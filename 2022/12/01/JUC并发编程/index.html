<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC 并发编程 | Hexo</title><meta name="keywords" content="JUC"><meta name="author" content="YuanJW"><meta name="copyright" content="YuanJW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JUC并发编程理论基础线程和进程进程 进程是程序的一次执行过程，是系统运行程序的基本单位，进程是动态的，操作系统运行一个程序即一个进程从创建、运行到消亡的过程。 在操作系统上，可以同时运行很多进程，每个进程之间相互隔离互不干扰，CPU通过时间片轮转算法，为每一个进程分配时间片，并在时间片使用结束后切换下一个进程继续执行，通过这种方式实现宏观上的多个线程同时运行。 每个进程都有自己独立的内存空间，并">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC 并发编程">
<meta property="og:url" content="http://example.com/2022/12/01/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JUC并发编程理论基础线程和进程进程 进程是程序的一次执行过程，是系统运行程序的基本单位，进程是动态的，操作系统运行一个程序即一个进程从创建、运行到消亡的过程。 在操作系统上，可以同时运行很多进程，每个进程之间相互隔离互不干扰，CPU通过时间片轮转算法，为每一个进程分配时间片，并在时间片使用结束后切换下一个进程继续执行，通过这种方式实现宏观上的多个线程同时运行。 每个进程都有自己独立的内存空间，并">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/default-cover/23.png">
<meta property="article:published_time" content="2022-12-01T00:31:22.000Z">
<meta property="article:modified_time" content="2023-06-15T05:52:22.739Z">
<meta property="article:author" content="YuanJW">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default-cover/23.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/01/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC 并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-15 13:52:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default-cover/23.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC 并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-01T00:31:22.000Z" title="Created 2022-12-01 08:31:22">2022-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-15T05:52:22.739Z" title="Updated 2023-06-15 13:52:22">2023-06-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC 并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><blockquote>
<p>进程是程序的一次执行过程，是系统运行程序的基本单位，进程是<strong>动态</strong>的，操作系统运行一个程序即一个进程从<strong>创建</strong>、<strong>运行</strong>到<strong>消亡</strong>的过程。</p>
<p>在操作系统上，可以同时运行很多进程，每个进程之间<strong>相互隔离互不干扰</strong>，CPU通过<strong>时间片轮转</strong>算法，为每一个进程分配时间片，并在时间片使用结束后切换下一个进程继续执行，通过这种方式实现宏观上的多个线程同时运行。</p>
<p>每个进程都有自己<strong>独立的内存空间</strong>，并且进程之间的通信非常麻烦（例如共享某些数据），而且CPU执行不同进程会产生<strong>上下文切换</strong>，非常耗时。</p>
</blockquote>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><blockquote>
<p>后来线程横空出世，一个进程可以有多个线程，线程是一个比进程<strong>更小的执行单位</strong>，线程是程序执行中一个<strong>单一的顺序控制流程</strong>，与进程不同的是，各个线程之间<strong>共享程序的内存空间</strong>即共享进程所在内存空间。在同一JVM进程中，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区资源</strong>，每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。因此，系统中产生一个线程或是中各个线程之间切换工作时，负担要比进程小得多，上下文切换的速度也高于进程，所以线程也称为轻量级进程。</p>
</blockquote>
<blockquote>
<p>在Java中，当我们启动main函数时，其实就是启动一个JVM进程，而main函数所在的线程就是这个进程的一个线程，这个main函数所在的线程也称为主线程。</p>
</blockquote>
<h5 id="使用线程达到数组排序效果"><a href="#使用线程达到数组排序效果" class="headerlink" title="使用线程达到数组排序效果"></a>使用线程达到数组排序效果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用线程达到数组排序效果</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(i * <span class="number">1000</span>);</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用JMX查看Java程序的线程"><a href="#使用JMX查看Java程序的线程" class="headerlink" title="使用JMX查看Java程序的线程"></a>使用JMX查看Java程序的线程</h5><blockquote>
<p>一个Java程序的运行是main线程和多个其他线程同时运行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Java虚拟机线程系统的托管bean</span></span><br><span class="line">    <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">    <span class="comment">// 返回所有活动线程的线程信息，包括堆栈跟踪和同步信息 不需要获取同步的 monitor 和 synchronizer 信息</span></span><br><span class="line">    ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;] &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/14/Prwv9xbjWElViOs.png" alt="image-20230414144520721"></p>
<h5 id="JUC工具类"><a href="#JUC工具类" class="headerlink" title="JUC工具类"></a>JUC工具类</h5><blockquote>
<p>Java5新增了<code>java.util.concurrent</code>即JUC包，其中包含了大量用于多线程编程的工具类，目的是为了更好的支持高并发，减少在操作多线程时竞争条件和死锁的问题。</p>
</blockquote>
<h3 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h3><blockquote>
<p>JMM内存模型和JVM中的内存模型不在同一层次上，JVM的内存模型是虚拟机规范对整个内存区域的规划，而Java内存模型是JVM内存模型之上的抽象模型，具体实现依然是基于JVM内存模型。</p>
</blockquote>
<h4 id="Java内存模型抽象"><a href="#Java内存模型抽象" class="headerlink" title="Java内存模型抽象"></a>Java内存模型抽象</h4><blockquote>
<p>在Java中，所有实例域，静态域和数组元素存储在虚拟机<strong>堆内存</strong>中，堆内存在<strong>线程之间共享</strong>。（注意：局部变量，方法定义参数和异常处理器参数不存储在虚拟机堆内存中，线程之间不共享，他们不会有内存可见性问题，不受内存模型的影响）。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/05/16/ihg38vKeXmV5JYN.jpg" alt="image"></p>
<p>从抽象的角度来看，JMM定义了线程与主内存之间的抽象关系：线程之间的<strong>共享变量</strong>存储在<strong>主内存</strong>中，每个<strong>线程</strong>都有一个<strong>私有的本地内存</strong>（local memory），<strong>本地内存</strong>中存储了该线程<strong>以读 / 写共享变量</strong>的<strong>副本</strong>。</p>
<p>Java线程之间的通信由Java内存模型（即JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。</p>
<p><img src="https://s2.loli.net/2023/05/16/muxcGzKCB6TpaNo.png" alt="img"></p>
<p><img src="https://s2.loli.net/2023/05/16/XN8VbTC2tyMxp16.png" alt="image-20230516144248491"></p>
<p>本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。</p>
<p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序提供内存可见性保证。</p>
<h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><blockquote>
<p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，操作的结果是不一致的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/20/GJnrC7i9Ke8kIOq.png" alt="image-20230420141456559"></p>
<h4 id="并发问题根源"><a href="#并发问题根源" class="headerlink" title="并发问题根源"></a>并发问题根源</h4><blockquote>
<p>并发三要素：<code>可见性-CPU缓存引起</code>,<code>原子性-分时复用引起</code>,<code>有序性-重排序引起</code></p>
</blockquote>
<h5 id="可见性：CPU缓存引起"><a href="#可见性：CPU缓存引起" class="headerlink" title="可见性：CPU缓存引起"></a>可见性：CPU缓存引起</h5><blockquote>
<p> 可见性：一个线程对共享变量修改时，其他线程可以立即看到</p>
</blockquote>
<p>当线程1修改一个共享变量时，会将这个共享变量的初始值从<strong>主内存加载到高速缓存</strong>中，然后修改赋值，此时高速缓存的发生了修改却<strong>没有立即刷新到主内存</strong>中，线程2从主内存中查看或者读取修改这个共享变量时，没有立即看到线程1修改的值，发生了<strong>可见性问题</strong></p>
<h5 id="原子性：分时复用引起"><a href="#原子性：分时复用引起" class="headerlink" title="原子性：分时复用引起"></a>原子性：分时复用引起</h5><blockquote>
<p>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p>
</blockquote>
<p>由于CPU分时服用即<strong>线程切换</strong>的存在，</p>
<h5 id="有序性：重排序引起"><a href="#有序性：重排序引起" class="headerlink" title="有序性：重排序引起"></a>有序性：重排序引起</h5><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h4 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h4><p><img src="https://s2.loli.net/2023/04/17/E49MtzBCjwQFbPY.png" alt="image"></p>
<h5 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h5><blockquote>
<p>创建后尚未启动</p>
</blockquote>
<h5 id="可运行（Runnbale）"><a href="#可运行（Runnbale）" class="headerlink" title="可运行（Runnbale）"></a>可运行（Runnbale）</h5><blockquote>
<p>可能正在运行或者正在等待CPU时间片（包含了操作系统线程状态中的Running和Ready）</p>
</blockquote>
<h5 id="阻塞（Blocking）"><a href="#阻塞（Blocking）" class="headerlink" title="阻塞（Blocking）"></a>阻塞（Blocking）</h5><blockquote>
<p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态</p>
</blockquote>
<h5 id="限期等待（Timed-Waiting）"><a href="#限期等待（Timed-Waiting）" class="headerlink" title="限期等待（Timed Waiting）"></a>限期等待（Timed Waiting）</h5><blockquote>
<p>无需等待其他线程显示地唤醒，在一定时间之后会被系统自动唤醒</p>
</blockquote>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep()方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了Timeout参数的Object.wait()方法</td>
<td>时间结束/Object.notify()/Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束/被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos()方法</td>
<td>-</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>-</td>
</tr>
</tbody></table>
<blockquote>
<p>调用Thread.sleep()方法使线程进入限制等待状态时即“使一个线程睡眠”</p>
<p>调用Object.wait()方法使线程进入限期等待或者无限制等待即“使一个线程挂起”</p>
<p>调用Thread.join()方法使线程无限等待阻塞当目标线程执行完毕即“使一个线程等待目标线程执行完毕”</p>
</blockquote>
<h5 id="无限期等待（Waiting）"><a href="#无限期等待（Waiting）" class="headerlink" title="无限期等待（Waiting）"></a>无限期等待（Waiting）</h5><blockquote>
<p>等待其他线程显示地唤醒，否则不会被分配CPU时间片</p>
</blockquote>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置Timeout参数的Object.wait()方法</td>
<td>Object.notify()/Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置Timeout参数的Thread.join()方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park()方法</td>
<td>-</td>
</tr>
</tbody></table>
<h5 id="死亡（Terminated）"><a href="#死亡（Terminated）" class="headerlink" title="死亡（Terminated）"></a>死亡（Terminated）</h5><blockquote>
<p>线程结束任务或者产生异常而结束</p>
</blockquote>
<h4 id="线程使用方式"><a href="#线程使用方式" class="headerlink" title="线程使用方式"></a>线程使用方式</h4><blockquote>
<p>Runnable接口和Callable接口类只能当作一个线程中运行的任务，不是真正意义上的线程，需要通过Thread调用，任务通过线程驱动从而执行的。</p>
</blockquote>
<ul>
<li><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5></li>
</ul>
<blockquote>
<p>创建类继承Thread类重写run方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过Thread调用start()方法来启动线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程的三种方式</span></span><br><span class="line">    <span class="comment">// 方式一：继承Thread重写run方法</span></span><br><span class="line">    <span class="type">Thread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5></li>
</ul>
<blockquote>
<p>实现Runnable接口来实现run方法，通过Thread调用start()方法来启动线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 方式二：实现Runnable接口</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5></li>
</ul>
<blockquote>
<p>与Runnable相比，Callable可以有返回值，返回值通过<code>FutureTask</code>进行封装</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 方式三：实现Callable接口并用FutureTask封装</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;线程3执行结束&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现接口和继承重写"><a href="#实现接口和继承重写" class="headerlink" title="实现接口和继承重写"></a>实现接口和继承重写</h5><blockquote>
<p>实现接口更好一点</p>
<ul>
<li>Java不支持多重继承，继承Thread类就无法继承其它类，但可以实现多个接口</li>
<li>子类可能只要求可执行就好，继承整个Thread类的开销较大</li>
</ul>
</blockquote>
<h4 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><blockquote>
<p>Executor管理多个异步任务的执行，无需程序显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作</p>
</blockquote>
<p>主要的三种Executor：</p>
<blockquote>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为1的FixedThreadPool</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Deamon"><a href="#Deamon" class="headerlink" title="Deamon"></a>Deamon</h5><blockquote>
<p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也会终止，同时杀死所有守护线程。</p>
<p>main()属于非守护线程，使用setDaemon()方法将一个线程设置为守护线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;daemon&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><blockquote>
<p>Thread.sleep(millisec)方法会休眠当前正在执行线程。</p>
<p>sleep()可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。</p>
<p>线程的其他异常也同样需要在本地进行处理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><blockquote>
<p>对静态方法Thread.yield()的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换其他线程来执行。</p>
<p>该方法只是对线程调度器的一个建议，只是建议具有相同优先级的其他线程可以运行。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/18/vL7XANInVf48bqo.png" alt="image-20230418133835836"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Thread.yield();;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><blockquote>
<p>一个线程执行完毕后回自动结束，如果在运行过程中发生异常也会提前结束。</p>
</blockquote>
<h5 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt()"></a>Interrupt()</h5><blockquote>
<p>通过调用一个线程的interrupt()来中断该线程，当该线程处于阻塞、无限阻塞或者无限期等待状态，就会抛出<code>InterruptedException</code>，从而提前结束该线程。但是不能中断I/O阻塞和synchronized锁阻塞。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/18/Mid7pzyAm5bJj3u.png" alt="image-20230418135635517"></p>
<blockquote>
<p>当中断一个处于阻塞、限期阻塞或者无限期等待的状态的线程，将会抛出<code>InterruptedException</code>异常。</p>
</blockquote>
<h5 id="Interrupted"><a href="#Interrupted" class="headerlink" title="Interrupted()"></a>Interrupted()</h5><blockquote>
<p>如果一个线程的run()方法执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;wait interrupted&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/18/rcBh4AENuyJUXmI.png" alt="image-20230418141100474"></p>
<h5 id="Executor的中断操作"><a href="#Executor的中断操作" class="headerlink" title="Executor的中断操作"></a>Executor的中断操作</h5><blockquote>
<p>调用Executor的<code>shutdown()</code>方法会等待线程<strong>执行完毕</strong>后再关闭，如果调用<code>shotdownNow()</code>方法，相当于调用每个线程的interrupt()方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/18/DjetMumKpwbNia3.png" alt="image-20230418170443315"></p>
<blockquote>
<p>如果只想中断Executor中的一个线程，可以通过使用submit()方法来提交一个线程，它会返回一个Future&lt;?&gt;对象，通过调用该对象的cancel(true)方法可以中断线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;?&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    future.cancel(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程互斥同步"><a href="#线程互斥同步" class="headerlink" title="线程互斥同步"></a>线程互斥同步</h4><blockquote>
<p>Java提供了两种锁机制来控制多个线程对共享资源的互斥访问。</p>
<p>第一个是JVM实现的sychronized，第二个是JDK实现的ReentrantLock。</p>
</blockquote>
<h5 id="Sychronized"><a href="#Sychronized" class="headerlink" title="Sychronized"></a>Sychronized</h5><h6 id="同步一个代码块"><a href="#同步一个代码块" class="headerlink" title="同步一个代码块"></a>同步一个代码块</h6><blockquote>
<p>只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>当使用ExecutorService执行了两个线程，由于调用的是同一个对象的同步代码块，因此两个线程会进行同步，当一个线程进入同步语句块，另一个线程必须等待。</p>
<p>当使用ExecutorService执行两个线程调用了不同对象的同步代码块，因此两个线程不需要同步，两个代码交叉执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SychronizedBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/18/H7Sa2t35EVcuz8b.png" alt="image-20230418234154610"></p>
<p><img src="https://s2.loli.net/2023/04/18/JcHNva9z7VQgjBq.png" alt="image-20230418234223220"></p>
<h6 id="同步一个方法"><a href="#同步一个方法" class="headerlink" title="同步一个方法"></a>同步一个方法</h6><blockquote>
<p>它和同步代码块一样，作用于同一对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SychronizedFuncExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">func</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/18/Du3cSwrj6thqZAv.png" alt="image-20230418234523882"></p>
<h6 id="同步一个类"><a href="#同步一个类" class="headerlink" title="同步一个类"></a>同步一个类</h6><blockquote>
<p>作用于整个类，两个线程调用同一个类的不同对象也会进行同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SychronizedClazzExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SychronizedClazzExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/18/h6yCgwmOWsPKT9B.png" alt="image-20230418234953882"></p>
<h6 id="同步一个静态方法"><a href="#同步一个静态方法" class="headerlink" title="同步一个静态方法"></a>同步一个静态方法</h6><blockquote>
<p>静态方法作用于整个类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SychronizedStaticFuncExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/18/lje9zHJuqRtxcON.png" alt="image-20230418235152312"></p>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><blockquote>
<p><code>ReentrantLock</code>是java.util.concurrent(J.U.C)包中锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 确保释放锁，从而避免发生死锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLockExample</span> <span class="variable">reentrantLockExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; reentrantLockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; reentrantLockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Sychronized和ReentrantLock比较"><a href="#Sychronized和ReentrantLock比较" class="headerlink" title="Sychronized和ReentrantLock比较"></a>Sychronized和ReentrantLock比较</h5><h6 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h6><blockquote>
<p><code>synchronized</code>是JVM实现的，而<code>ReentrantLock</code>是JDK实现的</p>
</blockquote>
<h6 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h6><blockquote>
<p>Java对synchronized进行了很多优化，例如自旋锁，轻量级锁等，synchronized与ReentrantLock大致相同。</p>
</blockquote>
<h6 id="等待可中断"><a href="#等待可中断" class="headerlink" title="等待可中断"></a>等待可中断</h6><blockquote>
<p>当持有锁的线程长期不释放锁时候，正在等待的线程选择放弃等待，改为处理其他事情</p>
<p>ReentrantLock可以中断，而synchronized不可以中断。</p>
</blockquote>
<h6 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h6><blockquote>
<p>公平锁是指多个线程在等待同一锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
</blockquote>
<h6 id="锁绑定多个条件"><a href="#锁绑定多个条件" class="headerlink" title="锁绑定多个条件"></a>锁绑定多个条件</h6><blockquote>
<p>一个ReetrantLock可以同时绑定多个Condition对象</p>
</blockquote>
<h5 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h5><blockquote>
<p>除非需要使用RetraintLock的高级特性，否则优先使用sychronized.</p>
<p>因为synchronized是JVM实现的一种锁机制，JVM原生地支持它；而ReentrantLock不是所有的JDK版本都支持。在使用ReetrantLock需要在finally代码块中完成锁的释放，而由于JVM会确保锁的释放，无论在没目标代码执行完还是发生异常的情况下，使用sychronized不用担心没有释放锁造成死锁问题，</p>
</blockquote>
<h4 id="线程之间协作"><a href="#线程之间协作" class="headerlink" title="线程之间协作"></a>线程之间协作</h4><blockquote>
<p>多个线程一起工作去解决某个问题时，如果某些部分必须在其它部分<strong>之前完成</strong>，那么就需要对线程进行<strong>协调</strong>。</p>
</blockquote>
<h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/19/UAJrDzuiHkg78Pl.png" alt="image-20230419102026662"></p>
<h5 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h5><blockquote>
<p>调用wait()使得线程等待某个条件满足，线程在等待时被挂起，当其他线程的运行使得某个条件满足时，其他线程会调用notify()或者notifyAll()来唤醒挂起的线程。</p>
<p>wait()、notify()、notifyAll()都属于对象Object的一部分，但是不属于Thread。它们只能在同步方法或者同步控制块中使用，否则会在运行时抛出IllegalMonitorStateExeception。</p>
<p>使得wait()挂起期间，线程会<strong>释放锁</strong>。因为如果没有释放锁，其他线程就没有办法进入对象的同步方法或者同步控制块中，无法执行notify()或者notifyAll()来唤醒挂起的线程，造成死锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;notify&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/19/S4jWahQgbp38oPA.png" alt="image-20230419130223957"></p>
<h6 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h6><ul>
<li>wait()是Object方法，而sleep()是Thread的静态方法</li>
<li>wait()是释放锁（其他进程需要进入对象的同步方法或者同步代码块执行notify()或者notigyAll()操作唤挂起的线程，防止死锁），sleep()是不会释放锁</li>
</ul>
<h5 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h5><blockquote>
<p>JUC类库中提供了Condition类来实现线程之间的协调，可以在Condition上调用await()方法是线程等待，其他线程调用signal()和signalAll()方法来唤醒等待的线程。</p>
<p>相比于wait()，await可以指定等待的条件，更加灵活。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwaitSignalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;await&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/19/kqagLXm9h1URMoJ.png" alt="image-20230419164632799"></p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><p>同一时间只能处理一个任务，依次完成所有的任务</p>
<p><img src="https://s2.loli.net/2023/04/14/YIGzaAWT5NybtEH.jpg" alt="image-20220301213629649"></p>
<h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><p>同一时间只能处理一个任务，每个任务轮着做（时间片轮换），宏观上就是三个任务同时进行</p>
<p><img src="https://s2.loli.net/2023/04/14/s5but2QUVZMy1pA.png" alt="image-20230414150044434">    </p>
<h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>同一时间可以处理多个任务</p>
<p><img src="https://s2.loli.net/2023/04/14/UfN6dFwzxT1MhXR.jpg" alt="image-20220301214238743"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><blockquote>
<p>C程序代码中，我们利用操作系统提供的互斥锁实现同步块的互斥访问以及线程的阻塞以及唤醒等工作，Java在语法层面上提供了<code>Synchronized</code>关键字来实现互斥同步原语。</p>
</blockquote>
<h4 id="Synchronized使用"><a href="#Synchronized使用" class="headerlink" title="Synchronized使用"></a>Synchronized使用</h4><blockquote>
<p>一把锁只能同时被一个线程获取，没有获得锁的线程只能阻塞等待。</p>
<p>每个实例都有对应的自己的一把锁，不同的实例之间互不影响（当锁对象是修饰类或者static方法时，所有对象公用同一把锁）。</p>
<p>Synchronized修饰的方法将在方法正常执行或者抛出异常，完成锁的释放。</p>
</blockquote>
<h5 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h5><p>包括方法锁和同步代码块锁</p>
<h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h5><h4 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h4><blockquote>
<p>深入JVM查看字节码，反编译查看monitor指令</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/14/9f4dH3Kpu1Q5MPr.png" alt="image-20230414151713225"></p>
<blockquote>
<p><code>Monitorenter</code>和<code>Monitorexit</code>指令：<code>Monitorenter</code>和<code>Monitorexit</code>分别对应着添加锁和释放锁</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/14/qj5bKPsFcR6OGHt.png" alt="image-20230414152322347"></p>
<blockquote>
<p>每个对象都有一个对象监视器与之对应，任意线程对对象进行访问时，首先获得对象的监视器，如果获取失败，该线程就进入同步队列，线程进入<strong>BLOCKED</strong>状态，当对象的监视器占有者释放后，在同步队列中的线程有机会重新获得该监视器。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/14/Lk7DzIcUFw5MsxW.webp" alt="img"></p>
<h5 id="Monitorenter"><a href="#Monitorenter" class="headerlink" title="Monitorenter"></a>Monitorenter</h5><blockquote>
<p>执行monitorentor需要尝试获取锁，获取锁的过程就是获取对象监视器的所有权，一旦监视器被某个线程持有，其他线程将无法获得。（管程模型）。</p>
<p>对象监视器中有一个计数器，当计数器为0时，表示目前没有被获取即没有被锁，获取对象监视器所有权后，执行monitorentor指令后会将监视器中的计数器加1，表示该对象的监视器已经被占有，别的线程获取需要等待，如果某线程获取到了对象的监控器的所有权，重入这把锁，对象监视器中计数器会累加，并随着重入的次数会一直累加。</p>
</blockquote>
<h5 id="Monitorexit"><a href="#Monitorexit" class="headerlink" title="Monitorexit"></a>Monitorexit</h5><blockquote>
<p>执行Monitorexit释放对象监控器的所有权，释放就是将对象监视器中的计数器减1，如果减完计数器不是0，表示是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该对象监视器的所有权，即释放锁。</p>
<p>正常释放锁执行Monitorexit会执行goto执行跳转到return执行，当出现异常时，执行释放锁并处理异常。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/14/AK8sCmycuZN2YkV.jpg" alt="image-20220302114613847"></p>
<h4 id="Sychronized存储结构"><a href="#Sychronized存储结构" class="headerlink" title="Sychronized存储结构"></a>Sychronized存储结构</h4><blockquote>
<p>Synchronized锁信息就存储在Java对象头上。 Java对象存储在堆内存中，每个对象内部有一部分空间用于存储对象头信息，而对象头的信息中，包含对象的锁信息，不同状态下，存储结构有所不用。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/14/yItdoqlT5WHuAgm.jpg" alt="image-20220302203846868"></p>
<h3 id="Synchronized锁的类型"><a href="#Synchronized锁的类型" class="headerlink" title="Synchronized锁的类型"></a>Synchronized锁的类型</h3><blockquote>
<p>在JavaSE1.6里Synchronied同步锁里，一共有四种状态：<code>无锁</code>、<code>偏向锁</code>、<code>轻量级锁</code>、<code>重量级锁</code>，它会随着竞争情况逐渐升级，锁可以升级但是但不可以降级，目的是为了提供获取锁的和释放锁的效率。</p>
<p>锁的膨胀方向：<strong>无锁</strong>-&gt;<strong>偏向锁</strong>-&gt;<strong>轻量级锁</strong>-&gt;<strong>重量级锁</strong>（此过程是<strong>不可逆</strong>的）</p>
</blockquote>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>在JDK1.6之前即没有加入锁优化时，Synchronized一直是重量级锁，对象监视器依赖于底层操作系统的Lock实现，Java线程是映射到操作系统的原生线程上，切换成本较高。</p>
<blockquote>
<p>每个对象有一个对应的对象监视器与之关联，在Java虚拟机中，对象监视器由ObjectMonitor实现。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">// 当前占有的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁释放的线程，会被加入到_EntryList</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个等待锁的线程都会封装成ObjectWaiter对象，当ObjectWaiter进入EntrySet，当线程获取到对象的对象监视器后进入The Owner区域并把将对象监视器中的owner变量设置为当前线程，同时将计数器count加1，如果The owner区域的线程调用wait()方法，会释放当前持有的对象监控器，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。</p>
<p>如果当前线程执行完毕会释放对象监控器，并复位变量以便其他线程进入获取对象的对象监视器。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/14/yui4XKpWBTMzERe.jpg" alt="img"></p>
<blockquote>
<p>在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，并且挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了极大的影响和压力。</p>
<p>由于在很多情况下，共享数据的锁定状态只会持续很短的时间，完全没有必要将竞争的线程挂起再唤醒。在多处理器的环境下，完全可以让另一个没有获取到锁的线程自旋一会即执行一个忙循环，但不释放CPU资源，不断检测是否可以获取锁，由于单个线程的占用锁的时间比较短，循环的次数不会太多，可能很快就可以拿到锁并运行。</p>
</blockquote>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><blockquote>
<p>自旋锁在JDK1.4中就引入，当时是默认关闭的，在JDK1.6就默认开启，自旋转本质和阻塞并不相同，阻塞需要将其他线程挂起并唤醒，如果锁占用时间非常短的话，自旋锁的性能将非常好，但是如果锁占用的时间较长的话，其会带来更多的性能开销（因为线程自旋时，会占用CPU的时间片，如果锁占用时间太长的话，自旋的线程会白白消耗CPU资源）。因此自旋等待的次数必须是有一定限度的，如果自旋超过了限定的次数仍然没有成功获取到锁，就会采用重量级锁的机制去挂起线程。在JDK定义中自旋锁默认的自旋次数为10次，可以使用参数<code>--XX:PreBlockSpin</code>更改。</p>
</blockquote>
<h5 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h5><blockquote>
<p>在JDK1.6中引入了自适应自旋锁，自旋锁得到了优化，自旋的时间不再固定，而是由前一次在同一锁上的自旋时间以及锁的拥有者的状态来决定。避免了线程锁在线程自旋结束刚好释放的问题。如果在同一个锁对象上，自旋等待刚好成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。相反，如果对于某一个锁，自旋很少成功获取锁，获取这个锁时将可能省略掉自旋过程，直接使用轻量级锁，以避免浪费处理器资源。</p>
</blockquote>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote>
<p>在JDK1.6后引入了轻量级锁，轻量级锁不是代替重量级锁，而是对在大多数同步代码块不会产生竞争的情况的一种优化，从而减少重量级锁对于线程阻塞带来的资源开销，提高并发性能。</p>
<p>理解轻量级锁的实现，需要了解HotSpot虚拟机中对象头的内存布局，在对象头（Object Header）中存在两部分，第一部分称为<code>Mark Word</code>，一般为32位或者64位，用于存储对象自身的运行时数据，包括HashCode、GC Age、锁标记位、是否为偏向锁等，这部分是实现轻量级锁和偏向锁的关键；另一部分称为<code>Klass point</code>，用于存储指向方法区对象类型数据的指针；如果该对象是数组，还会有一个额外部分用于存储数据的长度。</p>
</blockquote>
<h5 id="轻量级锁加锁原理"><a href="#轻量级锁加锁原理" class="headerlink" title="轻量级锁加锁原理"></a>轻量级锁加锁原理</h5><blockquote>
<p>在线程执行同步代码块的之前，首先会先检查对象<code>Mark WOrd</code>中锁对象的占用情况，如果没有被其他线程占用，锁标志位为01状态，JVM会先在当前线程所处的栈帧中创建一个名为<code>Lock Record</code>的锁记录的空间，用于存储锁对象目前<code>Mark Word</code>的拷贝（JVM将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>）。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/16/JSEsFgaZjxr3RIm.png" alt="img"></p>
<blockquote>
<p>虚拟机使用CAS操作将对象的标记字段<code>Mark Word</code>拷贝到锁记录中，并且将<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。如果更新成功，线程就拥有对象的锁，并且对象的<code>Mark Word</code>的锁标志位更新为00，即表示此对象处于轻量级锁定状态。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/16/uEXUeAHk213sDoK.png" alt="    "></p>
<blockquote>
<p>如果更新操作失败，JVM会检查当前对象的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针。如果有，说明该锁已经被该线程获取，可以直接调用；如果没有，则说明该锁被其他线程抢占。当有两条或以上的线程竞争同一锁，轻量级锁将膨胀为重量级锁，没有获取锁的线程将会被阻塞，此时，锁的标志位为<code>10.Mark Word</code>z中存储的指向重量级锁的指针。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/16/s7qPlfFeMTmXtdC.png" alt="img"></p>
<blockquote>
<p>轻量级锁解锁时，会使用原子CAS操作将<code>Displaced Mark Word</code>替换回到对象头中，如果成功，则表示没有发生竞争关系，如果失败，标识当前锁存在竞争关系，轻量级锁就会膨胀成重量级锁。</p>
</blockquote>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote>
<p>针对很多不存在多线程竞争，而是总是由同一线程多次获取锁的情况，为了避免同一线程反复获取锁释放锁带来的不必要的性能开销和上下文切换。Java1.6对于Synchronized进行了优化，引入了偏向锁，当一个线程访问同同步块并获取锁时，将在对象头和线程所在栈帧中的锁记录里存储锁偏向线程ID。之后该线程进入和退出同步代码块时，不需要进行CAS操作来加锁和解锁，只需要检查一下对象头的<code>Mark Word</code>里是否存储这指向当前线程的偏向锁（如果成功，则表示线程已经获取到了锁）。当检查对象的<code>Mark Word</code>里存储不是指向当前线程的偏向锁，偏向锁将膨胀为轻量级锁。</p>
<p>偏向锁的使用一般是添加<code>-XX:+UseBiased</code>参数开启</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/16/RL7g2oADWymbetz.png" alt="img"></p>
<blockquote>
<p>如果对象通过调用<code>hashCode()</code>方法计算出对象的一致性哈希值，那该对象不支持偏向锁，因为hashcode需要被保存，偏向锁的<code>Mark Word</code>结构无法保存hashcode，如果对象已经是偏向锁的状态，再调用<code>hashCode()</code>方法，偏向锁会直接膨胀为重量级锁，hashcode存放中monitor的对象中。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/17/1WxrYCi6ByZVz58.jpg" alt="image-20220302214647735"></p>
<h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><blockquote>
<p>偏向锁只有竞争出现才会释放锁，只有当其他线程尝试获取锁时，持有偏向锁的线程才会释放锁。</p>
<p>偏向锁的撤销需要达到全局安全点（即当前线程没有正在执行的字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否处于活动状态。如果线程不处于活动状态，直接将锁的对象头设置为无锁状态；如果线程处于活动状态，JVM将遍历线程所在栈帧中的锁记录，栈帧中的锁记录和锁的对象头偏向于其他线程，要么标记对象不适合作为偏向锁并将锁进行膨胀。    </p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/17/L2MH6cZDFl3SJvo.png" alt="img"></p>
<h4 id="各类锁的优缺点"><a href="#各类锁的优缺点" class="headerlink" title="各类锁的优缺点"></a>各类锁的优缺点</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>线程竞争不适用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了响应速度</td>
<td>如线程始终得不到锁竞争的线程，使用自旋会消耗CPU性能</td>
<td>最求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>只有一个线程访问同步块</td>
</tr>
</tbody></table>
<p><img src="https://s2.loli.net/2023/04/17/yB43FXSLRdlvJrA.png" alt="image-20230417005632265"></p>
<h4 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h4><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><blockquote>
<p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步但被检测到不可能存在共享数据竞争的锁进行消除。</p>
<p>锁消除的主要判定依据来源于逃逸分析的数据支持。JVM判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，JVM会把它们当作栈上的数据对待，认为这些数据是线程独有的，不需要加同步，进行锁消除。</p>
<p>在Java API中很多方法加了同步的，那么JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">test</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1+s2+s3;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：由于String是不可变类，对字符串的连续操作总是通过生成新的String对象来进行的，而在执行上诉代码块操作String数据类型时，Javac编译器会对String连接自动优化，在JDK1.5之前会使用StringBuffer对象的连续append()操作，但是在JDK1.5之后的版本，会转化为使用StringBuilder对象的连续append()操作。尽管StringBuilder不是安全同步的，但JVM判断上诉代码不会逃逸，则将该代码默认为线程独有资源，并不需要同步，所以执行消除操作。</p>
</blockquote>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><blockquote>
<p>原则上添加同步锁时，要尽可能将同步块的作用范围限制到尽量小的范围（只在共享数据的实际作用于域中才进行同步），使得需要同步的操作数尽可能变小，使得在存在锁竞争中，等待锁的线程尽早拿到锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">test</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">  <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  sb.append(s3);</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当如果存在连串的一系列操作对同一对象反复加锁和解锁，即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p>
<p>在上述的连续append()操作中属于这类情况，JVM检测这样一连串的操作都是同一个对象加锁，那么JVM会将加锁同步的范围扩展（粗化）到整个一系列操作的外部，使得一连串的append()操作只需加锁一次。</p>
</blockquote>
<h2 id="锁类"><a href="#锁类" class="headerlink" title="锁类"></a>锁类</h2><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Synchronized-1"><a href="#Synchronized-1" class="headerlink" title="Synchronized"></a>Synchronized</h3><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><p>​    </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">YuanJW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/01/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://example.com/2022/12/01/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="/img/default-cover/23.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/01/Redis%E5%AE%9E%E6%88%98/"><img class="prev-cover" src="/img/default-cover/26.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Redis实战</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/06/ElasticSearch/"><img class="next-cover" src="/img/default-cover/30.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">分布式搜索-ElasticSearch</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YuanJW</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XiaoYuanJW" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2754742370@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">JUC并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E8%BE%BE%E5%88%B0%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E6%95%88%E6%9E%9C"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">使用线程达到数组排序效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JMX%E6%9F%A5%E7%9C%8BJava%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">使用JMX查看Java程序的线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JUC%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text">JUC工具类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">JMM内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Java内存模型抽象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">线程不安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E6%A0%B9%E6%BA%90"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">并发问题根源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9ACPU%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">可见性：CPU缓存引起</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9A%E5%88%86%E6%97%B6%E5%A4%8D%E7%94%A8%E5%BC%95%E8%B5%B7"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">原子性：分时复用引起</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E5%BC%95%E8%B5%B7"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">有序性：重排序引起</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">线程状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%EF%BC%88New%EF%BC%89"><span class="toc-number">1.2.0.1.1.</span> <span class="toc-text">新建（New）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8C%EF%BC%88Runnbale%EF%BC%89"><span class="toc-number">1.2.0.1.2.</span> <span class="toc-text">可运行（Runnbale）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%EF%BC%88Blocking%EF%BC%89"><span class="toc-number">1.2.0.1.3.</span> <span class="toc-text">阻塞（Blocking）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85%EF%BC%88Timed-Waiting%EF%BC%89"><span class="toc-number">1.2.0.1.4.</span> <span class="toc-text">限期等待（Timed Waiting）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85%EF%BC%88Waiting%EF%BC%89"><span class="toc-number">1.2.0.1.5.</span> <span class="toc-text">无限期等待（Waiting）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E4%BA%A1%EF%BC%88Terminated%EF%BC%89"><span class="toc-number">1.2.0.1.6.</span> <span class="toc-text">死亡（Terminated）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">线程使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">1.2.0.2.1.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.0.2.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.0.2.3.</span> <span class="toc-text">实现Callable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99"><span class="toc-number">1.2.0.2.4.</span> <span class="toc-text">实现接口和继承重写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">基础线程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Executor"><span class="toc-number">1.2.0.3.1.</span> <span class="toc-text">Executor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Deamon"><span class="toc-number">1.2.0.3.2.</span> <span class="toc-text">Deamon</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sleep"><span class="toc-number">1.2.0.3.3.</span> <span class="toc-text">sleep()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield"><span class="toc-number">1.2.0.3.4.</span> <span class="toc-text">yield()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">线程中断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Interrupt"><span class="toc-number">1.2.0.4.1.</span> <span class="toc-text">Interrupt()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Interrupted"><span class="toc-number">1.2.0.4.2.</span> <span class="toc-text">Interrupted()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Executor%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.0.4.3.</span> <span class="toc-text">Executor的中断操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">线程互斥同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Sychronized"><span class="toc-number">1.2.0.5.1.</span> <span class="toc-text">Sychronized</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.2.0.5.1.1.</span> <span class="toc-text">同步一个代码块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.0.5.1.2.</span> <span class="toc-text">同步一个方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-number">1.2.0.5.1.3.</span> <span class="toc-text">同步一个类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.0.5.1.4.</span> <span class="toc-text">同步一个静态方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.2.0.5.2.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sychronized%E5%92%8CReentrantLock%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.0.5.3.</span> <span class="toc-text">Sychronized和ReentrantLock比较</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.0.5.3.1.</span> <span class="toc-text">锁的实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">1.2.0.5.3.2.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%8F%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.0.5.3.3.</span> <span class="toc-text">等待可中断</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.2.0.5.3.4.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.0.5.3.5.</span> <span class="toc-text">锁绑定多个条件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.0.5.4.</span> <span class="toc-text">使用选择</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%8D%8F%E4%BD%9C"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">线程之间协作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#join"><span class="toc-number">1.2.0.6.1.</span> <span class="toc-text">join()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait-notify-notifyAll"><span class="toc-number">1.2.0.6.2.</span> <span class="toc-text">wait() notify() notifyAll()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#wait-%E5%92%8Csleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.0.6.2.1.</span> <span class="toc-text">wait()和sleep()的区别</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await-signal-signalAll"><span class="toc-number">1.2.0.6.3.</span> <span class="toc-text">await() signal() signalAll()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.2.1.</span> <span class="toc-text">并发和并行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">顺序执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">并发执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">并行执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized"><span class="toc-number">1.3.1.</span> <span class="toc-text">Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Synchronized使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">对象锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E9%94%81"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">类锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Synchronized原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Monitorenter"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">Monitorenter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Monitorexit"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">Monitorexit</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sychronized%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">Sychronized存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">Synchronized锁的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">自适应自旋锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">轻量级锁加锁原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">偏向锁的撤销</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">各类锁的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">锁消除和锁粗化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">1.3.2.5.1.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">1.3.2.5.2.</span> <span class="toc-text">锁粗化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">锁类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.5.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">Synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile"><span class="toc-number">1.5.2.</span> <span class="toc-text">Volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.5.3.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">1.6.</span> <span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">并发容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.8.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.9.</span> <span class="toc-text">并发工具</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux常用命令"><img src="/img/default-cover/15.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux常用命令"/></a><div class="content"><a class="title" href="/2023/06/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux常用命令">Linux常用命令</a><time datetime="2023-06-10T02:31:22.000Z" title="Created 2023-06-10 10:31:22">2023-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring%E5%8E%9F%E7%90%86/" title="Spring 原理"><img src="/img/default-cover/33.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring 原理"/></a><div class="content"><a class="title" href="/2023/05/24/Spring%E5%8E%9F%E7%90%86/" title="Spring 原理">Spring 原理</a><time datetime="2023-05-24T12:35:22.000Z" title="Created 2023-05-24 20:35:22">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/10/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/" title="阅读源码-@Transaction"><img src="/img/default-cover/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阅读源码-@Transaction"/></a><div class="content"><a class="title" href="/2023/05/10/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/" title="阅读源码-@Transaction">阅读源码-@Transaction</a><time datetime="2023-05-10T09:30:00.000Z" title="Created 2023-05-10 17:30:00">2023-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/04/ELK/" title="ELK"><img src="/img/default-cover/44.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ELK"/></a><div class="content"><a class="title" href="/2023/05/04/ELK/" title="ELK">ELK</a><time datetime="2023-05-04T07:31:22.000Z" title="Created 2023-05-04 15:31:22">2023-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/27/XXL-JOB/" title="XXL-JOB"><img src="/img/default-cover/59.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XXL-JOB"/></a><div class="content"><a class="title" href="/2023/04/27/XXL-JOB/" title="XXL-JOB">XXL-JOB</a><time datetime="2023-04-27T07:31:22.000Z" title="Created 2023-04-27 15:31:22">2023-04-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By YuanJW</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>