<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>jvm 基础 | Hexo</title><meta name="keywords" content="jvm"><meta name="author" content="YuanJW"><meta name="copyright" content="YuanJW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="jvm 基础初始jvmjvm职责 jvm - java virtual machine 即 java虚拟机，是 经过java编译器（javac）编译后的 java程序 的运行环境。 jvm 是运行在计算机上的程序，他是运行 java字节码的程序，他的职责是运行即将 已经经过java编译器（javac）编译的字节码文件（.class文件）进行加载和执行时解释，执行时通过JIT（just-in-tim">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm 基础">
<meta property="og:url" content="http://example.com/2023/12/28/jvm-1-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="jvm 基础初始jvmjvm职责 jvm - java virtual machine 即 java虚拟机，是 经过java编译器（javac）编译后的 java程序 的运行环境。 jvm 是运行在计算机上的程序，他是运行 java字节码的程序，他的职责是运行即将 已经经过java编译器（javac）编译的字节码文件（.class文件）进行加载和执行时解释，执行时通过JIT（just-in-tim">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/default-cover/45.png">
<meta property="article:published_time" content="2023-12-27T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-07T08:21:19.807Z">
<meta property="article:author" content="YuanJW">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default-cover/45.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/28/jvm-1-%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jvm 基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-07 16:21:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default-cover/45.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">jvm 基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-12-27T16:00:00.000Z" title="Created 2023-12-28 00:00:00">2023-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-03-07T08:21:19.807Z" title="Updated 2024-03-07 16:21:19">2024-03-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="jvm 基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="jvm-基础"><a href="#jvm-基础" class="headerlink" title="jvm 基础"></a>jvm 基础</h1><h2 id="初始jvm"><a href="#初始jvm" class="headerlink" title="初始jvm"></a>初始jvm</h2><h3 id="jvm职责"><a href="#jvm职责" class="headerlink" title="jvm职责"></a>jvm职责</h3><blockquote>
<p>jvm - java virtual machine 即 java虚拟机，是 经过java编译器（javac）编译后的 java程序 的运行环境。</p>
<p>jvm 是运行在计算机上的程序，他是运行 java字节码的程序，他的职责是运行即将 已经经过java编译器（javac）编译的字节码文件（.class文件）进行加载和执行时解释，执行时通过JIT（just-in-time compilation - 即时编译技术）将字节码解释成机器码，以便于计算机能够理解和执行。</p>
</blockquote>
<p>在正常项目过程中，我们会先将java工程编译并打包成jar文件（jar即是包含经过编译后的字节码，资源文件以及相关文件的打包在一起的一种文件格式），jar部署在jvm虚拟机上运行，由于jvm部署所在的计算机无法直接执行字节码（字节码是由一组针对jvm设计的指令构成 - 虚拟机指令），所以jvm需要加载并通过JIT即时编译技术将字节码解释成机器码，交给计算机理解和执行。</p>
<p>因此，java程序不能直接在计算机上运行的，而是编译后通过jvm加载并执行。</p>
<img src="https://s2.loli.net/2023/12/28/krslc3HymnoNvdK.png" alt="image-20231228163553436" style="zoom: 33%;" />

<p>正是因为 针对不同程序的不同编译器所编译成的相同字节码文件 和 针对不同操作系统的jvm的加载和解释 使得java程序具有跨平台性即可以在不同的操作系统上运行。</p>
<img src="https://s2.loli.net/2023/12/28/vWS4grG7C3no5kR.png" alt="image-20231228163900743" style="zoom: 33%;" />

<h3 id="jvm功能"><a href="#jvm功能" class="headerlink" title="jvm功能"></a>jvm功能</h3><p>上文，我们知道jvm的功能之一就是：</p>
<ul>
<li>加载字节码文件的指令并实时解释成机器码交给计算机执行（解释过程支持通过JIT即时编译进行优化，提升热点代码的执行效率）</li>
</ul>
<p>其他功能还有：</p>
<ul>
<li>自动为对象和方法等分配内存，并配合垃圾回收机制回收不再使用的对象</li>
</ul>
<h3 id="java-vs-c"><a href="#java-vs-c" class="headerlink" title="java vs c"></a>java vs c</h3><p>由于java程序需要编译后成字节码（.class）通过jvm加载并实时解释，解释成计算机可以执行的机器码才可以执行；而c程序可以直接编译为计算机可以直接执行的可执行文件(.exe)，即c程序无需加载和解释，c程序的性能要高于java程序。</p>
<p>但是java之所以保持编译字节码和jvm解释的特性，主要目的是支持跨平台，”一次编译，随处运行”。</p>
<h3 id="jit-即时编译"><a href="#jit-即时编译" class="headerlink" title="jit - 即时编译"></a>jit - 即时编译</h3><p>由于 java 在性能上的不足主要是由于 jvm解释 的过程导致的，java 后面引入了 jit （just-in-time compilation - 即时编译技术)：</p>
<p>jvm对于热点字节码进行解释并优化成机器码，并将这个机器码保存在内存中，当再此执行时直接从内存中加载出来直接交给计算机执行，从而节省了对于热点代码解释的工作，大幅度提升了java程序的性能。</p>
<img src="https://s2.loli.net/2023/12/29/AsgvBqfx7dC2eRl.png" alt="image-20231228170508653" style="zoom: 33%;" />

<h3 id="常见的jvm"><a href="#常见的jvm" class="headerlink" title="常见的jvm"></a>常见的jvm</h3><img src="https://s2.loli.net/2023/12/29/Mp5Z7HYwF1sWS6L.png" alt="image-20231228171714480" style="zoom: 50%;" />

<p>jvm有很多但是都要满足《<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">java虚拟机规范</a>》</p>
<p>上述虚拟机中，jdk默认的虚拟机是Hotspot - Oracle JDK，它是目前应用最广泛、稳定可靠的虚拟机。</p>
<h4 id="Hotspot-发展历程"><a href="#Hotspot-发展历程" class="headerlink" title="Hotspot 发展历程"></a>Hotspot 发展历程</h4><img src="https://s2.loli.net/2023/12/28/4FjVDeOXMlBTiZS.png" alt="image-20231228172947817" style="zoom:50%;" />

<h3 id="jvm-组成"><a href="#jvm-组成" class="headerlink" title="jvm 组成"></a>jvm 组成</h3><ul>
<li>类加载器 - class loader：<ul>
<li>功能：负责将 java字节码 加载到 jvm内存 中</li>
<li>分类：jvm类加载器分为三个层次：启动类加载器（bootstrap class loader）、扩展类加载器（extension class loader）和 应用程序类加载器（application class loader）</li>
</ul>
</li>
<li>运行时数据区 - runtime data area：<ul>
<li>功能：负责 管理分配给jvm的内存，存储和管理程序运行时所需要的数据</li>
<li>主要区域：<ul>
<li>方法区 - method area：存储类的结构信息，包括类的字段、方法、接口等</li>
<li>本地方法栈 - native method stack：执行本地方法</li>
<li>堆 - heap：存储对象实例</li>
<li>栈 - stack：存储局部变量、操作数栈、方法出口等</li>
<li>程序计数器 - program counter register：记录当前线程执行的字节码行号</li>
</ul>
</li>
</ul>
</li>
<li>执行引擎 - execution engine：<ul>
<li>功能：执行编译后的字节码<ul>
<li>主要组件：<ul>
<li>解释器 - interpreter：逐行解析字节码并执行</li>
<li>即时编译器 - just-in-time compiler（JIT compiler）：提供字节码即时编译，提高执行效率</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>本地接口 - native interface：<ul>
<li>功能：提供与本地库（如：c/c++）交互的接口或者方法，允许java代码调用    </li>
<li>例如：jvm 提供的c/c++方法</li>
</ul>
</li>
</ul>
<h2 id="字节码文件"><a href="#字节码文件" class="headerlink" title="字节码文件"></a>字节码文件</h2><h3 id="字节码文件定义"><a href="#字节码文件定义" class="headerlink" title="字节码文件定义"></a>字节码文件定义</h3><blockquote>
<p>字节码文件（.class 文件）是 源代码 经过编译之后的内容，是一个以8位字节为基础单位的二进制流即通过 二进制 方式存储。由于 并没有指定字符编码方式，所以无法直接通过记事本等工具打开。</p>
</blockquote>
<p>我们可以使用 <a target="_blank" rel="noopener" href="https://github.com/ingokegel/jclasslib/releases">jclasslib</a> 打开字节码文件</p>
<h3 id="字节码文件的组成"><a href="#字节码文件的组成" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h3><ul>
<li><p>基础信息：</p>
<ul>
<li><p>魔数 - Magic Number</p>
<ul>
<li><p>定义：每个class文件开头的4个字节（OxCAFEBABE）成为魔数 </p>
<p>​     由于文件名是可以随意修改的（但不会影响文件的内容），因此文件是无法通过文件扩展名来确定文件类型的。</p>
<p>​     因此魔术用于校验文件的类型，很多类型的文件都有自己对应的”魔术”</p>
</li>
<li><p>作用：确定文件是一个java编译后的class文件 即识别一个文件是否为特定的类型</p>
</li>
</ul>
</li>
<li><p>文件版本：</p>
<ul>
<li>定义：紧随着魔数的4个字节为 编译字节码文件 对应的jdk版本号，包括类主版本号和次版本号</li>
<li>作用：判断字节码文件的版本和运行时的版本是否兼容（jdk版本是向后的兼容，低版本无法加载运行高版本的字节码文件）</li>
</ul>
</li>
<li><p>访问标识 - Access Flags：</p>
<ul>
<li>定义：标识文件是类、接口还是枚举等，以及他的属性和访问类型</li>
</ul>
</li>
<li><p>类、父类、接口索引：</p>
<ul>
<li>定义：表示当前类、父类和实现接口在常量池中的索引</li>
<li>作用：确定类的继承关系</li>
</ul>
</li>
</ul>
</li>
<li><p>常量池 - Constant Pool：</p>
<ul>
<li><p>定义：常量池是一个表，存储了各种字面量和符号引用。它包括类名、方法名、字段名等信息。</p>
<p>​     常量池的索引从1开始，0被保留用于表示不引用任何常量。</p>
</li>
<li><p>作用：节省字节码文件部分空间，避免相同的内容重复定义，而只需要引用常量池中的内容</p>
</li>
</ul>
</li>
<li><p>字段表 - Field Table：</p>
<ul>
<li>作用：描述接口和类中声明的字段的名称、类型和访问修饰符等信息</li>
</ul>
</li>
<li><p>方法表 - Method Table：</p>
<ul>
<li>作用：描述接口和类中声明的方法的名称、类型、访问修饰符以及方法信息等</li>
</ul>
</li>
<li><p>属性表 - Attribute Table：</p>
<ul>
<li>作用：描述类、字段或方法等附加信息</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面以一个简单的例子来展示一下字节码文件的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleClass.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 javac 生成 字节码文件 SimpleClass.class</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac SimpleClass.java</span><br></pre></td></tr></table></figure>

<p>打卡生成的class文件</p>
<img src="https://s2.loli.net/2023/12/29/crV2UHXFJ5WmNqR.png" alt="image-20231229131338804" style="zoom: 50%;" />

<p>前4个字节（OxCAFEBABE）是 魔数，jvm判断并接受以”caff babe”开头的class文件，这四个字节的作用即字节码的身份识别。</p>
<p>紧接着的4个字节为编译器jdk的版本号，前2位（0x0000）是次版本号，后2位（0x0040）为主版本号，将0x0040转换为十进制为64，所以字节码文件编译器的jdk版本为20（64-44）。</p>
<p>使用 jclasslib 打开该字节码文件</p>
<h5 id="一般信息"><a href="#一般信息" class="headerlink" title="一般信息"></a>一般信息</h5><img src="https://s2.loli.net/2023/12/29/RoU8PSs9kgyNjOE.png" alt="image-20231229131543978" style="zoom:33%;" />

<h5 id="常量池引用"><a href="#常量池引用" class="headerlink" title="常量池引用"></a>常量池引用</h5><p>字段信息 引用常量池中的内容</p>
<p>常量池中放数据都有一个编号，编号从1开始。在指令中，可以通过编号快速找到引用的相应数据。</p>
<p>字节码指令可以通过编号引用到常量池的内容称之为 符号引用</p>
<img src="https://s2.loli.net/2023/12/29/1KAFIjflmbVaQcJ.png" alt="image-20231229132120760" style="zoom:33%;" />

<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>字节码文件的方法区存放了方法字节码指令</p>
<img src="https://s2.loli.net/2023/12/29/yVUaSgxRTWPrd2f.png" alt="image-20231229133815275" style="zoom:33%;" />

<h4 id="字节码指令执行分析"><a href="#字节码指令执行分析" class="headerlink" title="字节码指令执行分析"></a>字节码指令执行分析</h4><p>在理解字节码指令的流程，我们需要分析一下两个在jvm执行时相关的重要的概念：操作数栈（operand stack）和 局部变量表（local variable table）</p>
<p>操作数栈(栈)：用于存储方法执行过程中的操作数。各种指令将操作数压入或弹出操作数栈并进行相应的运算操作。</p>
<img src="https://s2.loli.net/2023/12/29/oWnQwxIMym7c8tF.png" alt="image-20231229142811892" style="zoom: 50%;" />

<p>局部变量表(数组)：用于存储方法中方法参数和方法定义的局部变量的表，每个方法执行前都会创建一个局部变量表。</p>
<p>​        当一个方法被调用时，方法的参数将被传递给局部变量表中的相应位置，并且方法内部的局部变量也会在表中占据一定的位置，供方法执行过程中使用。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>下面的代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部变量表如下：</p>
<img src="https://s2.loli.net/2023/12/29/eJb7BEvAXOcdCSD.png" alt="image-20231229141933896" style="zoom:33%;" />

<p>上面代码的字节码指令如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_0 # 将整数常量<span class="number">0</span>推送到操作数栈</span><br><span class="line"><span class="number">1</span> istore_1 # 从操作数栈弹出值，放入局部变量表位置<span class="number">1</span></span><br><span class="line"><span class="number">2</span> iload_1 # 局部变量表的位置<span class="number">1</span>加载整数值到操作数栈</span><br><span class="line"><span class="number">3</span> iconst_1 # 将整数常量<span class="number">1</span>推送到操作数栈</span><br><span class="line"><span class="number">4</span> iadd # 操作数栈栈顶弹出两个整数，相加，将结果推送回栈</span><br><span class="line"><span class="number">5</span> istore_2 # 从操作数栈弹出值，存储到局部变量表的位置<span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span> # 从当前方法返回，方法返回值在栈顶</span><br></pre></td></tr></table></figure>

<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  i = i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是i最终的赋值为0，下面从字节码指令的执行过程分析一下为什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_0 # 将整数常量<span class="number">0</span>推送到操作数栈</span><br><span class="line"><span class="number">1</span> istore_1 # 从操作数栈弹出值，存储到局部变量表的位置<span class="number">1</span></span><br><span class="line"><span class="number">2</span> iload_1 # 从局部变量表的位置<span class="number">1</span>加载整数值到操作数栈</span><br><span class="line"><span class="number">3</span> iinc <span class="number">1</span> by <span class="number">1</span> # 局部变量表的位置<span class="number">1</span>中的整数值增加<span class="number">1</span> </span><br><span class="line"><span class="number">6</span> istore_1 # 从操作数栈弹出值，存储到局部变量表的位置<span class="number">1</span> (此处和上一步是关键)</span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>局部变量表的位置1的整数直接加1，操作栈的数保持不变直接弹出存储到局部变量表位置1中，覆盖掉了自增后的值</p>
<p>对比 i = ++i 的指令，指令是先自增再加载到操作栈中，因此i等于1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_0</span><br><span class="line"><span class="number">1</span> istore_1</span><br><span class="line"><span class="number">2</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">5</span> iload_1</span><br><span class="line"><span class="number">6</span> istore_1</span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="字节码文件常见的工具"><a href="#字节码文件常见的工具" class="headerlink" title="字节码文件常见的工具"></a>字节码文件常见的工具</h3><p>除了上文提到了 jclasslib 工具外，还有很多工具可以查看并分析字节码文件，它们的适用场景各不相同。</p>
<h4 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h4><blockquote>
<p>javap 的 jdk 内置的反编译工具，可以反编译字节码文件并通过控制台查看字节码文件的内容。</p>
<p>语法：javap <options> <classes></p>
<p>适用：适合在服务器上查看字节码文件内容</p>
</blockquote>
<p>options 的选项如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--help -help -h -?               输出此帮助消息</span><br><span class="line">-version                         版本信息</span><br><span class="line">-v  -verbose                     输出附加信息</span><br><span class="line">-l                               输出行号和本地变量表</span><br><span class="line">-public                          仅显示公共类和成员</span><br><span class="line">-protected                       显示受保护的/公共类和成员</span><br><span class="line">-package                         显示程序包/受保护的/公共类</span><br><span class="line">                                 和成员 (默认)</span><br><span class="line">-p  -private                     显示所有类和成员</span><br><span class="line">-c                               对代码进行反汇编</span><br><span class="line">-s                               输出内部类型签名</span><br><span class="line">-sysinfo                         显示正在处理的类的</span><br><span class="line">                                 系统信息（路径、大小、日期、SHA-256 散列）</span><br><span class="line">-constants                       显示最终常量</span><br><span class="line">--module &lt;module&gt;  -m &lt;module&gt;   指定包含要反汇编的类的模块</span><br><span class="line">-J&lt;vm-option&gt;                    指定 VM 选项</span><br><span class="line">--module-path &lt;路径&gt;             指定查找应用程序模块的位置</span><br><span class="line">--system &lt;jdk&gt;                   指定查找系统模块的位置</span><br><span class="line">--class-path &lt;路径&gt;              指定查找用户类文件的位置</span><br><span class="line">-classpath &lt;路径&gt;                指定查找用户类文件的位置</span><br><span class="line">-cp &lt;路径&gt;                       指定查找用户类文件的位置</span><br><span class="line">-bootclasspath &lt;路径&gt;            覆盖引导类文件的位置</span><br><span class="line">--multi-release &lt;version&gt;        指定要在多发行版 JAR 文件中使用的版本</span><br></pre></td></tr></table></figure>

<p>常见用法：</p>
<p>到服务器的指定jar包路径下，执行<code>jar -xvf</code>命令解压jar包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -xvf xx.jar</span><br></pre></td></tr></table></figure>

<p>执行解压后，会生成一个<code>BOOT_INF</code>目录，执行javap查看字节码信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p xx</span><br></pre></td></tr></table></figure>

<p>在终端控制台可能查看的效果不好，可以直接将展示的信息写入到txt文件中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p xx &gt; /xx/xx.txt</span><br></pre></td></tr></table></figure>

<h4 id="IDEA插件jclasslib"><a href="#IDEA插件jclasslib" class="headerlink" title="IDEA插件jclasslib"></a>IDEA插件jclasslib</h4><p>搜索安装插件后，编译代码，选中当前类，点击 视图 - Show Bytecode With Jclasslib 来查看该类编译后的字节码显示面板</p>
<img src="https://s2.loli.net/2023/12/29/l4wiEW1AFfpv5Nr.png" alt="image-20231229154246747" style="zoom:50%;" />

<h4 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h4><p>上述工具都是根据源代码编译后的字节码文件，来查看字节码文件的信息，而如果只有正在运行的程序，如何查看字节码的信息？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/">Arthas</a> 是一款 线上java应用 性能监控和诊断工具，可以全局实时的查看应用负载，内存清空，垃圾回收，线程状态等信息。</p>
<p>在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p>
</blockquote>
<h5 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h5><p>下载<code>arthas-boot.jar</code>，然后用<code>java -jar</code>的方式启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<h5 id="功能概览"><a href="#功能概览" class="headerlink" title="功能概览"></a>功能概览</h5><p>相关命令教程可以查看地址：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/commands.html">https://arthas.aliyun.com/doc/commands.html</a></p>
<img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20231229164553637.png" alt="image-20231229164553637" style="zoom:50%;" />

<p>本章主要介绍如何查看字节码信息：</p>
<h5 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h5><blockquote>
<p>dump 已加载类的字节码文件(到特定目录 - 可选)</p>
</blockquote>
<p>参数：</p>
<table>
<thead>
<tr>
<th><strong>参数名称</strong></th>
<th><strong>参数说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>class-pattern</td>
<td>类名表达式匹配</td>
</tr>
<tr>
<td>-c</td>
<td>类所属 ClassLoader 的 hashcode</td>
</tr>
<tr>
<td>-classLoaderClass</td>
<td>指定执行表达式的 ClassLoader 的 class name</td>
</tr>
<tr>
<td>-d</td>
<td>设置类文件的目标目录</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -d /xxx/xxx class-pattern</span><br></pre></td></tr></table></figure>

<h5 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h5><blockquote>
<p>dump 反编译指定已加载类的源码</p>
<p>适用于 查看线上应用的源代码</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>参数名称</strong></th>
<th><strong>参数说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>class-pattern</td>
<td>类名表达式匹配</td>
</tr>
<tr>
<td>-c</td>
<td>类所属 ClassLoader 的 hashcode</td>
</tr>
<tr>
<td>-classLoaderClass</td>
<td>指定执行表达式的 ClassLoader 的 class name</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad class-pattern</span><br></pre></td></tr></table></figure>

<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><blockquote>
<p>类的生命周期描述了一个类从加载到虚拟机的内存、到使用、最后到卸载出内存的整个过程。 </p>
<p>掌握类的生命周期可以更好地理解和优化执行的过程，是后续很多知识点的基础。类加载器的作用、运行时常量池、多态、类的加密和解密 与 类的生命周期都有密不可分的关联</p>
</blockquote>
<p>类的生命周期会经历 加载（Loading） - 连接（Linking） - 初始化（Initialization） - 使用（Using）- 卸载（Unloading），其中 连接 包含了三个部分分别是 验证（Verification）、准备（Preparation）和解析（Resolution）。</p>
<img src="https://s2.loli.net/2023/12/29/sVG6veTqf1RXDWO.png" alt="image-20231229215507721" style="zoom: 50%;" />

<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote>
<p>加载阶段是类的生命周期的第一阶段</p>
<p>主要是将类的字节码从磁盘或其他介质加载到内存中，并为之创建一个 <code>java.lang.Class</code> 类的实例。</p>
</blockquote>
<ul>
<li>类加载器通过一个类的全限定名从磁盘、其他介质等中获取类字节码文件（二进制字节流）</li>
<li>jvm 将 字节码加载到内存中，并生成一个表示类信息的数据结构InstanceKlass 存储在 方法区 中<ul>
<li>InstanceKlass 保持了类信息的基本信息、字段、方法等以及实现特定功能的信息（例如：实现多态的虚方法表）</li>
</ul>
</li>
<li>在 jvm 的堆中的创建一个 <code>java.lang.Class</code> 类的实例，作为对方法区类信息的访问入口<ul>
<li><code>java.lang.Class</code> 类是 jvm 运行时自动创建和维护的，代表一个类的元数据信息，是在 java 层面上对类信息的一种抽象表示，包含了描述类的各种信息，可以用于获取类的字段、方法、构造器等信息。</li>
</ul>
</li>
</ul>
<img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20231230160545240.png" alt="image-20231230160545240" style="zoom:33%;" />

<h5 id="java-lang-Class类的实例"><a href="#java-lang-Class类的实例" class="headerlink" title="java.lang.Class类的实例"></a>java.lang.Class类的实例</h5><blockquote>
<p>为什么在堆中保存 <code>java.lang.Class</code> 类的实例？</p>
<ul>
<li>java 语言层面访问：java.lang.Class 类提供了一些 java 语言层面操作类信息的方法<ul>
<li>例如获取类的名称，获取父类，获取实现的接口等，这些方法是通过 java.lang.Class 类提供的，而不是通过 InstanceKlass 类</li>
</ul>
</li>
<li>反射：java 的反射机制就是基于 <code>java.lang.Class</code> 类实现的。通过反射可以在运行时获取并操作类的信息，创建类的实例、调用方法等。</li>
<li>动态代理： 动态代理也是基于 <code>java.lang.Class</code> 实现的。通过 <code>Proxy.newProxyInstance</code> 方法，可以动态地生成代理类，并在运行时处理代理类的方法调用。</li>
</ul>
<p>总结：虽然 InstanceKlass 在虚拟机层面保存了类的底层信息（c语言），用于虚拟机层面管理类的信息，但 <code>java.lang.Class</code> 对象提供了更高层次的抽象，使得开发者可以更方便地在 java 代码中访问和操作类的信息，以便实例化对象和访问类的成员变量等。</p>
</blockquote>
<p>如何在代码层面获取 Class 对象即 java.lang.Class 类的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 使用.class字面常量</span><br><span class="line">Class&lt;?&gt; clazz = xxClass.class;</span><br><span class="line"></span><br><span class="line"># 使用 Class.forName 方法</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.xxClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用对象的 getClass 方法</span><br><span class="line"><span class="type">XxClass</span> <span class="variable">classObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxClass</span>();</span><br><span class="line">Class&lt;?&gt; clazz = classObj.getClass();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.Class</code> 类的实例 和 new 构建的对象实例不同：</p>
<p>java.lang.Class 是 jvm 运行时自动创建和维护的，代表一个类的元数据信息，是在  java 层面上对类信息的一种抽象表示，而 new 构建的对象实例是在堆内存中为该类创建一个对象的实例，代表着类的一个具体对象，使用 <code>new</code> 关键字创建对象，都会在堆内存中分配一块新的内存空间，实例相互独立；</p>
<p><code>java.lang.Class</code> 实例通常不会被垃圾回收，一旦创建，它就会一直存在于应用的生命周期中，直到应用结束。而 new 的对象实例在堆内存中分配，它的生命周期和引用情况有关，当对象不再被引用了就会变成一个不可达对象，在垃圾回收机制中成为一个潜在可回收的对象。</p>
<h5 id="查看jvm内存结构"><a href="#查看jvm内存结构" class="headerlink" title="查看jvm内存结构"></a>查看jvm内存结构</h5><blockquote>
<p>jdk 自带的hsdb工具 可以查看 jvm内存信息，工具位于 jdk 安装目录下的lib文件夹中的 sa-jdi.jar 中</p>
</blockquote>
<p>启动命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp sa-jdi.jar sun.jvm.hotspot.HSDB # -cp 指定HSDB为启动类</span><br></pre></td></tr></table></figure>

<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><blockquote>
<p>连接（Linking）阶段包含了三个部分分别是 验证（Verification）、准备（Preparation）和解析（Resolution）。</p>
</blockquote>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><blockquote>
<p>验证（Verification）：检测类的字节码文件是否合法以及符合《java虚拟机的规范》来确保字节码的安全性和正确性。目的是确保jvm能够安全地执行这些类的字节码，防止恶意代码和非法字节码的执行。</p>
</blockquote>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><blockquote>
<p>准备（Preparation）：jvm 为类的静态变量分配内存并为设置初始值。这里的初始值为一个初始默认值（初始赋值是在初始化时进行赋值），通常是数据类型的零值，如零、null、false等。</p>
</blockquote>
<p>假设一个类的静态变量定义为 public static int value = 1; 在准备阶段后，初始值为0，这时候尚未执行任何java方法，把value赋值为1的会在初始化才会执行（赋值的put static指令在程序编译后存放在类构造器<code>&lt;clinit&gt;()</code>方法之中）</p>
<p>注意 <strong>final</strong> 修饰的<strong>基本数据类型的静态变量</strong>，在准备阶段会分配内存并进行赋值。final 表示一个常量时候，一旦赋值就不能被修改。在准备阶段就被确定，并且在后续的初始化阶段不会再改变。</p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><blockquote>
<p>解析（Resolution）：将类、字段、方法等符号引用解析为直接引用的过程。直接引用不再使用编号，而是使用内存地址引用，以便jvm更高效的执行。</p>
</blockquote>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote>
<p>jvm 执行类的初始化代码，为静态变量正确的赋值并执行静态代码块。</p>
<p>初始化阶段会执行字节码文件中<code>&lt;clinit&gt;()</code>部分的字节码指令。</p>
<p>类初始化是一个线程安全的操作，多个线程同时尝试初始化同一个类时，只有一个线程会执行初始化过程，其他线程会等待初始化完成。</p>
<p>初始化阶段的执行是有序的，按照类加载的顺序依次执行。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        value = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20231231014601030.png" alt="image-20231231014601030" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_2	# 将整数常量<span class="number">2</span>推送到操作数栈</span><br><span class="line"><span class="number">1</span> putstatic #<span class="number">7</span> &lt;SimpleClass.value : I&gt; # 将 栈顶整数（即常量<span class="number">2</span>）存储到SimpleClass类的静态变量value中</span><br><span class="line"><span class="number">4</span> iconst_1 # 将整数常量<span class="number">2</span>推送到操作数栈</span><br><span class="line"><span class="number">5</span> putstatic #<span class="number">7</span> &lt;SimpleClass.value : I&gt; # 将 栈顶整数（即常量<span class="number">1</span>）存储到SimpleClass类的静态变量value中</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span> # 返回，方法执行完毕</span><br></pre></td></tr></table></figure>

<p>从上面示例中，我们可以看出 初始化阶段时按照类加载的顺序依次执行 即 clinit 方法中的执行顺序与源代码编写顺序一致。</p>
<h5 id="初始化的触发"><a href="#初始化的触发" class="headerlink" title="初始化的触发"></a>初始化的触发</h5><ul>
<li>创建类的实例</li>
</ul>
<p>通过new关键字创建类的实例时，如果当前类没有被初始化，则会触发类的初始化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XxClass</span> <span class="variable">xxClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxClass</span>(); </span><br></pre></td></tr></table></figure>

<ul>
<li>访问类的静态变量和静态方法（不被final修饰的）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">staticVariable</span> <span class="operator">=</span> MyClass.staticVariable;</span><br><span class="line">MyClass.staticMethod();</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 class.forName 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.XxClass&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>main</code> 方法的当前类</li>
<li>初始化子类会导致会导致父类的初始化（优先初始化父类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass initialization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass initialization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SubClass</span> <span class="variable">subClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(); <span class="comment">// 先触发 SuperClass 类的初始化，再触发 SubClass 类的初始化</span></span><br></pre></td></tr></table></figure>

<p>添加参数 -XX:+TraceClassLoading 可以打印出加载并初始化的类</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote>
<p>执行程序代码，创建类的实例</p>
</blockquote>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><blockquote>
<p>释放不再被使用的类的内存</p>
</blockquote>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote>
<p>类加载器 （classloader）负责将字节码文件（.class文件）加载到内存中。jvm 提供给应用程序实现获取字节码的技术。</p>
</blockquote>
<p>在整个加载阶段在通过类加载器将字节码文件加载到内存中后，类加载器会调用本地接口（JNI - java native interface 允许使用java语言调用jvm本地方法 c++编写的方法）来在方法区生成类信息的数据结构InstanceKlass和堆上生成java.lang.Class类的实例。所以类加载器在加载阶段只负责获取字节码并加载到内存中。</p>
<h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><blockquote>
<p>从java虚拟机的角度出发，类加载器分为两类：jvm底层实现的类加载器和java代码自定义类加载器。</p>
</blockquote>
<ul>
<li><p>jvm 底层实现的类加载器</p>
<p>源代码位于 jvm 虚拟机的源码中，实现语言和虚拟机底层实现语言一致</p>
<p>作用：保存程序运行中的类被正确的加载，保证其可靠性。</p>
</li>
<li><p>java 代码自定义类加载器</p>
<p>jdk 中默认提供了多种处理不同介质来源的类加载器，开发者也可以自定义类加载器 以实现特定的加载需求。</p>
<p>自定义加载器需要继承 <code>ClassLoader</code>类并实现 <code>findClass</code> 方法。</p>
</li>
</ul>
<p>在jdk8及之前的版本中，默认的类加载器包括以下几种：</p>
<ul>
<li><p>jvm 底层实现的类加载器</p>
<ul>
<li>Bootstrap Class Loader - 启动类加载器：加载java的核心类库</li>
</ul>
</li>
<li><p>java 代码自定义类加载器</p>
<ul>
<li>Extension Class Loader - 扩展类加载器：加载java的扩展类库</li>
<li>Application Class Loader - 应用程序类加载器：加载应用程序中的类</li>
</ul>
</li>
</ul>
<p>如何查看当前程序远行时的类加载器的详细信息，可以通过 arthas 中的 classloader命令来查看。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/classloader.html">classloader命令</a> 查看 classloader 的继承树，urls，类加载信息。</p>
</blockquote>
<img src="https://s2.loli.net/2024/01/01/d8Qwn2hOrmxHegc.png" alt="image-20240101144226364" style="zoom:50%;" />

<h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h5><blockquote>
<p>启动类加载器（Bootstrap ClassLoader）由虚拟机提供，由虚拟机底层实现。</p>
<p>默认加载jvm安装目录/jre/lib下的类文件。</p>
<p>由于启动类加载器由jvm底层实现，我们无法通过java源代码xxClass.getClassLoader()和arthas工具直接获取到，所以当为null时，即该类由启动类加载器加载。</p>
</blockquote>
<p>如何让启动加载器加载一些开发者扩展的类，用于jdk基础类的扩展：</p>
<ul>
<li>将开发者扩展的jar包放入到/jre/lib目录下扩展（不推荐 - 文件名需要满足jvm规范，不满足则不会被加载）</li>
<li>使用启动参数 -Xbootclasspath:/xx/xx.jar 来扩展。</li>
</ul>
<h5 id="扩展加载器和应用加载器"><a href="#扩展加载器和应用加载器" class="headerlink" title="扩展加载器和应用加载器"></a>扩展加载器和应用加载器</h5><p>扩展加载器和应用加载器由jdk提供，使用java语言实现，它们的源码是位于 sun.misc.launcher 中的一个静态内部类，继承自 URLClassloader 以具备通过目录或者指定jar包将字节码文件加载到内存中。</p>
<p>下图继承关系如下：</p>
<img src="https://s2.loli.net/2024/01/01/fbKuVcjQeIELmSN.png" alt="image-20240101151806770" style="zoom:50%;" />

<p>ClassLoader：抽象类。定义了类加载器的具体行为模式，将字节码文件加载到内存中后通过JNI调用底层的jvm方法来来在方法区生成类信息的数据结构InstanceKlass和堆上生成java.lang.Class类的实例。</p>
<p>SecureClassLoader：使用证书机制提升类加载器的安全性。</p>
<p>URLClassLoader：利用URL获取目录下或者执行的jar包进行加载，获取字节码信息。</p>
<h6 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h6><p>扩展类加载默认加载 jdk 安装目录下的 /jre/lib/ext 下的类文件。</p>
<p>和上面一样，可以使用启动次数 -Djava.ext.dirs = /xx/xx/ 修改扩展加载器加载的目录位置进行扩展，注意该方法会覆盖掉原始目录，因此可以使用追加的方式进行添加目录(;使用分号分割) -Djava.ext.dirs = /jre/lib/ext/;/xx/xxx/</p>
<h6 id="应用类加载器"><a href="#应用类加载器" class="headerlink" title="应用类加载器"></a>应用类加载器</h6><p>应用类加载器加载 classpath 下的类文件即加载项目中开发者编写的类和接口文件和第三方jar包类和接口的文件。</p>
<p>通过 <code>classloader -c hash值</code> 可以查看类加载器的加载目录和文件</p>
<p><img src="https://s2.loli.net/2024/01/01/ajcfvqngX9AShHR.png" alt="image-20240101154437880"></p>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote>
<p>双亲委派机制（Delegation Model）是Java中类加载器（ClassLoader）的一种工作机制，用于加载Java类和资源。</p>
<p>它的作用是将类加载的责任委托给父类加载器，从而形成一种层次结构，保证类加载的顺序和一致性。</p>
<p>简而言之，jvm 中有多个类加载器，双亲委派机制解决了一个类到底由哪一个加载器加载的问题。通过双亲委派机制可以保持类加载的有序性、避免类的冲突、提高安全性并且能够实现类的共享。</p>
</blockquote>
<p>双亲委派模式对类加载器定义了层级，如图所示。</p>
<p><img src="https://s2.loli.net/2024/01/02/GMAbg4ldeJ8Ph3R.png" alt="image-20240102113437845"></p>
<p>双亲委派机制：当一个类加载器处理类加载任务时，会自低向上的查找类是否加载过，再由顶向下的进行尝试加载。</p>
<p>当一个类需要加载的时候，首先自低向上委派父类加载器进行检查是否加载过，如果检查加载过，会直接返回class对象，加载过程结束，这样能避免一个类的重复加载。如果未加载过，则由顶向下的进行尝试加载，如果所有父类无法加载该类，则由当前类加载器尝试加载。</p>
<p>本质上双亲委派机制是起到了一个加载优先级的作用。</p>
<blockquote>
<p>可以通过 <code>classloader -t</code> 查看类加载器的层级信息。</p>
<p><img src="https://s2.loli.net/2024/01/02/pAaOFX5DfqBUdC8.png" alt="image-20240102091656380"></p>
</blockquote>
<h5 id="双亲委派机制的作用"><a href="#双亲委派机制的作用" class="headerlink" title="双亲委派机制的作用"></a>双亲委派机制的作用</h5><ul>
<li><p>保证类加载的安全性</p>
<ul>
<li>防止恶意类的加载。java核心类库都只能由被信任的类加载器加载，确保了系统的安全性。</li>
</ul>
</li>
<li><p>避免同一个类的重复加载：</p>
<ul>
<li>双亲委派机制通过一层一层的委派，确保了类加载的顺序，防止同一个类被多个类加载器加载，从而避免了类的冲突和混乱。</li>
<li>当一个类加载器需要加载类时，它首先会委派给其父类加载器去尝试加载。如果父类加载器已经加载了该类，就不会再次加载，避免了重复加载和的性能开销。提高了性能，也保证了类不会冲突和混乱。 </li>
</ul>
</li>
<li><p>确保类的一致性</p>
<ul>
<li>同一个类在在整个类加载器层次结构中只有一份，不会出现不同加载器加载同名类导致类型不一致的问题。</li>
</ul>
</li>
</ul>
<h4 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制"></a>如何打破双亲委派机制</h4><h5 id="为什么要打破双亲委派机制？"><a href="#为什么要打破双亲委派机制？" class="headerlink" title="为什么要打破双亲委派机制？"></a>为什么要打破双亲委派机制？</h5><p>先举例一个场景，在tomcat中运行多个Web应用，如果两个应用中存在相同限定名的类，通常情况下双亲委派机制会导致只有第一个加载的类被使用。</p>
<p>为了解决这个问题，tomcat使用不同的类加载器实现应用之间类的隔离。每个web应用会有一个自己独立的类加载器加载对应的类。    </p>
<h5 id="双亲委派机制的实现原理"><a href="#双亲委派机制的实现原理" class="headerlink" title="双亲委派机制的实现原理"></a>双亲委派机制的实现原理</h5><p>要想打破双亲委派机制，首先要了解双亲委派机制的实现。</p>
<p>查看类加载类的抽象类 Classloader，该类中有4个核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 类加载的入口方法，默认实现会委托给双亲类加载器来完成加载</span><br><span class="line"># 在加载类的过程中，它会调用findClass方法来查找类，并最终调用defineClass方法来定义类</span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name);</span><br><span class="line"></span><br><span class="line"># 用于在类加载器的查找过程中实际定位和加载类的字节码</span><br><span class="line"># 默认的ClassLoader中findClass方法是抽象的，具体实现由子类加载器实现</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name);</span><br><span class="line"></span><br><span class="line"># 校验类名，调用了虚拟机底层方法将类的字节码转换为一个Class对象并加载到虚拟机内存中，</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len);</span><br><span class="line"></span><br><span class="line"># 用于连接并准备类，确保类的正确性</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure>

<p>查看类加载的入口的方法 loadClass(String)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">   <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 加锁 保证只有一个线程可以加载，避免重复加载和线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">      <span class="comment">// 判断当前类（权限定名）是否被当前类加载器加载过，加载过则返回当前类，否则为空 </span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 如果parent即父类加载器不为空，则委派到父加载器加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果parent为空，则说明当前类为扩展加载器，其父加载器为启动器加载器，委派到启动器加载器加载	</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">              <span class="comment">// 父类加载器都没有加载到，则调用当前类加载器进行加载，在classloader抽象类中，并没有实现findClass的具体逻辑，而是由子类继承类并重写实现方法</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 判断是否执行连接阶段</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="打破双亲委派机制的方式"><a href="#打破双亲委派机制的方式" class="headerlink" title="打破双亲委派机制的方式"></a>打破双亲委派机制的方式</h5><ul>
<li>自定义类加载器</li>
</ul>
<p>查看上面代码查看双亲委派机制的具体实现，因此需要打破双亲委派机制，则需要继承 ClassLoader 类并对于 loadClass 方法进行重新实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 具体实现来获取字节码 byte[] bytes</span></span><br><span class="line">    <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, data.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义加载器如果没有手动设置parent，默认会指向应用程序类加载器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ClassLoader类中提供了构造方法设置parent的内容</span></span><br><span class="line">		<span class="keyword">private</span> <span class="title function_">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">if</span> (ParallelLoaders.isRegistered(<span class="built_in">this</span>.getClass())) &#123;</span><br><span class="line">            parallelLockMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">            package2certs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">            assertionLock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no finer-grained lock; lock on the classloader instance</span></span><br><span class="line">            parallelLockMap = <span class="literal">null</span>;</span><br><span class="line">            package2certs = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">            assertionLock = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数构造方法，父类加载器由getSystemClassLoader()方法设置，该方法返回的是 appClassLoader</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在自定义加载器加载相同限定名的类，并不会产生任何冲突，在jvm中，只有相同类加载器和相同类限定名才可以被认定为是同一个类</p>
<p>使用arthas的 <code>sc -d 类名</code> 查看类的具体的情况</p>
</blockquote>
<p>如果不想打破双亲委派机制，从不同的渠道获取类字节码，则可以自定义类加载继承classloader抽象类并重写findclass方法，实现获取类字节码并调用defineClass来加载内存。</p>
<ul>
<li><p>线程上下文类加载器</p>
<p>jdbc和jndi等使用了线程上下文加载器加载类，下面我们以jdbc为例，说明线程上下文加载器</p>
<p>jdbc 中使用 driverManager 来管理项目中引入的不同数据库的驱动，以实现对接不同数据库的目的</p>
<p>在 driverManager 加载驱动jar包中类的过程中，我们发现它打破了双亲委派机制</p>
<p>driverManager类位于 rt.jar 包中，由启动类加载器bootstrapClassLoader进行加载，而 driverManager 需要加载引入不同的数据库驱动类，这些类由应用类加载器加载。driverManager 由 启动类加载加载，而 driverManager 管理的驱动类需要委托给应用程序类加载器进行加载，这违反了双亲委派机制。</p>
<p>首先，我们需要了解 driverManager 如何知道jar中需要加载的驱动类的位置的，这里使用就是SPI机制（Seriver Provider Interface）  - JDK 内置的一种松散耦合的服务提供发现机制。</p>
<p>在数据库驱动的加载中，<code>DriverManager</code>通过 SPI 机制来查找和加载具体的数据库驱动。</p>
<p>SPI的工作原理：</p>
<ul>
<li><p>驱动加载配置文件：</p>
<p>在驱动jar中的classpath路径下的META-INF/services/文件夹z中，有以接口的全限定名来命名文件名，文件中有具体接口实现类的全限定名。</p>
</li>
<li><p>ServiceLoader 加载驱动</p>
<p><code>ServiceLoader</code> 是 java 提供的用于加载服务提供者的工具类，它会在类路径下查找 <code>META-INF/services/</code> 目录下的配置文件，并加载其中指定接口的服务提供者的类名，通过类加载器加载对应的类并创建对象注册到 DriverManager 中。</p>
<p><img src="https://s2.loli.net/2024/01/02/HP24DTUp3MlEhiV.png" alt="image-20240102112120324"></p>
</li>
</ul>
<p>在 SPI 中，驱动的jar包的类是通过应用加载器加载的，那么 driverManager 是通过启动器加载器的，那么启动器加载器是如何获取应用程序类加载器的？</p>
<blockquote>
<p>SPI 中使用了 线程上下文 保存类加载器进行类的加载，该类加载器一般是应用程序类加载器。</p>
<p><img src="https://s2.loli.net/2024/01/02/kxBXuzjMIqaKWsS.png" alt="image-20240102112802722"></p>
</blockquote>
</li>
<li><p>osgi框架类加载器</p>
</li>
</ul>
<blockquote>
<p>OSGi框架的类加载机制是基于模块化的概念的。在OSGi中，应用程序被组织成模块（bundles），每个模块都有自己的类加载器。它存在同级之间的类加载器的委托加载。 </p>
</blockquote>
<h4 id="热部署的类加载"><a href="#热部署的类加载" class="headerlink" title="热部署的类加载"></a>热部署的类加载</h4><blockquote>
<p>热部署是指服务在不停机的情况下，动态地更新字节码文件到内存中。</p>
</blockquote>
<p>使用arthas实现热部署</p>
<ul>
<li><p>将反编译的文件写入到执行文件中并修改文件源代码</p>
<blockquote>
<p>jad –source-only 全限定类名 &gt; /xx/xxx.java</p>
</blockquote>
</li>
<li><p>查看当前类的类加载器的hashcode</p>
<blockquote>
<p>sc -d xx.java</p>
</blockquote>
</li>
<li><p>编译修改过的源代码</p>
<blockquote>
<p>mc -c 类加载器的hashcode /xx/xxx.java -d /jar包所在目录</p>
</blockquote>
</li>
<li><p>使用 retrantsform 命令加载新的字节码</p>
<blockquote>
<p>retransform /类字节文件所在目录/xxx.class</p>
</blockquote>
</li>
</ul>
<p>注意：</p>
<blockquote>
<p>注意：retransform 命令是将字节码信息更新到内存中，程序重启之后，字节码文件会恢复</p>
<p>retransform 命令无法在已经在的类上添加字段和方法。因为 arthas 允许现有方法的修改，比如添加、修改或删除方法体中的代码，但不支持结构性的更改，比如添加字段或者方法</p>
<p>retransform 命令也不能作用于正在执行的方法中，正在执行的方法字节码是被锁定的，此时不能将其进行重新转换。</p>
</blockquote>
<h4 id="jdk-类加载器的变化"><a href="#jdk-类加载器的变化" class="headerlink" title="jdk 类加载器的变化"></a>jdk 类加载器的变化</h4><blockquote>
<p>jdk9前后类加载器发生了变化。</p>
<p>在jdk9之前，扩展类加载器和应用程序加载器的源代码位于 rt.jar 包中 sun.misc 包中，这两个都继承自 java.net.URLClassLoader (通过 指定目录 找到jar包以及jar包中的字节码文件)</p>
<p>在jdk9之后，引入module的概念，加载器类不在存放在jar包中，java 类 会被模块化为一个一个jmod文件，字节码不在从jar包中获取，而是从jmod文件中获取。</p>
</blockquote>
<p>在jdk9及之后，启动类加载器不在由jvm底层的c/c++编写，使用java编写，位于jdk.internal.loader.ClassLoaders 类中。同时启动类加载器会继承自 BuiltinClassLoader 实现从模块文件中找到要加载的字节码资源文件。值的注意的是，尽管如此，我们依旧无法在java代码中获取到启动类加载器，获取到结果依旧是 null, 这是为类保证统一。</p>
<p>新增的类加载器 平台类加载器（Platform Class Loader）遵循模块化方式加载字节码文件，以从模块中加载字节码文件到内存中。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>类加载器的作用：负责在类加载的过程中，获取字节码并加载到内存中，并通过JNT本地方法调用调用底层方法将来在方法区生成类信息的数据结构InstanceKlass和堆上生成java.lang.Class类的实例</p>
<p>常见的类加载器：启动类加载器 - 加载java核心类</p>
<p>​         扩展类加载器 - 加载java扩展类</p>
<p>​         应用程序加载器 - 加载应用classpath中的类</p>
<pre><code>     自定义类加载器 - 重写 findClass 方法
</code></pre>
<p>双亲委派机制：类加载器的层次结构</p>
<p>​        自低向上的判断是否加载过，再自顶向下的进行加载，避免核心类被应用程序重写导致安全问题，保证加载类的顺序性和一致性，避免重复加载，提高了性能          </p>
<p>如何打破双亲委派机制：</p>
<p>  继承classloader类重写loadClass方法，不再实现双亲委派机制。</p>
<p>  使用SPI机制加载类字节码使用了上下文类加载器。</p>
<p>  OSGi框架实现了一整套类加载机制，允许同级类加载器的相互调用。</p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><blockquote>
<p>jvm 在执行java程序的过程中管理的内存区域被称为 运行时数据区，在执行过程中，运行时数据区划分为若干的不同数据区域。</p>
</blockquote>
<p>根据《Java虚拟机规范》的规定，运行时数据区将会包括以下 运行时数据区域：</p>
<p><img src="https://s2.loli.net/2024/01/02/jaGvAJ3kgrDBzPo.png" alt="image-20240102141247168"></p>
<p>线程私有：程序计数器 本地方法栈 虚拟机栈</p>
<p>线程共享：方法区 堆</p>
<h3 id="运行时内存结构"><a href="#运行时内存结构" class="headerlink" title="运行时内存结构"></a>运行时内存结构</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><blockquote>
<p>程序计数器（Program Counter Register）是每个线程会通过程序计数器记录当前需要执行的字节码指令的内存地址，可以看作当前线程所执行的字节码的”行号指示器”，属于线程私有的，是一个较小的固定长度的内存空间。</p>
</blockquote>
<p>字节码指令在jvm类的加载阶段被加载到内存中，会源文件中的指令偏移量转换为内存地址，每一条字节码指令都会有一个对应的内存地址</p>
<img src="https://s2.loli.net/2024/01/02/JMhu8qty2SkaDCc.png" alt="image-20240102160613196" style="zoom:50%;" />

<p>在代码的执行过程中，程序计数器记录 下一个字节码指令的内存地址，当当前指令执行完成后，虚拟机的执行引擎会根据程序计数器记录的内存地址找到对应的指令来执行下一行指令</p>
<h5 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h5><ul>
<li><p>程序计数器是程序控制流的指示器，可以实现分支、循环、跳转、异常等逻辑。</p>
</li>
<li><p>在多线程运行的情况下，线程轮流切换来分配处理器执行时间，程序计数器会记录当前线程接下来需要执行的指令，以便线程切换后恢复到正确的执行位置从而继续执行。</p>
</li>
</ul>
<p>根据《Java虚拟机规范》，程序计数器是没有规定任何OutOfMemoryError情况的区域，同时开发者无需对于程序计数器做任何的处理。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><blockquote>
<p>java 虚拟机栈（Java Virtual Machine Stack）是 采用栈的数据结构来保存每个方法调用的基本数据。栈是一种先进后出的数据结构，每一个方法的调用信息将使用一个栈帧（Stack Frame）来保存即每个栈帧对应一个个调用方法调用。</p>
<p>虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，jvm 都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程即每个方法执行伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong>，线程上的每一个方法都对应着一个栈帧。</p>
<p>虚拟机栈的生命周期和线程相同，随着线程的创建而创建，随着线程的销毁而回收。</p>
</blockquote>
<p> 通过IDEA的debug工具可以查看栈帧的内存</p>
<img src="https://s2.loli.net/2024/01/02/UloFNvkE8eJA6i3.png" alt="image-20240102170325870" style="zoom:50%;" />

<h5 id="栈帧的组成"><a href="#栈帧的组成" class="headerlink" title="栈帧的组成"></a>栈帧的组成</h5><blockquote>
<p>虚拟机栈的栈帧中，存储着：局部变量表（Local Variables）、操作数栈（Operend Stack）、动态链接（Dynamic Linking）、方法返回地址（Return Address)、附加信息等。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/03/VOcUgfdZQBve9qH.jpg" alt="jvm-stack-frame"></p>
<p><img src="https://s2.loli.net/2024/01/10/XpUFP8orcvGwJaQ.png" alt="image-20240110164003715"></p>
<h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><blockquote>
<p>用于存储方法参数和方法内部定义的局部变量。局部变量表的容量是在编译期确定的，存储的数据类型包括基本数据类型（如int、float）和对象引用</p>
</blockquote>
<p>栈中的局部变量表本质上是一个 数组，数组中每一个位置被称之为一个槽（slot），其中 long 和 double 类型占用两个槽，其他类型和引用类型专用一个槽</p>
<p>在实例方法中，局部变量序号为0的位置存放的是this，指的是当前调用方法的对象（即对象实例的引用），运行时会在内存中存放对象的地址。当静态方法中则无需在序号为0的位置存放对象的引用。方法参数也需要保存在局部变量表中，其顺序和方法参数定义顺序一致。</p>
<p>因此局部变量表中包含了方法参数、局部变量、对象实例的引用和返回值等。</p>
<p>为了节省局部变量表的空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以被复用。</p>
<h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h6><blockquote>
<p>用于执行计算操作的栈。在方法执行过程中，操作数栈用于暂存计算过程中的中间结果。</p>
<p>在编译器可以确定操作数栈的最大深度，从而执行时正确的分配内存大小。</p>
</blockquote>
<h6 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h6><blockquote>
<p>动态链接指向方法区的运行时常量池的方法引用，用于方法调用过程中的动态链接。</p>
<p>在类的生命周期的连接-解析阶段，会将符号引用转换为直接引用。当前类的字节码指令引用了其他类的属性和方法时，符号引用在类的连接阶段不会直接变成直接引用，因此在运行时需要将符号引用和对应运行时常量池中的内存地址映射关系。</p>
<p>动态链接中保存了符号引用到运行时常量池的内存地址的映射关系。当字节码指令执行过程中，就可以根据当前的符号引用从动态链接中快速找到运行时常量池对应的数据。</p>
</blockquote>
<img src="https://s2.loli.net/2024/01/03/lhLe9oR1r62PaBY.jpg" alt="jvm-dynamic-linking" style="zoom: 33%;" />

<h6 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h6><blockquote>
<p>当一个方法执行结束或者异常后，会从栈顶弹出，此时程序计数器需要知道下一个方法指令的地址，而方法出口保存了指向下一个方法指令的地址。</p>
</blockquote>
<h6 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h6><blockquote>
<p>异常表存放了代码中的异常的处理信息，包含了try代码和catch代码指令执行后跳转字节码的指令位置。</p>
</blockquote>
<h5 id="虚拟机的栈内存"><a href="#虚拟机的栈内存" class="headerlink" title="虚拟机的栈内存"></a>虚拟机的栈内存</h5><blockquote>
<p>在java虚拟机栈的大小一般是固定的，即在启动时通过命令行参数或者其他配置方法指定并在运行时不会动态的调整；jvm 如果栈帧过多，因此会出现内存溢出。</p>
<p>在《Java虚拟机规范》中，如果线程请求分配的栈容量超过虚拟机所设置允许的最大容量，将抛出栈溢出StackOverflowError异常。</p>
</blockquote>
<p>在不指定栈的大小的情况下，jvm 会创建一个默认大小的栈，栈的大小取决于操作系统和计算机的体系结构。</p>
<p>可以通过虚拟机参数<code>-Xss</code>或者 <code>-XX:ThreadStackSize</code> 来设置线程的最大栈空间。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xss &lt;size&gt; （默认字节，此时必须1024的倍数，其他单位：k和kb，m和MB, g和GB）</span><br><span class="line">-XX:ThreadStackSize=&lt;size&gt;</span><br></pre></td></tr></table></figure>

<p>注意：hotspot jvm 对栈大小的最大值和最小值有要求</p>
<p>​     栈的可达深度取决于栈的大小和每个栈帧的大小</p>
<p>调优：在一般情况下，栈的大小不会超过256k，通过减小栈的大小，可以在一定程度上减小每个线程消耗的内存，手动指定<code>-Xss256k</code>来节省内存</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><blockquote>
<p>java 虚拟机栈存储的是java方法调用的栈帧，而本地方法栈存储的是native本地方法的栈帧。</p>
<p>在hotspot虚拟机上，java虚拟机栈和本地方法栈实现上使用了同一个栈空间。</p>
</blockquote>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><blockquote>
<p>java堆是jvm管理的内存最大的一部分，被所有线程共享，该区域用于存放对象实例。</p>
<p>在java虚拟机栈的栈帧上的局部变量表上，可以存放了堆上对象的引用，方法区的静态变量可以存放堆对象的引用（因此通过静态变量可以实现对象在线程之前的共享）</p>
</blockquote>
<p>java 虚拟机规范规定，堆大小存在上限，如果在java堆中没有内存完成实例分配，并且堆也无法再扩展时，java虚拟机将会抛出OutOfMemoryError异常。</p>
<p>堆空间有三个值得关注的值：used、total、max</p>
<p>used（已使用）：表示当前已经被使用的堆空间大小</p>
<p>total（总计）：已经分配的可用堆内存</p>
<p>max（最大）：可以分配的最大堆内存</p>
<p>当堆内存达到max时，应用程序尝试分配更多内存超过这个值时，会触发OutOfMemoryError错误。</p>
<p>可以使用arthas的 dashbroad 和 memory 命令查看jvm的堆内存占用情况：</p>
<p><img src="https://s2.loli.net/2024/01/03/FLCvOtRMlnKeVIY.png" alt="image-20240103110849137"></p>
<h5 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h5><blockquote>
<p>在不设置任何的虚拟机参数的情况下，max（即已经分配的可用堆内存）默认是系统内存的1/4，total（即可以分配的最大堆内存）默认是系统内存的1/64。在实际应用中一般都需要设置 total和max的值</p>
</blockquote>
<p>可以使用虚拟机参数 <code>-Xmx</code> 和 <code>-Xms</code> 来分别设置 total 和 max:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms &lt;size&gt; -Xmx &lt;size&gt;</span><br></pre></td></tr></table></figure>

<p>限制：Xmx必须大于2MB，Xms必须大于1MB</p>
<p>调优：建议将 <code>-Xmx</code> 和 <code>-Xms</code> 设置为相同的值，这样程序启动时，堆空间一次性分配，避免了在程序运行时，内存不足动态申请和分配堆空间的开销，以及内存过剩时堆内存收缩的情况。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><blockquote>
<p>方法区（method area）被所有线程共享，该区域用于存储被虚拟机加载的类型信息，常量、静态变量、即时编译器优化后的代码等数据的内存区域。</p>
</blockquote>
<h5 id="方法区设计"><a href="#方法区设计" class="headerlink" title="方法区设计"></a>方法区设计</h5><p>方法区是 jvm 规范中定义的一个概念，不同 jvm 实现不同，hotspot在不同的版本的设计也不同：</p>
<ul>
<li><p>jdk8之前的版本，方法区存放在堆区域的永久代空间（permanent generation），堆大小由虚拟机参数 <code>-XX:MaxPermSize=&lt;size&gt;</code> 控制</p>
</li>
<li><p>jdk8及之后的版本，方法区存放在元空间（namespcace），元空间位于操作系统维护的直接内存中，默认情况下，不超过操作系统内存上限，即可一直分配。但是可以使用参数 <code>-XX:MaxMetaspaceSize=&lt;size&gt;</code>设置元空间的最大大小</p>
<p><img src="https://s2.loli.net/2024/01/03/4unbKgAlTNOJS6h.png" alt="image-20240103131055200"></p>
</li>
</ul>
<h5 id="方法区组成"><a href="#方法区组成" class="headerlink" title="方法区组成"></a>方法区组成</h5><h6 id="类的基础信息"><a href="#类的基础信息" class="headerlink" title="类的基础信息"></a>类的基础信息</h6><p>方法区存储了每一个被加载的类的基础信息（即元信息），一般称为<code>InstanceKlass</code>对象（其中包含了类基本信息，常量池引用、字段引用、方法引用、虚方法表等）。</p>
<h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>此外，方法区存放了运行时常量池，运行时常量池存放的是字节码中的常量池的内容。在加载阶段，字节码中的常量池被加载到方法区，此时为常量池中的值为符号引用，所以被称之为静态常量池。在连接阶段后，符号引用转换为直接引用，可以通过内存地址快速定位常量池中的内容，此时常量池为运行时常量池。</p>
<h6 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h6><p>方法区还有一个区域是字符串常量池（StringTable），字符串常量池用于存储在代码中定义的常量字符串的内容。</p>
<img src="https://s2.loli.net/2024/01/03/Jjo1ILtxEN5QhBs.png" alt="image-20240103134240458" style="zoom:33%;" />

<p>jdk7前方法区采用永久代存放在堆中，运行时常量池逻辑上包含了字符串常量；jdk7将字符串常量池从永久代中移除，放到了堆上；jdk8及之后版本，hotspot 移除了永久代使用了元空间取而代之，字符串常量却仍然存在于堆中。</p>
<p><img src="https://s2.loli.net/2024/01/03/oAj57qilVa8ymv1.png" alt="image-20240103154047381"></p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c == d); # 输出 <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">7</span> &lt;<span class="number">1</span>&gt; # 将字符串常量池中索引为<span class="number">7</span>的地址引用推送至栈顶</span><br><span class="line"> <span class="number">2</span> astore_1 # 栈顶地址引用保存到局部变量表的第一个位置</span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">9</span> &lt;<span class="number">2</span>&gt;</span><br><span class="line"> <span class="number">5</span> astore_2</span><br><span class="line"> <span class="number">6</span> ldc #<span class="number">11</span> &lt;<span class="number">12</span>&gt;</span><br><span class="line"> <span class="number">8</span> astore_3</span><br><span class="line"> <span class="number">9</span> aload_1</span><br><span class="line"><span class="number">10</span> aload_2</span><br><span class="line"><span class="number">11</span> invokedynamic #<span class="number">13</span> &lt;makeConcatWithConstants, BootstrapMethods #<span class="number">0</span>&gt; # 动态调用字符串拼接，生成一个新的字符串存放在堆内存中</span><br><span class="line"><span class="number">16</span> astore <span class="number">4</span> # 将新的字符串的堆内存地址引用保存到局部变量表的第四个位置</span><br><span class="line"><span class="number">18</span> getstatic #<span class="number">17</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class="line"><span class="number">21</span> aload_3</span><br><span class="line"><span class="number">22</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">24</span> if_acmpne <span class="number">31</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">27</span> iconst_1</span><br><span class="line"><span class="number">28</span> goto <span class="number">32</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">31</span> iconst_0</span><br><span class="line"><span class="number">32</span> invokevirtual #<span class="number">23</span> &lt;java/io/PrintStream.println : (Z)V&gt;</span><br><span class="line"><span class="number">35</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><code>==</code> 比较的是两者的内存地址引用是否相等，显然上面一个是c在局部变量中存储的是 字符串常量池的引用，d时在堆内存上的字符串地址引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> + <span class="string">&quot;2&quot;</span>;</span><br><span class="line">System.out.println(c == d); # 输出 <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>字符串字面量的拼接在编译时就会被优化直接连接，d直接引用字符串常量池的地址，因此地址一样输出 true</p>
<p>String的intern</p>
<p>String的<code>intern</code>方法用于在运行时将字符串对象添加到字符串常量池中，并返回字符串常量池中对应的引用地址。在jdk7前，intern()方法会将第一次遇到的字符串实例从堆内存中复制到永久代的字符串常量池中， 此时返回的是永久代中字符串常量池的字符串的实例的引用。而jdk7及之后，方法会将第一次遇到的字符串的引用存入到字符串常量池中，返回到是字符串常量池的字符串的引用的引用，因此次数它的字符串地址和堆内存地址相同。</p>
<p>类的静态变量</p>
<blockquote>
<p>类的静态变量的存储在哪里?</p>
<p>jdk6及之前的版本中，静态变量是存放在方法区中的 instanceKlass，也就是永久代中。</p>
<p>jdk7及之后的版本中，静态变量是存放在堆中的java.lang.Class对象中</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是 在jdk8及之后，方法区存储在直接内存中。</p>
<p>直接内存解决了jdk1.4引入NIO机制后带来了的问题：</p>
<p>NIO 支持使用 native 函数直接分配直接内存，通过存储在java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作，避免了数据在直接内存和堆中的来回复制，提升了性能。</p>
<p><img src="https://s2.loli.net/2024/01/03/iD2U47Mqasg9e8B.png" alt="image-20240103152502254"></p>
</blockquote>
<p>使用 arthas 的 memory 命令可以看到 直接内存的情况</p>
<p><img src="https://s2.loli.net/2024/01/03/BxZrvPFeb1uztEW.png" alt="image-20240103152750154"></p>
<h4 id="直接内存的配置"><a href="#直接内存的配置" class="headerlink" title="直接内存的配置"></a>直接内存的配置</h4><p>直接内存的分配收到操作系统的影响，不可能无限制的增大，当各个内存区域总和大于物理内存限制，会出现OutOfMemoryError异常。</p>
<p>使用参数 <code>-XX:MaxDirectMemorySize=&lt;size&gt;</code> 来手动调整直接内存的大小，在默认情况下，jvm会自动选择最大分配的大小（如果系统底层使用了NIO，建议手动设置）。</p>
<h3 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><blockquote>
<p>内存溢出（Memory Overflow）指的是程序在运行过程中请求的内存超过了虚拟机所能提供的最大限制，导致程序运行出现错误。</p>
</blockquote>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><blockquote>
<p>在c/c++语言中，没有自动垃圾回收机制，一个对象如果不再使用需要手动进行释放即进行垃圾回收，否则就会出现内存泄漏（Memory Leak）。</p>
</blockquote>
<h3 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h3><p><strong>内存泄漏</strong>（<strong>Memory Leak</strong>）：程序中<strong>已经不再使用的对象或者资源没有被正常释放</strong>，导致这部分内存无法再被程序访问和利用。</p>
<p><strong>内存溢出</strong>（<strong>Memory Overflow</strong>）：程序在运行过程中<strong>需要的内存超过了系统所能提供的最大限制</strong>，导致程序无法正常运行。</p>
<blockquote>
<p>内存泄漏的积累会导致内存溢出</p>
</blockquote>
<p>java 简化了对象的释放，引入了自动垃圾回收（Garbage Collection，下文简称GC）机制。通过垃圾回收器对于不再使用的对象进行自动的回收。</p>
<p>垃圾回收器属于jvm执行引擎的一部分，主要负责对堆上的不使用的对象内存进行回收。</p>
<blockquote>
<p>对于线程私有的部分（程序计数器、java虚拟机栈、本地方法栈）是无需垃圾收集器进行回收的，因为这三部分是存放在线程内部的，伴随着线程的生命周期，随着线程的创建而创建，随着线程的销毁而销毁。同时，方法栈帧会在方法执行完毕后，栈帧会自动弹出栈并释放栈的内存。</p>
</blockquote>
<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>对于方法区中的回收主要是 不再使用的类：</p>
<p>判断一个类是否可以被回收，需要同时满足以下条件：</p>
<ul>
<li>类的所有实例对象均被回收：堆内存中不存在该类实例对象和该类的子类对象</li>
<li>类的加载器的生命周期结束</li>
<li>类对应的 java.lang.Class 对象没有被任何地方引用</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="type">URLClassLoader</span> <span class="variable">urlClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;/xxx/xxx&quot;</span>));</span><br><span class="line">  Class&lt;?&gt; clazz = urlClassLoader.loadClass(<span class="string">&quot;com.xxx.xx&quot;</span>);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">  </span><br><span class="line">  System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，循环体中的对象在进入下一个循环时就没有引用了，因此会进行回收。</p>
<p>执行方法时，添加虚拟机启动参数：<code>-XX:+TraceClassLoading</code> 和 <code>-XX:+TraceClassUnloading</code>来打印类加载和卸载的信息</p>
<p><code>System.gc()</code>: 可以手动触发垃圾回收</p>
<p>​        不一定会立即触发垃圾回收，而是向jvm发送一个垃圾回收的请求，具体是否需要执行垃圾回收则需要虚拟机自行判断。</p>
<p>由于正常程序的类是由应用加载器来加载的，应用加载器在运行的过程中是不会被回收的，所以这些类都在运行中是不会被回收的。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在一些例如OSGi和jsp的热部署等应用场景中，例如jsp的热部署，每一个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载了这个jsp的加载器和类信息，重新创建类加载器，重新加载jsp文件，从而实现jsp热部署。</p>
<h3 id="堆回收"><a href="#堆回收" class="headerlink" title="堆回收"></a>堆回收</h3><h4 id="判断对象是否需要回收"><a href="#判断对象是否需要回收" class="headerlink" title="判断对象是否需要回收"></a>判断对象是否需要回收</h4><blockquote>
<p>java中的垃圾回收机制基于对象的引用关系。一个对象是否能够被垃圾回收主要取决于是否存在对该对象的引用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Coder</span> <span class="variable">coder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coder</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/01/03/XJ5uW39ESH4cwYU.png" alt="image-20240103203722674"></p>
<blockquote>
<p>常见判断的对象是否有被引用的方法有两种：引用计数法和可达性分析法。</p>
</blockquote>
<h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><blockquote>
<p>引用计数法（Reference Counting）为每个对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
</blockquote>
<p>引用计数器实现简单，判定效率也很高。但是总在一些问题：</p>
<ul>
<li><p>每个对象都占用一些额外的内存空间来计数，并且引用的确认和失效都需要维护这个引用计数器，对于系统的开销有一定的影响。</p>
</li>
<li><p>存在循环引用问题</p>
<p>如果对象objA和objB都有字段instance，赋值令 objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已 经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也 就无法回收它们。</p>
</li>
</ul>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">SimpleClass</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleClass</span>();</span><br><span class="line">      <span class="type">SimpleClass</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleClass</span>();</span><br><span class="line">      objA.instance = objB;</span><br><span class="line">      objB.instance = objA;</span><br><span class="line">      objA = <span class="literal">null</span>;</span><br><span class="line">      objB = <span class="literal">null</span>;</span><br><span class="line">      System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>-verbose:gc</code> 查看垃圾回收日志</p>
<p><img src="https://s2.loli.net/2024/01/03/1UpGzZLXveKWInS.png"></p>
<p>上图可以看到内存回收日志中内存空间变化，意味着jvm没有因为这两个对象互相引用而放弃回收它们，则jvm并不是通过引用计数算法来判定对象是否是否存活。</p>
<h5 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h5><blockquote>
<p>jvm 通过 可达性算法（Reachability Analysis）算法来判定对象是否存活的。</p>
<p>可达性算法的对象被分为两类：垃圾回收的根对象（GC Root）和 普通对象。</p>
<p>可达性算法就是通过一系列称为”GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连即从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/03/1elKgyBIs9q7Twu.png" alt="image-20240103212130937"></p>
<h6 id="GC-Root对象"><a href="#GC-Root对象" class="headerlink" title="GC Root对象"></a>GC Root对象</h6><p>GC Roots的对象包括以下几种：</p>
<ul>
<li>虚拟机栈中引用的对象（局部变量，方法参数、临时变量等）</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>jvm 内部引用</li>
<li>监视器对象即被同步锁持有的对象</li>
</ul>
<h6 id="如何查看GC-ROOT"><a href="#如何查看GC-ROOT" class="headerlink" title="如何查看GC ROOT"></a>如何查看GC ROOT</h6><p>通过 arthas 和 eclipse memory analyzer(MAT) 查看 GC ROOT</p>
<blockquote>
<p>MAT 工具是 java堆内存的检测工具</p>
</blockquote>
<ul>
<li>使用 arthas 的 <code>heapdump</code> 命令将<strong>堆内存快照</strong>保存到本地磁盘中</li>
</ul>
<img src="https://s2.loli.net/2024/01/03/cmXLWew5kU6uZyv.png" alt="image-20240103220015710" style="zoom:33%;" />

<ul>
<li><p>使用 MAT 工具打开堆内存快照文件</p>
</li>
<li><p>选择 GC Roots 功能查看所有的GC Root   <img src="https://s2.loli.net/2024/01/03/kKbEh42ZMdY1BP7.png" alt="image-20240103222648481"></p>
</li>
</ul>
<h5 id="四种对象引用"><a href="#四种对象引用" class="headerlink" title="四种对象引用"></a>四种对象引用</h5><blockquote>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和”引用”有关。</p>
<p>在JDK 1.2版之后，java 对引用的概念进行了扩充，将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
</blockquote>
<h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><blockquote>
<p>强引用（Strongly Reference）是最传统和最普遍的引用的定义。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>回收情况：强引用指向的对象无论任何情况都<strong>不会被回收</strong></p>
<h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><blockquote>
<p>软引用用来描述一些还有用但是非必需的对象，软引用通过 <code>SoftReference</code> 类来实现(格式：new SoftReference&lt;对象类型&gt;(对象))。</p>
<p>软引用一般用于<strong>缓存</strong>中，即对象的存在对程序性能有帮助必须的场景。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>()； # <span class="keyword">new</span> <span class="title class_">Object</span>() 在堆中创建Object示例并使用obj建立强引用</span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj); # <span class="keyword">new</span> <span class="title class_">SoftReference</span>在堆中创建软引用对象包装obj并使用softRef建立软引用</span><br><span class="line">obj = <span class="literal">null</span>; # 清除obj强引用关联</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/01/04/vTRNrg3O5x2p6Iu.png" alt="image-20240104104152984" style="zoom:33%;" />

<p>回收情况：软引用中的对象只有<strong>在内存不够的情况</strong>下才会被回收</p>
<blockquote>
<p>注意：内存不够的情况下，会回收掉使用SoftReference包装的对象，堆中创建的SoftReference对象本身也需要进行回收。</p>
<p>SoftReference 提供了一套队列机制，使用引用队列（ReferenceQueue）来监控软引用对象的回收。通过检查引用队列中是否包含软引用对象，可以得知SoftReference对象是否被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), referenceQueue);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 检查引用队列中是否包含软引用对象</span></span><br><span class="line">SoftReference&lt;Object&gt; polledRef = (SoftReference&lt;Object&gt;) referenceQueue.poll();</span><br><span class="line"><span class="keyword">if</span> (polledRef != <span class="literal">null</span>) &#123;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><blockquote>
<p>弱引用用于描述一些非必须的对象，它的强度比软引用更弱一点。弱引用应用于 ThreadLocal 中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>回收情况：当垃圾收集器开始垃圾回收时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。</p>
<h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><blockquote>
<p>虚引用也称为“幽灵引用”或者“幻影引用”，不能通过虚引用对象获取对象实例。虚引用的唯一用途是 当对象被收集器回收时收到一个系统通知。</p>
</blockquote>
<p>jdk 提供 <code>PhantomReference</code> 类来实现虚引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><blockquote>
<p>对象垃圾回收分为两个阶段：标记阶段和清理阶段</p>
<ul>
<li>标记阶段（Marking）：标记内存中存活的对象<ul>
<li>标记过程中，未被标记的对象将被认为是不可达的，即垃圾对象。</li>
</ul>
</li>
<li>清理阶段（Sweeping）：垃圾回收器清理并回收那些不存活的对象所占用的内存空间。</li>
</ul>
</blockquote>
<blockquote>
<p>jvm 垃圾回收过程会通过单独的垃圾回收线程来执行。因为垃圾回收是相对耗时的操作，如果在主线程中执行，会导致应用程序停顿，影响用户体验。</p>
<p>不同的垃圾回收算法和 jvm 有不同的线程管理策略，但不管使用哪一种垃圾回收算法，都会有部分阶段，整个应用程序的所有线程都被暂停，不再执行任何指令，此阶段被称为 STW 即 stop the world。如果STW的时间越长越会影响用户的体验，因此此过程越短越好。</p>
</blockquote>
<h5 id="垃圾回收算法的评价标准"><a href="#垃圾回收算法的评价标准" class="headerlink" title="垃圾回收算法的评价标准"></a>垃圾回收算法的评价标准</h5><ul>
<li>吞吐量：吞吐量是指在一定时间内应用程序实际运行的时间占总时间的比例。高吞吐量通常意味着垃圾回收的效率较高。<ul>
<li>总时间 = 应用程序实际运行 + 垃圾回收时间</li>
</ul>
</li>
<li>暂停时间： 应用程序的暂停时间是指在进行垃圾回收时，应用程序中断执行的时间。<ul>
<li>低延迟的应用，较短的暂停时间通常是一个关键的性能指标。尤其是最大暂停时间不能过长。</li>
</ul>
</li>
<li>内存利用率：有效提高内存利用率是一个重要的标准。同时减少内存碎片的问题也会减少对于后续的内存分配的影响。</li>
</ul>
<p>不同的垃圾回收算法需要结合具体应用场景的需求进行选择。</p>
<h5 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h5><h6 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h6><blockquote>
<p>标记-清除（Mark and Sweep）：将存活的对象进行标记，然后清理掉未被标记的对象即非存活对象。</p>
</blockquote>
<img src="https://s2.loli.net/2024/01/04/j4tsmZ9QEc1Hzrp.jpg" alt="image"  />

<p>优点：实现简单（只需要在标记阶段给每一个对象维护一个标志位）</p>
<p>缺点：执行效率不高，标记和清除过程的执行效率随着对象的数量的增长而降低</p>
<p>​     内存空间碎片化问题，标记清除产生大量不连续的内存碎片，导致内存较大对象无法分配以及分配速度需要遍历导致速度慢的问题（通常通过“分区空闲分配链 表”来进行内存分配）</p>
<h6 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h6><blockquote>
<p>复制算法（Copying）：将内存划分为大小相等的两块，一半是活动对象的当前存放地（from），另一半是空闲区（to）。当这一块内存用完了就将还存活的对象复制到另一块上面并有序排列，然后再把使用过的内存空间进行一次清理。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/04/DeQnjVuSshlyKMC.png" alt="image-20240104114033697"></p>
<p>优点：不会出现内存碎片化问题（对象复制到另一块内存空间会按顺序存放），内存分配速度快，按顺序分配即可</p>
<p>缺点：内存使用效率低，可用内存空间缩小到原来的一半</p>
<p>​     当有大量对象存活时会产生大量内存复制的开销</p>
<h6 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h6><blockquote>
<p>标记-整理（Mark and Compact）：标记过程和”标记-清除”算法一样，但是后续整理阶段让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/04/RgAVKCpQXxqyhZt.png" alt="image-20240104132131609"></p>
<p>优点：内存使用率较高、不会产生内存碎片，内存分配性能好</p>
<p>缺点：整理阶段的效率不高并且阻塞用户程序（移动存活对象并更新所有引用这些对象的地方）</p>
<h6 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h6><blockquote>
<p>分代垃圾回收算法（Generational）：根据对象的存活周期将内存划分为几块，不同的块采用不同垃圾回收算法</p>
<p>一般将堆内存划分为 新生代和老年代, 其中新生代又被划分 <code>Eden</code>区，<code>s0</code> 和 <code>s1</code> 区</p>
<ul>
<li>新生代：存放存活时间比较短的对象</li>
<li>老年代：存放存活时间比较长的对象</li>
</ul>
</blockquote>
<p>添加启动参数 <code>-XX:userSerialGC</code> 参数使用<code>分代垃圾回收器</code>运行程序，然后使用 arthas 的 memory 命令查看内存结构和占用情况</p>
<p><img src="https://s2.loli.net/2024/01/04/RqS3wk7AIWsOrv2.png" alt="image-20240104134610689"></p>
<p>参数设置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseSerialGC SimpleClass # -XX:+UseSerialGC 使用的是基于分代算法的串行垃圾回收器</span><br><span class="line">-Xms #  设置 java 堆内存的初始大小</span><br><span class="line">-Xmx # 设置 java 堆内存的最大大小</span><br><span class="line">-Xmn # 设置 java 堆内存的新生代的大小</span><br><span class="line">-XX:NewRatio=2  # 设置老生代和新生代的比例</span><br><span class="line">-XX:SuriviorRatio # 设置新生代中 Eden 区和 单个Survivor 区的比例。SurvivorRatio 的默认值是 8 即  Eden 区占新生代的 8 部分，每个 Survivor 区各占 1 部分</span><br><span class="line">-XX:PrintGCDetails # 启用垃圾回收日志详细信息的打印</span><br><span class="line">-verbose:gc # 启用垃圾回收的详细输出【前者更加详细】</span><br></pre></td></tr></table></figure>

<p>分代垃圾回收流程</p>
<ul>
<li><p>分配阶段 - Allocation：新创建的对象首先被分配到新生代的 Eden 区</p>
</li>
<li><p>新生代垃圾回收 - Minor GC：当 Eden 区满时，会触发 Minor GC（也称 Young GC）</p>
<ul>
<li><p>Minor GC 采用 <code>标记-复制</code> 算法识别和标记仍然存活的对象，将存活的对象复制到一个 Survivor 区并清空 Eden 区</p>
<p>再次 Minor GC 时，将上一个 Survivor 区和 Eden 区仍然存活的对象复制到另一个 Survivor 区</p>
</li>
</ul>
</li>
<li><p>老化 - Aging：每次 Minor GC 都会为存活的对象记录年龄，初始值为0，每次 GC 存活对象的年龄增 1，当对象年龄到达阈值（最大15，默认值与垃圾回收器有关），对象会晋升到老年代（注：当新生代的空间不足时，部分对象也会晋升到老年代）</p>
</li>
<li><p>老年代垃圾回收 - Major GC：当老年代空间不足时，尝试进行 Minor GC 后仍然无法满足内存需求时，就会触发 Major GC （也称 Full GC），Major GC 会对整个堆内存进行回收，包括新生代和老年代。</p>
</li>
</ul>
<blockquote>
<p>Minor GC 频繁发生，会导致短暂的STW</p>
<p>Major GC 发生频率较低，整个堆都需要被扫描和清理会导致较长的STW，开销较高</p>
<p>​         如果 Major GC 后老年代仍然无法容纳新对象，会导致内存溢出</p>
</blockquote>
<p>为什么分代思想将堆划分为年轻代和老年代？</p>
<blockquote>
<p>新生代和老年代分别采用不同的垃圾回收算法和策略，以优化不同生命周期的对象的回收效率，减小每次垃圾回收的停顿时间，并提高整体垃圾回收的吞吐量。</p>
<p>开发者可以更加灵活的设置年轻代和老年代的比例来适应不同类型的应用程序（例如：并发比较高的应用可以适当增加年轻代，反正新生代内存占满后，对象提前晋升最终导致老年代占满频繁 Major GC 甚至导致内存溢出）</p>
</blockquote>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><blockquote>
<p>垃圾收集器就是内存回收算法的具体实现</p>
</blockquote>
<h5 id="常见的垃圾回收器"><a href="#常见的垃圾回收器" class="headerlink" title="常见的垃圾回收器"></a>常见的垃圾回收器</h5><h6 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h6><p>各款经典收集器之间的关系如下</p>
<p><img src="https://s2.loli.net/2024/01/04/mbjwQ6RvxkHEfnO.png" alt="image-20240104145042847"></p>
<h5 id="垃圾回收器的使用"><a href="#垃圾回收器的使用" class="headerlink" title="垃圾回收器的使用"></a>垃圾回收器的使用</h5><h6 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h6><blockquote>
<p>Serial收集器是<strong>单线程串行</strong>回收的<strong>年轻代</strong>收集器，采用 <strong>标记-复制</strong> 算法</p>
<p>单线程强调的是它在进行垃圾回收时，必须暂停其他所有工作线程，直到它收集结束。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/04/pRtbS2QiV8k4uNE.png"></p>
<p>优点：简单、高效，适用于单线程环境，单CPU处理器下吞吐量大</p>
<p>缺点：单线程执行不适用于多核处理器，可能导致停顿时间较长</p>
<p>使用场景：单核CPU小型应用、客户端应用</p>
<h6 id="SerialOld收集器"><a href="#SerialOld收集器" class="headerlink" title="SerialOld收集器"></a>SerialOld收集器</h6><blockquote>
<p>Serial Old是 Serial 收集器的老年代版本，是<strong>单线程串行</strong>回收的<strong>老年代</strong>收集器，采用 <strong>标记-整理</strong> 算法</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/04/I1ZEShtwcy6gxOb.png" alt="image-20240104151248065"></p>
<p>优缺点和使用场景和 Serial收集器 一致。</p>
<blockquote>
<p>使用启动参数 <code>-XX:+UseSerialGC</code> 开启 Serial收集器 和 SerialOld收集器 的单线程串行垃圾收集器组合。</p>
</blockquote>
<h6 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h6><blockquote>
<p>ParNew收集器是Serial收集器的多线程并行版本，使用<strong>多线程</strong>进行垃圾回收的<strong>年轻代</strong>收集器，采用  <strong>标记-整理</strong> 算法</p>
<p>使用参数 <code>-XX:+UseParNewGC</code> 开启新生代使用 ParNew 回收器，老年代使用串行回收器。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/04/TMFioBOWgp9q8jf.png" alt="image-20240104161804887"></p>
<p>优点：多线程执行垃圾回收，提高了垃圾回收的吞吐量；多核处理器停顿时间减少</p>
<p>缺点：不满足对停顿时间要求极高的场景</p>
<p>使用场景：中等规模的应用，对停顿时间要求不是特别严格的场景</p>
<h6 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h6><blockquote>
<p>CMS 收集器（Concurrent Mark-Sweep GC）是一种<strong>旨在获取最短回收停顿时间为目标</strong>的老年代收集器，采用  <strong>标记-清理</strong> 算法，在部分步骤中，采用了并发的执行方式，以尽量减小在垃圾回收过程中应用程序的停顿时间。</p>
<p>使用参数 <code>-XX:+UseConcMarkSweepGC</code> 开启老年代使用 CMS 回收器。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/04/oOM9EpRed2wPcNA.png" alt="image-20240104153222282"></p>
<p>整个过程分为四个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark） - <strong>STW</strong>：用较短的时间识别并标记与根对象（GC Root）直接关联的对象</li>
<li>并发标记（CMS concurrent mark）：并发标记，遍历对象图，标记所有可达的对象</li>
<li>重新标记（CMS remark） - <strong>STW</strong>：在并发标记期间可能产生的新的存活对象，进行一次短暂的新对象重新标记并进行修正</li>
<li>并发清除（CMS concurrent sweep）：并行清理标记为垃圾的对象，释放空间</li>
</ul>
<p>初始标记和重新标记阶段会造成短暂的停顿，并发标记和并发清除阶段是并发执行，占据上面流程中较长的时间。</p>
<p>优点：部分并发执行，减少了停顿时间</p>
<p>缺点：标记清除导致的内存碎片问题；在老年代内存分配对象不足的情况下会推化为SerialOld单线程串行垃圾回收器；</p>
<p>​     产生“浮动垃圾”问题，无法处理在并法清理阶段产生的垃圾对象；</p>
<p>​     并发阶段占用CPU资源造成性能影响</p>
<p>使用场景：适用于对于停顿时间要求较高的中大型应用，请求数据量大和频率高的场景（jdk14后，cms被废弃）</p>
<h6 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h6><blockquote>
<p>Parallel Scavenge是jdk8默认的年轻代垃圾回收器，在诸多特性从表面上看和ParNew非常相似，多线程并行回收。</p>
<p>Parallel Scavenge和与其他收集器不同的关注点，CMS等收集器的关注点是尽可能 地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐 量（Throughput）。</p>
<img src="https://s2.loli.net/2024/01/04/JFReA2YqvSZ9GdC.png" alt="image-20240104162047479" style="zoom:33%;" />

<p>Parallel Scavenge 可以通过参数打开 GC 自适应的调节策略（GC Ergonomics），jvm 会自动根据系统的配置和应用程序的行为进行调整堆参数（堆内存的大小、结构，晋升阈值等等），以提供最合适的停顿时间或者最大的吞吐量。</p>
</blockquote>
<p>优点：吞吐量高，自适应调节</p>
<p>缺点：不能保证每一次的停顿时间</p>
<p>适用场景：适用于执行时间较长、计算密集型的后台任务（例如：大数据处理和大文件导出），对吞吐量要求较高并且停顿时间要求相对宽松的场景</p>
<h6 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h6><blockquote>
<p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持<strong>多线程并发收集</strong>，基于<strong>标记-整理</strong>算法的老年代收集器。</p>
</blockquote>
<blockquote>
<p>使用参数 <code>-XX:+UseParallGC</code>或者 <code>-XX:+UserParallelOldGC</code> 开启使用 Parallel Scavenge 和 Parallel old 回收器的组合，但是jdk8默认启用的是这种组合，可以使用 <code>java -XX:+PrintCommandLineFlags --version</code> 查看当前 jvm 默认参数。</p>
</blockquote>
<p>优缺点和适用场景和 Parallel Scavenge 相似。</p>
<blockquote>
<p>Parallel scavenge 和 Parallel old 的组合时的参数设置：</p>
<p>Oracle官方建议，在使用这个组合时，不要设置堆内存的最大值，垃圾回收器会根据最大暂停时间和吞吐量 自动调整内存大小。</p>
<ul>
<li><code>-XX:MaxGCPauseMillis=n</code>：设置每次垃圾回收时的最大停顿毫秒数</li>
<li><code>-XX:GCTimeRatio=n</code>：设置吞吐量为n（用户线程执行时间 = n/n + 1)</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存参数的开关（默认为 true）</li>
</ul>
</blockquote>
<h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><blockquote>
<p>G1（Garbage First）收集器是 jdk9及之后默认的垃圾收集器，jdk9之后最推荐使用的垃圾收集器。</p>
<p>它是一款主要面向服务端应用的垃圾收集器，在 多CPU 和 大内存 的场景下有很好的性能。</p>
</blockquote>
<p>G1之前的垃圾收集器，内存结构一般是连续的，如下图</p>
<p><img src="https://s2.loli.net/2024/01/04/qPx1payzNDCk6Jm.png" alt="image-20240104170509132"></p>
<p>而G1也仍是遵循分代收集理论设计的，但是它堆内存的布局与其他收集器有非常明显的差异。</p>
<p>它把 连续的jvm堆 划分为 多个大小相等的独立区域（Region），使得新生代和老年代不再物理隔离，每个区域可以根据需求扮演不同的空间（新生代eden空间、Survior空间或者老年代空间），这样更有利于控制垃圾回收的时间。</p>
<img src="https://s2.loli.net/2024/01/04/nRrgIoLJXimOUF1.png" alt="image-20240104171231201" style="zoom:33%;" />

<h6 id="Region-Size"><a href="#Region-Size" class="headerlink" title="Region Size"></a>Region Size</h6><p>region 的大小 = 堆空间大小/2048 M，也可以通过参数 <code>-XX:G1HeapRegionSize=&lt;size&gt;</code>指定大小。</p>
<p>region size必须是2的指数幂，取值范围从1M到32M(1,2,4,8,16.32)。</p>
<h6 id="G1-垃圾回收方法"><a href="#G1-垃圾回收方法" class="headerlink" title="G1 垃圾回收方法"></a>G1 垃圾回收方法</h6><blockquote>
<p>G1 垃圾收集器的垃圾回收方法包括 Minor GC（年轻代垃圾回收）和 Mixed GC（混合垃圾回收）两种</p>
</blockquote>
<ul>
<li>Minor GC<ul>
<li><strong>触发时机</strong>：当年轻代中的Eden填满（Eden区最多占用60%）时，触发 Minor GC</li>
<li><strong>工作内容</strong>：Minor GC 主要采用 <strong>标记-复制</strong> 对年轻代进行垃圾回收。</li>
<li><strong>停顿时间</strong>：会导致短暂的STW，可以通过参数 <code>-XX:MaxGCPauseMillis=n</code>(单位：毫米，默认200) 设置每次垃圾回收时的最大暂停时间毫秒数。</li>
</ul>
</li>
<li>Mixed GC<ul>
<li><strong>触发时机</strong>：当老年代的占用达到一定的阈值（默认为45%，可通过<code>-XX:InitiatingHeapOccupancyPercent</code> 配置）时，触发 Mixed GC</li>
<li><strong>工作内容</strong>：Mixed GC 采用<strong>标记-复制</strong>收集所有年轻代、一部分老年代以及大对象区</li>
<li><strong>停顿时间</strong>： Mixed GC 的停顿时间相对较短，因为它只处理了部分老年代</li>
</ul>
</li>
</ul>
<h6 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h6><ul>
<li>Minor GC</li>
</ul>
<blockquote>
<p>新创建的对象会首先被分配到年轻代的Eden区，当G1判断到年轻代（包括Eden区和Survivor区）的空间不足以分配新对象时（年轻代默认初始占用堆空间百分比为5%，默认最大占用堆空间百分比为60%，可以由 <code>-XX:G1NewSizePercent</code> 和 <code>-XX:G1MaxNewSizePercent</code>进行配置）即当年轻代占用空间接近60%时，就会触发 Minor GC。Minor GC首先标记住Eden和Survivor区域中的存活对象，然后根据”Pause Prediction Model”算法和配置的最大暂停时间（通过 <code>-XX:MaxGCPauseMillis</code> 选项配置）来动态选择合适的区域进行垃圾回收并将存活的对象复制到新的Survivor区中，同时对象年龄+1，然后清空之前相应的区域。当某个存活的对象年龄达到了阈值（默认15），则晋升至老年代。</p>
<p>此处注意一个特殊情况，如果存在大对象超过参数HumongousThreshold（默认2M），它将占用，则会将它直接放入<code>Humongous</code>区域。</p>
</blockquote>
<ul>
<li><p>Mixed GC</p>
<blockquote>
<p>当老年代的占用达到一定的阈值（通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 配置，默认为45%）时，G1会触发 Mixed GC，主要目标是同时采用<strong>标记-复制</strong>（本质上，也是整理，不容易产生内存碎片）收集所有年轻代、一部分老年代（保证回收的最大暂停时间）以及大对象区。            </p>
</blockquote>
</li>
<li><p>Full GC</p>
<blockquote>
<p>当发现没有足够的空 region 存放转移的对象，会出现Full GC，此时单线程执行标记-整理算法，这个执行过程会导致用户线程暂停即STW。因此尽量保证应用的堆内存有一定的空间，防止出现内存溢出的情况。</p>
</blockquote>
</li>
</ul>
<h6 id="G1-垃圾混合回收过程"><a href="#G1-垃圾混合回收过程" class="headerlink" title="G1 垃圾混合回收过程"></a>G1 垃圾混合回收过程</h6><ul>
<li>初始标记 - STW：用于标记根对象（GC Root）与根对象直接关联的对象。</li>
<li>并发标记：通过 <code>Snapshot-At-The-Beginning</code>（SATB）原始快照算法并发标记所有存活的对象</li>
<li>最终标记 - STW：确认已经标记的信息的准确性，不会标记 并发标记阶段产生的新对象</li>
<li>并发清理：选择部分存活度较低的区域，将其中存活的对象复制到其他空闲的region中（本质整理，不容易产生内存碎片）</li>
</ul>
<p><img src="https://s2.loli.net/2024/01/04/OLQVvlA4JPMEDqf.png" alt="image-20240104214130716"></p>
<blockquote>
<p>和CMS不同点在于:最终标记不会对于并发标记阶段产生的新对象进行标记，提高了性能。</p>
<p>​              并发清理采用了复制算法，而CMS采用了标记清理算法，同时G1并发清理不会清理整个堆上的，而是选择部分存活度较低的区域。</p>
</blockquote>
<h6 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h6><blockquote>
<p>jdk8版本 g1 收集器还不够成熟，可以通过 <code>-XX:UseG1GC</code> 打开，jdk9 默认采用了g1收集器，无需参数启用。</p>
<p>可以通过 <code>-XX:MaxGCPauseMillis=&lt;millis&gt;</code> 设置最大暂停时间，默认200ms</p>
</blockquote>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>面对大堆的场景，延迟可控</li>
<li>不会产生内存碎片</li>
<li>并发标记采用 SATB算法 效率和准确性高</li>
</ul>
<h5 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h5><blockquote>
<ul>
<li>jdk8 <ul>
<li>单核or客户端应用：serial + serialold</li>
<li>关注暂停时间 - 互联网用户应用：parNew + CMS</li>
<li>关注吞吐量 - 后台任务：parallel scavenge + parallel old</li>
</ul>
</li>
<li>jdk9 g1</li>
</ul>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">YuanJW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/28/jvm-1-%E5%9F%BA%E7%A1%80/">http://example.com/2023/12/28/jvm-1-%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/jvm/">jvm</a></div><div class="post_share"><div class="social-share" data-image="/img/default-cover/45.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/05/jvm-2-%E5%AE%9E%E6%88%98/"><img class="prev-cover" src="/img/default-cover/12.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">jvm 实战</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/06/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"><img class="next-cover" src="/img/default-cover/25.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">JVM性能调优工具</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/01/15/jvm-3-%E9%AB%98%E7%BA%A7/" title="jvm 高级"><img class="cover" src="/img/default-cover/55.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="title">jvm 高级</div></div></a></div><div><a href="/2024/01/26/jvm-4-%E5%8E%9F%E7%90%86/" title="jvm 原理"><img class="cover" src="/img/default-cover/46.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">jvm 原理</div></div></a></div><div><a href="/2024/01/05/jvm-2-%E5%AE%9E%E6%88%98/" title="jvm 实战"><img class="cover" src="/img/default-cover/12.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-05</div><div class="title">jvm 实战</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YuanJW</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XiaoYuanJW" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2754742370@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jvm-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">jvm 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8Bjvm"><span class="toc-number">1.1.</span> <span class="toc-text">初始jvm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm%E8%81%8C%E8%B4%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">jvm职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text">jvm功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-vs-c"><span class="toc-number">1.1.3.</span> <span class="toc-text">java vs c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jit-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.4.</span> <span class="toc-text">jit - 即时编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84jvm"><span class="toc-number">1.1.5.</span> <span class="toc-text">常见的jvm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hotspot-%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">Hotspot 发展历程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm-%E7%BB%84%E6%88%90"><span class="toc-number">1.1.6.</span> <span class="toc-text">jvm 组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">字节码文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">字节码文件定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">字节码文件的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">一般信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">常量池引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.1.3.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">字节码指令执行分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">示例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.3.</span> <span class="toc-text">字节码文件常见的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#javap"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">javap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDEA%E6%8F%92%E4%BB%B6jclasslib"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">IDEA插件jclasslib</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arthas"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">Arthas</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">快速开始</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A6%82%E8%A7%88"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">功能概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dump"><span class="toc-number">1.2.3.3.3.</span> <span class="toc-text">dump</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jad"><span class="toc-number">1.2.3.3.4.</span> <span class="toc-text">jad</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.</span> <span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">类的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">加载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java-lang-Class%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">java.lang.Class类的实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bjvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">查看jvm内存结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.1.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">初始化的触发</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">卸载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">类加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">扩展加载器和应用加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.3.2.1.2.1.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.3.2.1.2.2.</span> <span class="toc-text">应用类加载器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">双亲委派机制的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">如何打破双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">为什么要打破双亲委派机制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.2.3.2.</span> <span class="toc-text">双亲委派机制的实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.3.3.</span> <span class="toc-text">打破双亲委派机制的方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">热部署的类加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">jdk 类加载器的变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">运行时内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">程序计数器的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">栈帧的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">1.4.1.2.1.1.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">1.4.1.2.1.2.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.4.1.2.1.3.</span> <span class="toc-text">动态链接</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%87%BA%E5%8F%A3"><span class="toc-number">1.4.1.2.1.4.</span> <span class="toc-text">方法出口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="toc-number">1.4.1.2.1.5.</span> <span class="toc-text">异常表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">虚拟机的栈内存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.4.1.4.1.</span> <span class="toc-text">参数设置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.1.5.1.</span> <span class="toc-text">方法区设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%84%E6%88%90"><span class="toc-number">1.4.1.5.2.</span> <span class="toc-text">方法区组成</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.1.5.2.1.</span> <span class="toc-text">类的基础信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.4.1.5.2.2.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.4.1.5.2.3.</span> <span class="toc-text">字符串常量池</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">直接内存的配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.3.</span> <span class="toc-text">内存溢出问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">1.5.1.</span> <span class="toc-text">内存泄漏和内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">方法区的回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">堆回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">判断对象是否需要回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">可达性分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#GC-Root%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.3.1.2.1.</span> <span class="toc-text">GC Root对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BGC-ROOT"><span class="toc-number">1.5.3.1.2.2.</span> <span class="toc-text">如何查看GC ROOT</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">四种对象引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.3.1.3.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.3.1.3.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.3.1.3.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.3.1.3.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86"><span class="toc-number">1.5.3.2.1.</span> <span class="toc-text">垃圾回收算法的评价标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.2.2.</span> <span class="toc-text">常见的垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="toc-number">1.5.3.2.2.1.</span> <span class="toc-text">标记-清除</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6"><span class="toc-number">1.5.3.2.2.2.</span> <span class="toc-text">标记-复制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86"><span class="toc-number">1.5.3.2.2.3.</span> <span class="toc-text">标记-整理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E4%BB%A3"><span class="toc-number">1.5.3.2.2.4.</span> <span class="toc-text">分代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.5.3.3.1.</span> <span class="toc-text">常见的垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.3.3.1.1.</span> <span class="toc-text">垃圾回收器的组合关系</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.3.3.2.</span> <span class="toc-text">垃圾回收器的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.5.3.3.2.1.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SerialOld%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.5.3.3.2.2.</span> <span class="toc-text">SerialOld收集器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.5.3.3.2.3.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.5.3.3.2.4.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.5.3.3.2.5.</span> <span class="toc-text">Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.5.3.3.2.6.</span> <span class="toc-text">Parallel Old收集器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.5.3.3.3.</span> <span class="toc-text">G1收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Region-Size"><span class="toc-number">1.5.3.3.3.1.</span> <span class="toc-text">Region Size</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.3.3.2.</span> <span class="toc-text">G1 垃圾回收方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.3.3.3.3.</span> <span class="toc-text">G1 垃圾回收流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#G1-%E5%9E%83%E5%9C%BE%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.3.3.3.4.</span> <span class="toc-text">G1 垃圾混合回收过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.5.3.3.3.5.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.5.3.3.4.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.5.3.3.5.</span> <span class="toc-text">垃圾收集器的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.5.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/14/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/" title="JUC 并发编程 (三) JUC并发工具"><img src="/img/default-cover/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 并发编程 (三) JUC并发工具"/></a><div class="content"><a class="title" href="/2024/02/14/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/" title="JUC 并发编程 (三) JUC并发工具">JUC 并发编程 (三) JUC并发工具</a><time datetime="2024-02-13T16:00:00.000Z" title="Created 2024-02-14 00:00:00">2024-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/12/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/" title="JUC 并发编程 (二) JMM"><img src="/img/default-cover/16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 并发编程 (二) JMM"/></a><div class="content"><a class="title" href="/2024/02/12/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/" title="JUC 并发编程 (二) JMM">JUC 并发编程 (二) JMM</a><time datetime="2024-02-11T16:00:00.000Z" title="Created 2024-02-12 00:00:00">2024-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/10/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/" title="JUC 并发编程 (一) 基础"><img src="/img/default-cover/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 并发编程 (一) 基础"/></a><div class="content"><a class="title" href="/2024/02/10/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/" title="JUC 并发编程 (一) 基础">JUC 并发编程 (一) 基础</a><time datetime="2024-02-09T16:00:00.000Z" title="Created 2024-02-10 00:00:00">2024-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/26/jvm-4-%E5%8E%9F%E7%90%86/" title="jvm 原理"><img src="/img/default-cover/46.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jvm 原理"/></a><div class="content"><a class="title" href="/2024/01/26/jvm-4-%E5%8E%9F%E7%90%86/" title="jvm 原理">jvm 原理</a><time datetime="2024-01-25T16:00:00.000Z" title="Created 2024-01-26 00:00:00">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/15/jvm-3-%E9%AB%98%E7%BA%A7/" title="jvm 高级"><img src="/img/default-cover/55.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jvm 高级"/></a><div class="content"><a class="title" href="/2024/01/15/jvm-3-%E9%AB%98%E7%BA%A7/" title="jvm 高级">jvm 高级</a><time datetime="2024-01-14T16:00:00.000Z" title="Created 2024-01-15 00:00:00">2024-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By YuanJW</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>