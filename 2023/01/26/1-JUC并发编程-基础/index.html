<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC 并发编程 (一) 基础 | Hexo</title><meta name="keywords" content="juc"><meta name="author" content="YuanJW"><meta name="copyright" content="YuanJW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JUC 并发编程多线程的引入进程和线程定义 进程（process）是计算机中运行的程序一个实例。进程之间有相互独立的内存空间，每个进程有自己的地址空间、指令、数据、系统资源等。 线程（thread）是进程中的一个执行单元，一个进程中包括了多个线程，它们共享了相同的内存空间和系统资源。 现代操作系统将进程作为资源分配和保护的基本单位，将线程作为调度和执行基本单位。  内存和资源 各个进程之间拥有独立">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC 并发编程 (一) 基础">
<meta property="og:url" content="http://example.com/2023/01/26/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JUC 并发编程多线程的引入进程和线程定义 进程（process）是计算机中运行的程序一个实例。进程之间有相互独立的内存空间，每个进程有自己的地址空间、指令、数据、系统资源等。 线程（thread）是进程中的一个执行单元，一个进程中包括了多个线程，它们共享了相同的内存空间和系统资源。 现代操作系统将进程作为资源分配和保护的基本单位，将线程作为调度和执行基本单位。  内存和资源 各个进程之间拥有独立">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/default-cover/49.png">
<meta property="article:published_time" content="2023-01-25T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-12T02:31:33.351Z">
<meta property="article:author" content="YuanJW">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default-cover/49.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/26/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC 并发编程 (一) 基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-12 10:31:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default-cover/49.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC 并发编程 (一) 基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-01-25T16:00:00.000Z" title="Created 2023-01-26 00:00:00">2023-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-03-12T02:31:33.351Z" title="Updated 2024-03-12 10:31:33">2024-03-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC 并发编程 (一) 基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JUC-并发编程"><a href="#JUC-并发编程" class="headerlink" title="JUC 并发编程"></a>JUC 并发编程</h1><h2 id="多线程的引入"><a href="#多线程的引入" class="headerlink" title="多线程的引入"></a>多线程的引入</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>进程（process）是计算机中运行的程序一个实例。进程之间有相互独立的内存空间，每个进程有自己的地址空间、指令、数据、系统资源等。</p>
<p>线程（thread）是进程中的一个执行单元，一个进程中包括了多个线程，它们共享了相同的内存空间和系统资源。</p>
<p>现代操作系统将进程作为资源分配和保护的基本单位，将线程作为调度和执行基本单位。</p>
</blockquote>
<h4 id="内存和资源"><a href="#内存和资源" class="headerlink" title="内存和资源"></a>内存和资源</h4><blockquote>
<p>各个进程之间拥有独立的内存空间，同一进程内的线程共享相同的内存空间和资源。</p>
</blockquote>
<h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><blockquote>
<p>进程之间的通信需要使用特定的机制，用一台计算机的进程通信称为IPC(Inter-process communication)，不同计算机的之间通信需要通过网络并遵守相应的协议。</p>
<p>线程之间通信可以通过共享内存进行直接通信，也可以通过java提供的线程间通信机制（wait、notify等）实现通信</p>
</blockquote>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><blockquote>
<p>进程的上下文切换的开销要比线程的上下文切换的大很多，因此线程更加轻量。</p>
</blockquote>
<h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h4><blockquote>
<p>进程的创建和销毁开销相对较大，因为每个进程都要分配自己独立的内存空间和资源；</p>
<p>线程的创建和销毁开销相对较小，因为线程之间共享相同的内存空间和系统资源。</p>
</blockquote>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>早期单核CPU的运行环境下，线程感观是”同时执行”，但本质上是串行执行的，这是由于操作系统有一个组件叫任务调度器，任务调度器会轮流给每个任务分配执行时间，将cpu的时间片分给不同的线程使用使之交替执行，这些时间片的时间非常短，感观是”同时执行”，本质上是分时执行，简而言之就是：微观串行，宏观并行。</p>
<blockquote>
<p>并发 - concurrency：同一时间间隔内交替执行多个任务，这些任务并不是同时进行的，而是在同一个处理多元单元通过快速的切换来实现。</p>
</blockquote>
<img src="https://s2.loli.net/2024/01/10/cwgmj5oX7SfaU3V.png" alt="image-20240110140123570" style="zoom:33%;" />

<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><blockquote>
<p>并行 - parallelism：在同一时刻发生多个任务或操作，在多个处理单元上同时执行。</p>
</blockquote>
<img src="https://s2.loli.net/2024/01/10/XKwIm4x6TQhVysa.png" alt="image-20240110140156661" style="zoom:33%;" />

<p>引用rob pike的一段描述：</p>
<ul>
<li>并发是同一时间应对多件事情，而并行同一时间做多件事情</li>
</ul>
<h3 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h3><blockquote>
<p>同步 - asychronous：任务按照顺序依次执行，一个任务的执行需要等待上一个任务的完成</p>
<p>异步 - synchronous：任务不按照顺序依次执行，任务的完成并不影响接下来的任务立即执行</p>
</blockquote>
<h3 id="为什么引入多线程"><a href="#为什么引入多线程" class="headerlink" title="为什么引入多线程"></a>为什么引入多线程</h3><p>在多核处理器流行的当下，多线程可以有效的提升程序的运行效率，多核cpu并行执行多个线程，充分地利用硬件资源。</p>
<p>注意在单核cpu的机器上，多线程不能实际提高程序的运行效率，反而可能会影响执行效率，因为线程的上下文切换会带来一些性能的损耗。但是单核cpu的多线程，让单核机器有了宏观上应对多个任务的能力。</p>
<h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><blockquote>
<p>创建Thread对象，重写 run() 方法，然后通过Thread调用 start() 方法来启动线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象 - 匿名内部类 实质上的创建的是线程的子类</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;myThread&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// 覆盖 run 方法，方法里是执行的任务</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程	- 线程放入就绪队列中等待任务调度器分配时间片执行，调度时会执行线程中的run方法</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>

<p>另一种非匿名内部类写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    myThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5><blockquote>
<p> 实现 runnable 接口需要实现其中的 run() 方法，然后通过Thread对象调用 start() 方法来启动线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable, <span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种非匿名内部类写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable, <span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">    myThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5><blockquote>
<p>与 Runnable 相比，Callable 可以有返回值，返回值使用 futureTask 进行封装</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    Callable&lt;String&gt; stringCallable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">// 构造 FutureTask 对象，传入 Callable 对象参数</span></span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(stringCallable);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">    myThread.start();</span><br><span class="line">  	<span class="comment">// 阻塞等待返回值</span></span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable和Thread源码分析"><a href="#Runnable和Thread源码分析" class="headerlink" title="Runnable和Thread源码分析"></a>Runnable和Thread源码分析</h4><p>Thread类实现了 Runnable 接口, 重写了 run() 方法，</p>
<p>实现Runnable接口方法：当调用构造函数创建 Thread 对象，传入参数 Runnable 对象，该 Runnable 对象会赋值到 Thread 对象 的 Runnable target 的属性中，当调用 Thread 对象 的 start() 方法时，会执行 target.run()</p>
<p>继承Thread类方法：当调用构造函数创建 Thread 对象，未传入参数 Runnable 对象，创建的 Thread 对象重写 run() 方法，当调用 Thread 对象 的 start() 方法时，会调用 Thread 对象重写的 run() 方法</p>
<p>可以简单把 Thread 理解为 线程对象，Runnable 为 任务对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Runnable</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Thread</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">private</span> Runnable target;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      	<span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议使用实现Runnable接口的方式创建线程：</p>
<ul>
<li>将线程对象和任务对象分开，使得任务对象可以更好的组合以及与一些线程池等高级API配合</li>
<li>任务对象可执行即可，而线程对象整个类的创建的开销比较大</li>
<li>java不支持多继承，但是支持多接口实现，因此使用实现Runnable接口的方式，可以更好的扩展</li>
</ul>
</blockquote>
<h3 id="jvm-线程原理"><a href="#jvm-线程原理" class="headerlink" title="jvm 线程原理"></a>jvm 线程原理</h3><blockquote>
<p>jvm 运行时数据区由 堆、方法区、虚拟机栈、本地方法栈和程序计数器组成，栈内存其实就是对应线程所持有的，每个线程启动后，都会为其分配一个对应的栈内存，栈内存是线程私有的，相互独立，互不干扰。每个栈由多个栈帧组成，每个栈帧对应了一次方法调用，每个线程同一时刻只有一个活动栈帧，对应着正在执行的方法。</p>
</blockquote>
<img src="https://s2.loli.net/2024/01/10/ZufGw6vNgiLtCme.png" alt="image-20240110165743707" style="zoom: 50%;" />

<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><blockquote>
<p>线程的上下文切换是指CPU从一个线程切换到另一个线程执行的过程，具体而言就是指多线程环境中，操作系统将当前运行的线程上下文保存起来，然后切换到另一个线程的上下文并开始执行。在 jvm 中由程序计数器来记录当前线程下一条字节码指令的地址。</p>
</blockquote>
<ul>
<li>该线程的cpu时间片用完</li>
<li>线程优先级调度：线程优先级的提高可能导致线程上下文切换。</li>
<li>等待阻塞：当一个线程因为等待某个事件（如I/O操作、锁、信号量等）而被阻塞</li>
</ul>
<blockquote>
<p>注意：频繁的线程上下文切换会带来性能上的开销</p>
</blockquote>
<h3 id="线程常见的方法"><a href="#线程常见的方法" class="headerlink" title="线程常见的方法"></a>线程常见的方法</h3><h4 id="start和run方法"><a href="#start和run方法" class="headerlink" title="start和run方法"></a>start和run方法</h4><ul>
<li>start()</li>
</ul>
<blockquote>
<p>start 方法用于启动一个新的线程，并在新的线程中调用 run 方法。</p>
<p>start 方法会创建一个新的线程并使之进入就绪状态，等待操作系统分配CPU时间片这个线程执行 run 方法。</p>
<p>注意：如果对同一个线程对象多次调用 start 方法，会导致 IllegalThreadStateException 异常。</p>
</blockquote>
<ul>
<li>run()</li>
</ul>
<blockquote>
<p>run 方法是 Thread 类中定义的一个普通方法，它包含了线程执行的代码。</p>
<p>当直接调用 run 方法时，它会在当前线程中执行，不会创建新的线程，即 run 方法被视为普通方法被调用，不会启动新的线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;current thread 1:&quot;</span> + currentThread());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t1.start();</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;current thread 2:&quot;</span> + currentThread());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t2.run();</span><br><span class="line">  &#125;</span><br><span class="line">  执行结果：</span><br><span class="line">  current thread <span class="number">1</span>:Thread[t1,<span class="number">5</span>,main]</span><br><span class="line">current thread <span class="number">2</span>:Thread[main,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure>

<h4 id="sleep和yield方法"><a href="#sleep和yield方法" class="headerlink" title="sleep和yield方法"></a>sleep和yield方法</h4><ul>
<li>sleep</li>
</ul>
<blockquote>
<p>sleep方法是Thread类的静态方法，调用Thread类的sleep方法会让当前线程休眠一段时间，此时线程的状态从 运行状态 切换到 TIMEWAITING-限期等待，线程释放占用的CPU资源并在该时间内不再竞争CPU执行权，让其他线程有机会执行。当休眠时间结束后，线程会重新进入就绪状态，等待分配CPU时间片即不会立即执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  			<span class="comment">// 参数为long millis， 表示休眠时间的毫秒数</span></span><br><span class="line">         Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当一个线程处于睡眠状态（即在 sleep 方法中）时，如果另一个线程调用了被睡眠线程的 interrupt 方法，被睡眠线程会被唤醒，并且会抛出 InterruptedException，该线程会提前结束并进入抛出异常的状态。</p>
<p>建议：用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用：使用while(true)方法连续执行任务时，引入适当的休眠或等待机制，可以防止cpu占用过度。因为该循环会一直执行，不会主动放弃时间片，这种情况被称为”忙等”(Busy Waiting)。注意：具体的休眠时间需要根据应用程序的需求来调整。太短的休眠时间可能导致频繁切换，而太长的休眠时间可能导致响应时间延迟。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行一些任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待一段时间，避免过度占用CPU</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>yield</li>
</ul>
<blockquote>
<p>yield 方法是 Thread 类的实例方法，用于提示调度器当前线程愿意放弃当前对CPU的使用，让其他线程有机会执行。它会让线程从 运行状态 进入 RUNNABLE 就绪状态（不是进入阻塞状态），等待重新分配CPU时间片。</p>
<p>注意：yield 方法并不保证当前线程会让步，只是向调度器发出一个提示，，其他线程是否能获得执行机会取决于底层操作系统的调度策略。</p>
<p>yield 通常用于在多个线程执行相同优先级任务，协调线程执行顺序，提高程序的执行效率。</p>
</blockquote>
<h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><blockquote>
<p>join 方法时是 Thread 类提供的一个方法，用于当前线程等待调用该方法的线程执行完毕。</p>
<p>调用目标线程的join()方法，会让当前线程阻塞（放弃占用cpu时间片），直到目标线程结束。</p>
<p>它是一种线程同步机制，用于协调多个线程的执行顺序。</p>
<p>当调用 join(long millis) 方法表示等待目标线程执行结束，但最多等待millis毫秒</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(<span class="string">&quot;t1 finish&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line">    	<span class="comment">// 当前线程main阻塞等待t1执行结束</span></span><br><span class="line">      t1.join();</span><br><span class="line">      System.out.println(<span class="string">&quot;main stop&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"># 输出结果：</span><br><span class="line">    t1 start</span><br><span class="line">    t1 finish</span><br><span class="line">    main stop</span><br></pre></td></tr></table></figure>

<h4 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h4><blockquote>
<p>thread.interrupt()方法用于中断一个线程的执行。调用目标线程的 interrupt方法 不会立即中断线程，而是设置线程的中断状态，线程自己检查中断标志并采取相应的行为。</p>
<p>使用 Thread.interrupted() 静态方法来检查当前线程的中断状态并清理中断状态。这个方法会返回当前中断状态，并在调用后将中断状态重新设置为 false。thread.isInterrupted 也可以检查当前线程的中断状态但是不会对中断状态进行清除。</p>
</blockquote>
<ul>
<li><p>打断RUNNABLE的线程</p>
<p>调用线程的 <code>interrupt()</code> 方法时，将线程的中断状态设置为 <code>true</code></p>
<p>应用：实现通知线程停止执行，线程可以在适当检查中断状态，如果发现被中断，可以选择优雅的退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 is running&quot;</span>);</span><br><span class="line">          <span class="comment">// 目标线程自己检查中断标记，自己优雅的退出</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">              <span class="comment">// 优雅的退出：执行退出前的工作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;t1 is break&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    t1.start();</span><br><span class="line">  <span class="comment">// 运行一秒 打断标记</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>打断休眠或者阻塞的线程</p>
<p>如果线程被某些阻塞操作（如 <code>Object</code> 类的 <code>wait()</code>、<code>Thread.sleep()</code>、<code>join()</code> 方法等）所阻塞，调用 <code>interrupt()</code> 方法可以使线程抛出 <code>InterruptedException</code>，从而提前结束阻塞状态。</p>
<p>注意这些情况的 <code>isInterrupted()</code> 会返回 <code>false</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      Thread.sleep(<span class="number">1</span>);</span><br><span class="line">      t1.interrupt();</span><br><span class="line">      System.out.println(<span class="string">&quot;打断标记：&quot;</span> + t1.isInterrupted());</span><br><span class="line">  &#125;</span><br><span class="line"># 输出</span><br><span class="line">       Exception in thread <span class="string">&quot;t1&quot;</span> java.lang.RuntimeException: java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at com.example.demo.concurrency.BlockingInterruptDemo.lambda$main$<span class="number">0</span>(BlockingInterruptDemo.java:<span class="number">16</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br><span class="line">  Caused by: java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at com.example.demo.concurrency.BlockingInterruptDemo.lambda$main$<span class="number">0</span>(BlockingInterruptDemo.java:<span class="number">14</span>)</span><br><span class="line">    ... <span class="number">1</span> more</span><br><span class="line">  打断标记：<span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li><p>打断LockSupport.park的线程</p>
<p>LockSupport.park 是 阻塞线程的一种方式，用于实现线程之间的协作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">           LockSupport.park();</span><br><span class="line"> 					System.out.println(<span class="string">&quot;unpark..thread isInterrupted - &quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">       t1.start();</span><br><span class="line">       TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">       t1.interrupt();</span><br><span class="line">   &#125;</span><br><span class="line">输出结果：</span><br><span class="line"> park...</span><br><span class="line">unpark..thread isInterrupted - <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在上述的例子中，子线程启动执行 LockSupport.park(), 主线程等待一段时间后调用 thread.interrupt() 打断子线程，此时线程的停止中断，此时的线程打断标记为 true</p>
<p>注意：如果打断标记为 true, 此时线程如果在执行 LockSupport.park() 是无法阻塞的</p>
</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><blockquote>
<p>线程的优先级是一个用于指定线程调度顺序的概念。java 中线程优先级是通过整数表示的，范围从<code>Thread.MIN_PRIORITY</code>（1）到<code>Thread.MAX_PRIORITY</code>（10），其中<code>Thread.NORM_PRIORITY</code>（5）是默认的优先级。</p>
<p>线程的优先级越高，任务调度器在选择下一个要执行的线程时，更有可能选择优先级较高的线程。注意：线程优先级并不是硬性规定，而是一个调度提示，在某些情况下影响线程的执行顺序，但不应该过度依赖它来实现程序的正确性。</p>
</blockquote>
<h3 id="主线程和守护线程"><a href="#主线程和守护线程" class="headerlink" title="主线程和守护线程"></a>主线程和守护线程</h3><blockquote>
<p>主线程（main thread）和 守护线程（daemon thread） 是 java 中线程的两种不同的类型。</p>
<p>默认情况下，整个 java 进程需要等待所有的线程运行结束才会结束。</p>
<p>而守护线程是一种在程序运行时在后台提供服务的线程，他的不影响程序的执行，也不阻止程序的终止。当所有的非守护线程结束时，进程会结束，守护线程也会被强制终止，即使它们还在执行任务。守护线程通常用于提供一些后台服务或周期性任务，如垃圾回收。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">      <span class="comment">// 将 t1 线程设置为 守护线程</span></span><br><span class="line">      t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;主线程执行结束！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"># 输出结构</span><br><span class="line">   	开始运行...</span><br><span class="line">	主线程执行结束！</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h4 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h4><img src="https://s2.loli.net/2024/01/13/AXTdEzWKMgOhnLY.png" alt="image-20240112162416523" style="zoom:33%;" />

<ul>
<li><p>初始 状态：仅仅在语言层面上创建了对象</p>
</li>
<li><p>可运行 状态：线程已经创建完毕，等待cpu调度执行</p>
</li>
<li><p>运行 状态：线程占用cpu资源，正在执行其指令</p>
<p>可运行状态和运行状态可以相互转换，这是由由操作系统的任务调度器（Scheduler）决定，当任务调度器给线程获取cpu时间片，线程切换为运行状态执行并消耗cpu时间片的时间，当分配的cpu时间片用完了，则线程切换为可运行状态</p>
</li>
<li><p>阻塞 状态：线程进入阻塞状态表示该线程暂时无法执行。这可能是因为线程在等待某个资源（如锁）的释放，或者在等待某个条件的满足。在阻塞状态下，线程不会占用 CPU 时间片，任务调度器不会考虑调度该线程。当阻塞状态结束后，线程会进入可运行状态</p>
</li>
<li><p>终止状态：线程的指令执行完毕，线程的整个生命周期结束</p>
</li>
</ul>
<h4 id="JDK-层面"><a href="#JDK-层面" class="headerlink" title="JDK 层面"></a>JDK 层面</h4><img src="https://s2.loli.net/2024/01/18/3jy8UpSDIhF52qB.png" alt="image-20240112162226284" style="zoom:33%;" />

<blockquote>
<p>java 将线程的状态划分为 6 种</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/01/13/BUnl2KqOcZoT8rI.png" alt="image" style="zoom: 67%;" />

<ul>
<li><p>新建 - NEW：线程创建后尚未启动 即 线程创建，但是还没有调用 start 方法</p>
</li>
<li><p>可运行状态 - RUNNABLE：可能是操作系统层面的运行状态，也可能是可运行状态，也可能是IO阻塞等导致的阻塞状态</p>
</li>
<li><p>阻塞状态 - BLOCKING：线程等待获取一个排它锁，如果其线程释放了锁就会结束此状态</p>
</li>
<li><p>无限期等待 - WAITING：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片</p>
<table>
<thead>
<tr>
<th>无限期等待进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置时间的 Object.wait()</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join()</td>
<td>目标线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park()</td>
<td>其他线程调用 LockSupport.unpark(目标thread) 或者 调用 目标thread.interrupt()</td>
</tr>
</tbody></table>
</li>
<li><p>限期等待 - TIME WAITING：无需等待其它线程显式地唤醒，在一定时间之后会被自动唤醒</p>
<table>
<thead>
<tr>
<th>限期等待进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep()</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置时间的 Object.wait()</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置超时时间 Timeout 参数的 Thread.join()</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos(long nanos) / LockSupport.parkUntil(long deadline)</td>
<td>其他线程调用 LockSupport.unpark(目标thread) 或者 调用目标thread.interrupt()</td>
</tr>
</tbody></table>
</li>
<li><p>死亡 - TERMINATED：线程结束任务之后自己结束，或者产生异常而结束</p>
</li>
</ul>
<h3 id="查看进程和线程的方式"><a href="#查看进程和线程的方式" class="headerlink" title="查看进程和线程的方式"></a>查看进程和线程的方式</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><blockquote>
<p>ps -ef # 查看所有进程</p>
<p>ps -ef | grep java  或者 jps -l  # 查看java进程     </p>
<p>top # 显示进程动态列表</p>
<p>kill <pid> # 查看进程</p>
</blockquote>
<h4 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h4><blockquote>
<p>ps -fT -p <PID> # 查看某个进程的所有线程</p>
<p>top -H -p <PID> #  进程中的动态线程列表</p>
<p>jstack <PID> # 进程中的线程快照详细信息</p>
</blockquote>
<p>java 图形化线程监控工具 - jconsole</p>
<p>在控制台输入 jconsole 命令</p>
<img src="https://s2.loli.net/2024/01/10/CyRzEMfg8dQ7rxn.png" alt="image-20240110161406048" style="zoom:33%;" />

<p>在jconsole进行远程监控时，需要jar包启动时，添加部分配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=&#123;host_ip&#125; \</span><br><span class="line">-Dcom.sun.management.jmxremote \ # 启用JMX远程访问</span><br><span class="line">-Dcom.sun.management.jmxremote.port=&#123;port_number&#125; \ # 指定了JMX远程连接的端口（与接口访问接口不同）</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false \ # 禁用SSL和身份验证</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false \  </span><br><span class="line">-jar xxx.jar</span><br></pre></td></tr></table></figure>

<h3 id="线程应用"><a href="#线程应用" class="headerlink" title="线程应用"></a>线程应用</h3><ul>
<li>异步调用</li>
<li>并行计算</li>
<li>同步等待</li>
<li>协同规划</li>
</ul>
<h2 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h2><h3 id="共享模型"><a href="#共享模型" class="headerlink" title="共享模型"></a>共享模型</h3><h4 id="共享问题"><a href="#共享问题" class="headerlink" title="共享问题"></a>共享问题</h4><p>简单示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出结果</span><br><span class="line">  <span class="number">1616</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，对于代码中，使用了多线程对于一个静态变量（共享变量）分别执行了5000次自增和5000次自减操作，但是最后的结果并不是0，这是由多线程的共享问题导致的线程不安全问题。</p>
<p>从字节码的角度分析 静态变量的 cnt++ 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> getstatic # 获取静态变量cnt的值</span><br><span class="line"><span class="number">3</span> iconst_1  # 将整数常量值 <span class="number">1</span> 推送到堆栈上                                        </span><br><span class="line"><span class="number">4</span> iadd			# 将堆栈上的两个值相加</span><br><span class="line"><span class="number">5</span> putstatic # 将相加的结果存回静态变量 cnt</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>由于 java 的 cpu 的分时复用技术，上述指令出现了 交错执行 的情况</p>
<p><img src="https://s2.loli.net/2024/01/13/dxGRFDIMz3XUbJi.png" alt="image-20240113123606339"></p>
<p>程序使用多线程执行本身没有问题，但是问题出现在对于共享资源的多线程的读写操作上，这块代码被称做 <strong>临界区</strong></p>
<p>当多个线程试图同时访问和修改共享数据，最终结果依赖于线程执行的具体顺序，这种情况被称之为 <strong>竞态条件</strong></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>为了避免在临界区发生竞态条件，java 提供了很多方案</p>
<ul>
<li>阻塞式：synchronized lock</li>
<li>非阻塞式：atomic原子类</li>
</ul>
<h4 id="变量线程安全分析"><a href="#变量线程安全分析" class="headerlink" title="变量线程安全分析"></a>变量线程安全分析</h4><p>成员变量和静态变量如果没有共享，则线程安全；如果处于共享状态（不同的线程都可以访问和操作），但只有读取操作，线程也是安全的，当有读写操作时，则需要考线程安全问题。</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><blockquote>
<p>synchronzed （对象锁）是 java 中用于实现同步的关键字。它提供了一种机制，确保在多个线程访问共享资源时，只有一个线程能够进入关键代码段（临界区），从而避免竞态条件和数据不一致性的问题。</p>
<p>它采用 互斥 的方式让同一时刻只有一个线程可以持有对象锁，其他线程会被阻塞，因此可以保证获取对象锁的线程安全的执行临界区的代码，在此期间不会发生线程的上下文切换。</p>
<p>当锁被释放后，等待该锁的线程会被唤醒，被唤醒的线程会从阻塞状态进入就绪状态，等待操作系统的调度器重新分配 CPU 时间片，从而执行。</p>
</blockquote>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ul>
<li>线程A获得对象锁并进入临界区执行</li>
<li>线程B尝试访问相同的对象锁，线程B被阻塞，从可运行状态进入阻塞状态</li>
<li>线程A释放锁时，线程B会被唤醒，并进入就绪状态</li>
<li>任务调度器将CPU时间分配给线程B，线程B开始执行临界区</li>
</ul>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用在 代码块 上</span></span><br><span class="line"><span class="keyword">synchronized</span> (对象) &#123; <span class="comment">// 该对象可以是任何对象（可以是 类的 Class 对象），用于作为锁</span></span><br><span class="line">  临界区</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用在 方法 上 相当于 synchronized(this) &#123;&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; <span class="comment">// 整个方法体都会受到同步保护，对于非静态方法，锁是 当前对象实例</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用在 静态方法 上相当于 synchronized(xx.Class) &#123;&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123; <span class="comment">// 对于静态方法，锁是当前类的 Class 对象。</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><blockquote>
<p>synchronized 实际上是使用 <strong>对象锁</strong> 保证了临界区代码的<strong>原子性</strong>。因此，需要保护共享资源，必须对于<strong>同一个对象加锁</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                counter.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(counter.getCnt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于 两个线程 执行是并行还是互斥，关键是看 synchronized 锁的是不是同一个对象。</p>
<p>synchronized 关键字的互斥性质是由同步锁的对象来决定的。不同的锁对象可能导致并行执行，相同的锁对象则会引起互斥执行。</p>
</blockquote>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>因为 synchronized被称为 对象锁，所以需要理解 synchronized 的底层，首先要了解 java 对象</p>
<blockquote>
<p>java 对象在内存中的结构由三个部分组成：对象头（object header）、实例数据（instance data）和填充（Padding）。</p>
<ul>
<li>对象头：包含一些用于管理对象的元信息，如标记字、类型指针等</li>
<li>实例数据：数据的实际数据，包括字段和方法等</li>
<li>填充：为满足特定的内存对齐要求，可能在实例数据之后添加一些填充字节 </li>
</ul>
</blockquote>
<h6 id="对象头-object-header"><a href="#对象头-object-header" class="headerlink" title="对象头 - object header"></a>对象头 - object header</h6><p>对象头位于 每个对象的开头部分，它包含了用于管理对象的元信息。它包括了标记字、类型指针以及数组长度（如果对象是数组类型则有）。</p>
<ul>
<li>标记字：一般占用32个位即4字节</li>
<li>类型指针：指向对象所属的元数据，用于确定对象的类型</li>
</ul>
<img src="https://s2.loli.net/2024/01/13/fDPtmcbGRNKJdWv.png" alt="image-20240113214427176" style="zoom: 50%;" />

<h6 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h6><p>其中，每个对象都有一个与之关联的监视器 - Monitor，它是多线程实现同步的机制的关键，负责管理对象的同步操作，监视器和对象是一对一的关系。当有对象被synchronized锁住，该对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针。</p>
<p>monitor的结构：</p>
<ul>
<li><p>锁持有者 - owner：持有锁的线程</p>
</li>
<li><p>等待锁 - waitset：调用对象 wait 方法进入的对象等待集</p>
</li>
<li><p>通知队列 - entrylist：存放因为等待锁释放而被阻塞的线程的队列</p>
<img src="https://s2.loli.net/2024/01/14/QblBCeJip4cEGHx.png" alt="image-20240114130236719" style="zoom: 50%;" /></li>
</ul>
<p>monitor底层原理</p>
<p>当线程1成功获取到锁，此时锁住的对象的对象头的mark word前30位用于存储monitor的指针 - ptr_to_heavyweight_monitor，monitor 的 owner 指向线程1，线程1成为锁的拥有者（owner），并且对象头的加锁状态从01变为10（即正常状态到加锁状态），；在线程1执行临界区指令的过程中，此时线程2尝试获取锁，由于对象头中的状态为加锁状态并且关联的monitor的owner指向线程1，此时 线程2加入到 entrylist 等待队列 中，并且状态2的状态变为 阻塞状态 - BLOCKED；当线程1执行完临界区的指令后，此时 owner 置为空，并且由线程1调用 Object.notifyAll() 唤醒等待队列中的线程，这些线程在竞争（非公平的）尝试获取锁，执行临界区的指令</p>
<p><img src="https://s2.loli.net/2024/01/14/6Y7B39aqldHg5oJ.png" alt="image-20240114140247979"></p>
<p>分析字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> getstatic #<span class="number">2</span> # 从索引为<span class="number">2</span>的静态字段获取值并推送到操作数栈中 （这里索引为<span class="number">2</span>的静态变量的值即是obj锁对象的引用）</span><br><span class="line"> <span class="number">3</span> dup          # 复制栈顶的obj锁对象的引用并放入到栈顶</span><br><span class="line"> <span class="number">4</span> astore_1     # 将栈顶的obj锁对象的引用弹出存储到局部变量表位置<span class="number">1</span> 用于后续的解锁和确保异常处理可以正确的释放锁</span><br><span class="line"> <span class="number">5</span> monitorenter # 进入对象的监视器，即获取锁。获取锁成功则 对象头的mark word存储指向monito的指针来与一个monitor对象关联</span><br><span class="line"> <span class="number">6</span> getstatic #<span class="number">3</span> # 从索引为<span class="number">3</span>的静态字段获取值 cnt 并推送到</span><br><span class="line"> <span class="number">9</span> iconst_1     # 将整数<span class="number">1</span>推送到栈顶</span><br><span class="line"><span class="number">10</span> iadd         # 执行整数相加操作</span><br><span class="line"><span class="number">11</span> putstatic #<span class="number">3</span> # 将自增的结构存入到索引为<span class="number">3</span>的静态字段cnt中</span><br><span class="line"><span class="number">14</span> aload_1      # 加载局部变量表位置<span class="number">1</span>的即之前复制的object对象</span><br><span class="line"><span class="number">15</span> monitorexit  # 退出对象的监视器，即释放锁</span><br><span class="line"><span class="number">16</span> goto <span class="number">24</span> (+<span class="number">8</span>) # 正常执行完毕 跳转到字节码指令索引为<span class="number">24</span>的位置</span><br><span class="line"><span class="number">19</span> astore_2     # 将栈顶的引用类型值存储到局部变量表位置<span class="number">2</span>，此时栈顶的引用为异常的引用</span><br><span class="line"><span class="number">20</span> aload_1      # 将局部变量表中索引为<span class="number">1</span>的obj锁对象引用加载到栈顶</span><br><span class="line"><span class="number">21</span> monitorexit  # 退出对象的监视器，即释放锁</span><br><span class="line"><span class="number">22</span> aload_2      # 将在局部变量表中的位置<span class="number">2</span>的信息即异常信息引用</span><br><span class="line"><span class="number">23</span> athrow       # 抛出异常</span><br><span class="line"><span class="number">24</span> <span class="keyword">return</span>       # 从当前方法返回</span><br></pre></td></tr></table></figure>

<p>从上述代码，可以看出，即使执行同步代码块时，发生了异常，锁也在抛出异常前，进行释放。</p>
<p>复制锁对象的引用存放到 局部变量表的位置1 的目的是 确保锁对象的引用在同步块内的后续操作中仍然位于固定位置，以便于后续的存储和使用</p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><blockquote>
<p>jvm 底层对于 synchronized 进行了优化，在不同竞争程度下，采用了不同的锁的类型来优化性能开销，其中包括了 偏向锁、轻量级锁、重量级锁。这样做的目的在于提高获取锁和释放锁的效率以提高多线程并发操作的性能。</p>
<p>这四种状态是随着竞争情况而升级（即锁的膨胀）的，锁可以升级但是不可以降级（即锁的膨胀是不可逆的），锁的膨胀方向：偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁。</p>
<p>这种优化策略依赖于具体应用场景和线程行为，jvm在运行时会根据运行情况动态的自动选择合适的锁类型，因此无需开发者显式低关心锁的细节，jvm 会在背后自动的进行优化，使用最适合的锁策略。</p>
</blockquote>
<h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><ul>
<li><p>适用场景：多线程<strong>交替</strong>访问同步代码块（这里的交替指的是”访问的时间是错开的”，没有产生竞争）</p>
</li>
<li><p>流程：</p>
<ul>
<li><p>当线程尝试获取锁时，首先会在线程的栈帧中，创建一个<strong>锁记录</strong>的对象（锁记录在JVM层面），锁记录对象包含两部分，一部分用来存储 将要锁住对象的对象指针的空间，另一部分存储 锁记录地址以及轻量级锁标识00</p>
<img src="https://s2.loli.net/2024/01/18/HYULh3WCzgOkvVT.png" alt="image-20240116143157172" style="zoom:50%;" />

<p><img src="https://s2.loli.net/2024/01/16/bZ7X6cv2AdmzLNi.png" alt="image-20240116095137152"></p>
</li>
<li><p>当线程尝试获取锁时，会尝试通过<strong>CAS</strong>操作将对象的对象头的Mark Word和锁记录中的地址和轻量级锁标识进行互换</p>
<ul>
<li><p>如果CAS操作成功，则线程栈帧中的锁记录中的对象指针指向锁对象，标识线程获取锁成功</p>
<p><img src="https://s2.loli.net/2024/01/16/wM956Lcb8jZNTSn.png" alt="image-20240116090743477"></p>
</li>
<li><p>如果CAS操作失败，会有两种情况</p>
<ul>
<li><p>如果锁对象的对象头中Mark Word中的锁标识为00，但锁记录指针指向当前线程的其他锁记录，则发生了锁重入的情况，则只在线程的栈帧加上一个锁记录用于锁重入的计数，锁记录取值为 Null</p>
<p><img src="https://s2.loli.net/2024/01/16/7KVluGgXtfIsnJe.png" alt="image-20240116093852460"></p>
</li>
<li><p>如果锁对象的对象头中Mark Word中的锁标识为01，并且锁记录指针指向其他线程的锁记录，代表其他线程持有了这把对象锁，此时发生同一时刻有多个线程竞争同一个对象锁的情况发生了锁竞争，轻量级锁会升级成重量级锁，进入重量级的流程</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>执行完同步代码块的内容后，开始释放锁时，</p>
<ul>
<li><p>当栈帧弹出锁记录为Null时，则代表这是重入锁的锁记录，则直接弹出，此时重入次数也会减一；</p>
</li>
<li><p>当锁记录不为Null时，则通过CAS操作将对象的对象头的Mark Word和锁记录中存储之前的无锁状态的对象头信息（hashcode gc age 偏向锁标识 锁状态）进行互换即将原先对象头Mark Word进行恢复。</p>
<ul>
<li>CAS恢复成功，则解锁成功</li>
<li>CAS恢复失败，则说明轻量级锁已经发生锁膨胀升级为了重量级锁，此时将进入重量级锁解锁的流程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h6><blockquote>
<p>锁膨胀：在上述情况下，在线程尝试获取轻量级锁的过程中，CAS替换对象锁时，因为当前对象状态为01并且锁记录指针指向其他线程的锁记录时，此时表示 轻量级锁发生了竞争，这时候就需要锁膨胀，将轻量级锁升级为重量级锁。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/16/pjyBisJ1O3z5cmI.png" alt="image-20240116100637988"></p>
<p>当有线程持有了轻量级锁，其他线程获取锁失败，进入锁膨胀流程：</p>
<ul>
<li><p>为锁对象申请Monitor监视器，让对象的对象头的Mark Word的锁状态变为10，指针指向Monitor监视器，Monitor监视器的owner指向当前持有轻量级锁的线程，其他线程进入Monitor的阻塞队列中，并且变为阻塞状态</p>
</li>
<li><p>当之前持有轻量级锁的线程执行完同步代码块后尝试释放锁，通过CAS将之前存储在线程栈帧锁记录中的对象的Mark Word交换恢复给对象，此时由于对象对象头中的Mark Word存储的是Monitor地址和10重量级锁标识，因此进入重量级锁的锁释放流程，根据对象头的Monitor的指针找到Monitor监视器，将Owner置为Null，并且使用之前的持有锁线程唤醒entrylist的阻塞线程</p>
<p><img src="https://s2.loli.net/2024/01/16/QPNRKVDLAfzCI42.png" alt="image-20240116103407802"></p>
</li>
</ul>
<h6 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h6><blockquote>
<p>自旋优化 - spin lock</p>
<p>在线程尝试获取锁，如果锁已经被其他线程占用，该线程不会立即阻塞，而是会循环自旋一段时间，防止线程阻塞而减少上下文切换的开销，这针对于短暂的锁占用和低竞争情况的一种优化策略。</p>
<p>注意：自旋会占用一定的CPU资源，节省了上下文切换的时间，这也是为什么它用于短暂的锁占用和低竞争情况的原因。此外，它会进行一定时间或次数的自旋（JDK1.6引入了自适应自旋锁Adaptive Spinning - 自旋的时间由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定），如果自旋超过了限定的时间或次数，则会进入阻塞状态，等待被唤醒。</p>
</blockquote>
<h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><ul>
<li><p>使用场景：同一个代码块由同一个线程多次执行的场景；执行的同步代码块大多数场景下是单线程访问同步块的场景，使用偏向锁可以减少CAS操作和monitor对象的开销</p>
</li>
<li><p>机制：当线程第一次进入获取对象锁时，线程获取锁成功，将该线程的ID直接存储在对象头中并将标记对象为启用偏向锁状态（即表示该对象归属于该线程），之后该线程重复获取锁，无需竞争，直接获取锁，后续锁释放，依旧会在对象头中保持这个线程ID</p>
<img src="https://s2.loli.net/2024/01/18/ADOPXFYURhN5C7j.png" alt="image-20240116142559410" style="zoom:50%;" />

<blockquote>
<p>对象默认开启了偏向锁即创建的对象最后3位为101(添加参数 -XX:-UseBiasedLocking 禁用偏向锁)，但是偏向锁是默认延迟的，对象创建后不是立即处于启用偏向状态，而是有一个默认的延迟时间，延迟时间后启用偏向状态即最后3位为101，这个延迟时间的目的是为了让应用程序在启动时有足够的时间执行一些初始化操作，避免在初始化阶段执行一些初始化操作。（可以添加 VM 参数：-XX:BiasedLockingStartupDelay=0来禁用延迟）</p>
</blockquote>
</li>
<li><p>偏向锁的撤销：撤销对于对象的偏向 将101状态修改为001</p>
<ul>
<li>调用对象的 hashcode 方法（对象头的hashcode占用对象头mark word的一部分空间）</li>
<li>当出现其他线程尝试获取偏向锁对象，会将偏向锁升级为轻量级锁</li>
<li>调用对象的 wait/notify 方法</li>
</ul>
</li>
<li><p>批量重偏向：当对象的偏向锁的撤销但并多个线程并没有没有出现竞争时，而其中一个线程获取锁的次数达到了阈值（默认20），虚拟机可能会重新偏向其中的一个线程。但是如果该类的实例对象偏向锁撤销的次数越来越多，达到阈值（默认40），会将整个类标记为不可偏向，新建的该类的实例对象也无法偏向。</p>
</li>
</ul>
<h6 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h6><blockquote>
<p>锁消除机制是jvm即时编译器的优化手段，用于消除代码中不必要的同步操作，从而减少加锁和释放锁带来的性能开销。编译器通过静态分析代码，判断对象锁在特定情况下不会发生竞争。</p>
<p>锁消除的常见情况</p>
<ul>
<li>逃逸分析：分析对象的引用是否会逃逸出当前方法的作用域，如果没有，则说明对象的生命周期仅限于当前方法的执行过程，不会被其他方法引用。即时编译器判断在方法内部，对象锁不会发生竞争，此时可以消除锁操作</li>
<li>线程局部存储：对象的作用域为所属线程，此时也不会发生线程锁的竞争，因此可以安全的消除锁操作</li>
</ul>
<p>jvm 默认开启锁消除机制</p>
</blockquote>
<h4 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h4><blockquote>
<p>wait 是 Object 类的实例方法用于 线程之间的协作：线程为了等待某个条件满足，阻塞等待，让出锁其他的线程获取 锁执行</p>
<p>该方法只能在同步代码块或同步方法中调用，否则会运行时抛出 IllegalMonitorStateException。</p>
<p>调用 wait() 方法使得线程挂起，等待某个条件满足，此时线程会被挂起，这个期间会释放对象锁，当其他线程的运行使得这个条件满足时，其他线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/01/16/P4dN3nqDEzj56fV.png" alt="image-20240116215737327"></p>
<p>当线程获取锁后进入同步代码块中后，调用wait方法，释放对象的锁，线程从RUNNABLE状态变为WAITING状态（不会占用CPU资源），并加入到monitor对象的WaitSet等待集合中，其他线程调用 notify() 或者 notifyAll() 来唤醒WaitSet中的线程，被唤醒的线程重新尝试获取锁。</p>
<h5 id="相关API方法"><a href="#相关API方法" class="headerlink" title="相关API方法"></a>相关API方法</h5><ul>
<li>obj.wait()：让当前持有对象锁的线程到monitor监视器的WaitSet中等待，无限期等待直到其他线程获取该对象锁并调用notify()或者notifyAll()唤醒它  </li>
<li>obj.wait(long timeout)：同样是线程进入到monitor的WaitSet中等待，只不过是限期等待，等待超过时间会自动唤醒</li>
<li>obj.notify()：在同步代码中唤醒对象monitor监视器的WaitSet中的一个线程</li>
<li>obj.notifyAll()：在同步代码中唤醒对象monitor监视器的WaitSet中的全部线程</li>
</ul>
<blockquote>
<p>notify和notifyAll方法必须在同步代码块中执行，是为了保证线程安全性、避免数据竞争和死锁，并确保线程间正确的通信</p>
</blockquote>
<p>这些方法主要用于线程之间的协作，都是所有Object对象方法，所有方法的调用只能在获取锁的前提下即在同步代码块或者同步方法中执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置final修饰变量 保证对象引用不可变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait(); <span class="comment">// t1 进入 WaitSet</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();  <span class="comment">// t2 进入 WaitSet</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// notify 唤醒WaitSet其中一个线程 notifyAll 唤醒WaitSet所有线程</span></span><br><span class="line">            obj.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">  t1 start</span><br><span class="line">  t2 start</span><br><span class="line">  t1 end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h5><ul>
<li>sleep 是 Thread 类的一个静态方法，wait 是 Object 类的方法</li>
<li>wait 必须在同步代码块中调用即调用的该方法的线程必须要持有这把对象锁，而 sleep 则不需要</li>
<li>sleep 休眠时无论是否持有锁都不会释放持有的锁，而 wait 会在等待时会释放对象锁</li>
<li>wait 没有设置休眠时间时，会进入无限期等待，直到其他线程获取锁后，调用notify()或者notifyAll()方法唤醒锁</li>
<li>sleep 方法用于 定时任务或者简单的时间控制，而 wait 方法用于线程之间的协作</li>
</ul>
<h5 id="正确实例"><a href="#正确实例" class="headerlink" title="正确实例"></a>正确实例</h5><p>在线程需要等待某个条件的场景下，可以使用wait方法来让线程阻塞，释放锁对象，让其他线程先执行，等待条件满足后，再由其他线程获取锁对象调用notifyAll 唤醒线程。</p>
<ul>
<li>这种方式，相比于 sleep 方法而言，效率更好，因为 sleep 在执行同步代码块时，不会释放锁对象。</li>
<li>使用 notifyAll 的原因是 notify方法只会从对象的monitor监视器的 WaitSet 中挑一个执行，当有个多个线程执行wait方法时即 WaitSet 中有多个对象时，notify 不一定会唤醒该线程， 而notifyAll 会唤醒 WaitSet中的所有集合。</li>
<li>线程被notifyAll唤醒后，此时的线程所需要等待的条件可能没有成立，此时，线程直接往下执行，不会执行某个条件成立的代码。因此需要使用 while 让没有成立条件的方法继续进入等待状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 使用 final 修饰的变量 不可变（引用关系）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立) &#123;</span><br><span class="line">      lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h5 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h5><blockquote>
<p>保护性暂停 - Guarded Suspension，用于 一个线程等待另一个线程的执行结果。</p>
<p>其核心是一个受保护的方法，该方法在执行其所需要真正执行的操作时需要满足特定的条件，当条件状态不满足时，执行受保护方法的线程挂起并进入等待状态，直到条件状态满足该线程才能继续执行。</p>
<p>应用场景：JDK中，join底层实现，Future类的底层实现。</p>
</blockquote>
<img src="https://s2.loli.net/2024/01/18/dzbG3pSchgHJPyW.png" alt="image-20240118140420491" style="zoom:50%;" />

<h6 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 条件不满足 阻塞 释放锁</span></span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置等待的超时时间</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">                System.out.println(passTime);</span><br><span class="line">                <span class="keyword">if</span> (passTime &gt; timeout) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 防止结果依旧为 null 但是被其他线程唤醒</span></span><br><span class="line">                    lock.wait(timeout - passTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          <span class="comment">// 其他线程获取条件</span></span><br><span class="line">            <span class="built_in">this</span>.result = response;</span><br><span class="line">          <span class="comment">// 唤醒</span></span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGuard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">GuardObject</span> <span class="variable">guardObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="comment">// 设置超时时间</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> guardObject.get(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;result:&quot;</span> + o);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;result complete...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            guardObject.complete(Integer.MAX_VALUE);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="join底层分析"><a href="#join底层分析" class="headerlink" title="join底层分析"></a>join底层分析</h6><blockquote>
<p>线程A调用线程B实例的join方法，线程A将等待线程B执行结束后，才会执行线程A下面的代码。</p>
<p>join的底层实现就用到了 保护性暂停 Guarded Suspension 模式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// millis 超时时间 0表示不会超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      	</span><br><span class="line">      <span class="comment">// 参数有效性检查</span></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 不会超时的等待</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">              <span class="comment">// 超时释放</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if this thread is alive. A thread is alive if it has</span></span><br><span class="line"><span class="comment">     * been started and has not yet died. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 代码执行完毕后，线程被销毁 返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h6 id="多任务代码实现"><a href="#多任务代码实现" class="headerlink" title="多任务代码实现"></a>多任务代码实现</h6><img src="https://s2.loli.net/2024/01/18/KanUrBxG2RtSesp.png" alt="image-20240118150227848" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"># GuardObj </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardObj</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardObj</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">            <span class="keyword">if</span> (passTime &gt; timeout) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait(timeout);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#  Tasks 统一管理多个任务</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tasks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Long, GuardObj&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardObj <span class="title function_">genGuardObj</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">GuardObj</span> <span class="variable">guardObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardObj</span>(id);</span><br><span class="line">        tasks.put(id, guardObj);</span><br><span class="line">        <span class="keyword">return</span> guardObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardObj <span class="title function_">removeGuardObj</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGuardObjs</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0l</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">GuardObj</span> <span class="variable">guardObj</span> <span class="operator">=</span> Tasks.genGuardObj(finalI);</span><br><span class="line">                System.out.println(<span class="string">&quot;任务&quot;</span> + finalI + <span class="string">&quot;开始接受任务&quot;</span>);</span><br><span class="line">                guardObj.get(<span class="number">5000</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0l</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">GuardObj</span> <span class="variable">guardObj</span> <span class="operator">=</span> Tasks.removeGuardObj(finalI);</span><br><span class="line">                System.out.println(<span class="string">&quot;向任务&quot;</span> + finalI + <span class="string">&quot;发送任务&quot;</span>);</span><br><span class="line">                guardObj.complete(finalI);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line"> 	任务<span class="number">0</span>开始接受任务</span><br><span class="line">  任务<span class="number">1</span>开始接受任务</span><br><span class="line">  任务<span class="number">2</span>开始接受任务</span><br><span class="line">  向任务<span class="number">0</span>发送任务</span><br><span class="line">  向任务<span class="number">1</span>发送任务</span><br><span class="line">  向任务<span class="number">2</span>发送任务</span><br></pre></td></tr></table></figure>

<h6 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h6><p>上述的模式，一个线程等待另一个线程的条件满足，才被唤醒执行，等待线程和唤醒线程是一对一的关系，在多个任务时，需要多对线程。而在生产者和消费者模型中，等待线程可以多次等待，唤醒线程可以多次唤醒，从而减少了线程资源的开销。生产者只负责生产数据，消费者只负责接收数据，数据以消费队列的方式存储，JDK的很多阻塞队列采用了这种模式。</p>
<img src="https://s2.loli.net/2024/01/18/Cxnc3ZPGhUmIRwY.png" alt="image-20240118190002480" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(Integer id, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(Integer capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 获取消息的等待条件为 队列不能空</span></span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息队列已空，等待生产者生产消息&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            System.out.println(<span class="string">&quot;comsume:&quot;</span> + message.toString());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 等待存入消息的条件为 队列没有满</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息队列满足，等待消费者消费消息&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            System.out.println(<span class="string">&quot;produce:&quot;</span> + message.toString());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMq</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">messageQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                messageQueue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, <span class="string">&quot;content&quot;</span> + id));</span><br><span class="line">            &#125;, <span class="string">&quot;produce&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                messageQueue.take();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Park和unPark方法"><a href="#Park和unPark方法" class="headerlink" title="Park和unPark方法"></a>Park和unPark方法</h4><p>Park和unPark方法是LockSupport类中的方法，它们以线程为单位阻塞和唤醒线程，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.park(); <span class="comment">// 用于暂停当前线程</span></span><br><span class="line">LockSupport.unpark(thread对象); <span class="comment">// 恢复某个线程的运行</span></span><br></pre></td></tr></table></figure>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 输出：</span><br><span class="line">  start...</span><br><span class="line">  park...</span><br><span class="line">  unpark...</span><br></pre></td></tr></table></figure>

<p>注意：unpark 方法可以在 park 之前调用，也可以在 park 之后调用，在之前调用也可以恢复线程。</p>
<h5 id="wait和park方法"><a href="#wait和park方法" class="headerlink" title="wait和park方法"></a>wait和park方法</h5><ul>
<li>wait、notify和 notifyAll 底层通过 对象的 monitor 监视器实现，而 unpark 实现更加的轻量级，unpark 让线程阻塞，但是不会让持有锁的线程释放锁</li>
<li>unpark 是 唤醒一个指定的线程，而 notify/notifyAll 则是唤醒 对象的 monitor 监视器中 waitSet 等待线程的随机一个 </li>
<li>park 之前可以先执行 unpark</li>
</ul>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>LockSupport中的 park 和 unpark 方法，底层原理依赖于操作系统的线程调度和管理机制。当一个线程调用 <code>park</code> 时，它会检查线程jvm底层的parker对象 是否有一个“许可”（permit）可用，如果有许可，<code>park</code> 立即返回，并消耗这个许可（即许可数变为0）；如果没有许可，线程将被阻塞，直到接收到一个许可或者线程被中断。当线程一个线程调用 <code>unpark</code> 唤醒它时，它会如果目标线程此时被 <code>park</code> 阻塞，它将被唤醒。如果目标线程此时没有被阻塞，它会持有这个许可，直到下次调用 <code>park</code> 时立即返回而不会阻塞。</p>
<h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><blockquote>
<p>在很多场景下，为了提高系统的并发度，会讲锁的粒度尽可能的细化，这样有可能造成死锁。死锁就是 两个线程或者多个线程互等待彼此持有的锁。</p>
</blockquote>
<h6 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h6><ul>
<li>jstack</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jps </span><br><span class="line">jstack &lt;PID&gt; &gt; thread.dump</span><br><span class="line">搜索关键字 deadlock</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 visualvm 或者 jconsole 工具</p>
<img src="https://s2.loli.net/2024/01/18/uEIMtCSW5QyoUcN.png" alt="image-20240118223540220" style="zoom:50%;" /></li>
</ul>
<h6 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h6><p>可以按照相同的顺序进行加锁，但是这种情况容易发生饥饿现象即有部分线程很难获取到锁，导致一直没有办法执行</p>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><blockquote>
<p>活锁是指两个或者多个线程相互改变彼此线程的结束条件，导致的状态变化彼此抵消，使得两个线程一直执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line"></span><br><span class="line">                System.out.println(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">                System.out.println(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，会一直执行下去，解决办法：可以使得两个线程执行时间交错，可以两个线程的休眠时间设置成不同的</p>
<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><blockquote>
<p>饥饿是指一个线程由于优先级太低，始终得不到CPU调度而始终无法结束的情况或者很难获取到锁对象，导致一直没有办法执行同步代码块</p>
</blockquote>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><blockquote>
<p>ReentrantLock 翻译是 可重入锁，相比于 synchronized 有如下的特点</p>
<ul>
<li>可以被中断</li>
<li>可以设置获取锁的超时时间</li>
<li>可以设置公平锁 - 先到先得，有效防止部分线程饥饿的情况</li>
<li>支持多个条件变量进行</li>
</ul>
<p>与 synchronized 一样，ReentrantLock 也是可重入的。</p>
</blockquote>
<h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><blockquote>
<p>可重入指的是同一个线程可以多次获取同一把锁</p>
</blockquote>
<h5 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h5><p>Synchronized 和 ReentrantLock的 Lock 都是不可打断的，即有线程持有了锁，其他线程将一直阻塞等待下去。</p>
<blockquote>
<p>可打断是指 锁已经被持有的情况下，线程等待锁的释放，等待锁的释放的过程可以被打断，防止线程一直等待获取锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">				<span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果锁没有被其他线程占用，竞争获取对象的锁</span></span><br><span class="line">                <span class="comment">// 如果锁被其他线程占用，则进入阻塞队列等待锁释放</span></span><br><span class="line">                System.out.println(<span class="string">&quot;t1 try lock&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 get lock&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 unlock&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;main lock&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1 interrupt&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">				# 输出</span><br><span class="line">          main lock</span><br><span class="line">          t1 <span class="keyword">try</span> lock</span><br><span class="line">          t1 interrupt</span><br><span class="line">          interrupted</span><br><span class="line">          java.lang.InterruptedException</span><br><span class="line">            at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">944</span>)</span><br><span class="line">            at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1263</span>)</span><br><span class="line">            at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">317</span>)</span><br><span class="line">            at com.example.demo.concurrency.ReentrantLockDemo.lambda$method2$<span class="number">0</span>(ReentrantLockDemo.java:<span class="number">38</span>)</span><br><span class="line">            at java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>)</span><br></pre></td></tr></table></figure>

<h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><blockquote>
<p>锁超时机制是指尝试获取锁的线程不会一直阻塞等待，而是在指定的时间内等待锁的释放。如果在指定的时间内未能获取到锁，则停止等待，返回 <code>false</code>。这种机制有效的防止了线程无限制的等待下去，防止了死锁。</p>
</blockquote>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;         </span><br><span class="line">			<span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;t1 try lock&quot;</span>);</span><br><span class="line">           <span class="type">boolean</span> tryLock;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               tryLock = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;获取锁超时&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1 get lock&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       lock.lock();</span><br><span class="line">       t1.start();</span><br><span class="line">&#125;</span><br><span class="line">       # 输出：</span><br><span class="line">         t1 <span class="keyword">try</span> lock</span><br><span class="line">				获取锁超时</span><br></pre></td></tr></table></figure>

<p>注意当直接调用 lock.trylock() 方法时即没有设置超时时间的情况下，线程直接尝试获取锁，不会等待，获取不到则直接返回 false ，获取锁失败。</p>
<h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><blockquote>
<p>公平锁的是指 线程会按照它们请求锁的顺序获得锁即先发出请求的线程会先获得锁，而后发出请求的线程按顺序排队等待锁。</p>
<p>Synchronized 和 ReentrantLock的无参数构造都是 非公平锁。 Synchronized 的 对象对应的 monitor 监视器的 EntryList（本质队列）维护了 等待获取锁的线程，当占有锁的线程释放锁时， 会调用 notifyAll（不是notify方法，防止死锁和饥饿） 方法唤醒所有阻塞队列的线程，让这些线程重新竞争获取锁。ReentrantLock 的无参数构造默认是 非公平锁。</p>
<p>ReentrantLock 的有参数构造设置 fair 参数为 true，此时是 公平锁 的实现。公平锁可以避免饥饿问题，防止线程无限制的等待。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock 实例对象的无参构造方法，默认创建非公平锁</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ReentrantLock 实例对象的有参构造方法， </span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是没有必要使用 ReentrantLock 实现避免饥饿问题（防止线程无限制的等待），因为 并发锁会降低并发度，造成性能降低，可以使用 lock.trylock 方法。</p>
<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><blockquote>
<p>条件变量是ReentrantLock提供的一种允许持有锁的线程在特定条件不满足时阻塞等待，在条件满足时被唤醒的特性。和Synchronized代码块中的wait/notify相比，ReentrantLock支持多个条件变量，提供了更细粒度的阻塞和唤醒机制。通过使用条件变量，你可以控制线程在特定条件下的等待和唤醒，从而有效地管理线程间的协作。</p>
<p>ReentrantLock的条件变量和Synchronized的wait/notify方法防止持有锁的线程在等待条件满足时占有锁，让其他线程无法执行，它们都有效的管理了线程之间的协作。</p>
</blockquote>
<p>ReentrantLock的条件变量通过 ReentrantLock实例对象的 newCondition 方法创建，该提供了该条件变量的await方法使得当前持有锁的线程等待并且释放锁（当前线程需要持有锁），直到另一个线程调用同一条件变量的single或者sinleAll方法唤醒等待条件中的一个线程或者全部线程重新竞争lock锁。</p>
<p>注意：使用变量时，调用 await 方法，线程应持有相关的锁。当调用 await方法后，线程会释放锁，进入等待状态。</p>
<p>使用场景：条件变量通常用于表示“某个条件是否满足”，用于实现复杂的线程间协调和通信。例如，在生产者-消费者问题中，消费者线程可能在“缓冲区为空”的条件上等待，而生产者线程在添加了新项到缓冲区后会通知该条件。</p>
<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 wait&quot;</span>);</span><br><span class="line">            condition1.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 doing&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 wait&quot;</span>);</span><br><span class="line">            condition1.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 doing&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition1.signalAll();</span><br><span class="line">        condition2.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">YuanJW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/26/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/">http://example.com/2023/01/26/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/juc/">juc</a></div><div class="post_share"><div class="social-share" data-image="/img/default-cover/49.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/26/jvm-4-%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="/img/default-cover/54.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">jvm 高级</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/26/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/"><img class="next-cover" src="/img/default-cover/4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">JUC 并发编程 (三) JUC并发工具</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/01/26/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/" title="JUC 并发编程 (二) JMM"><img class="cover" src="/img/default-cover/2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-26</div><div class="title">JUC 并发编程 (二) JMM</div></div></a></div><div><a href="/2023/02/01/rocketmq/" title="RocketMQ"><img class="cover" src="/img/default-cover/40.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">RocketMQ</div></div></a></div><div><a href="/2023/01/26/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/" title="JUC 并发编程 (三) JUC并发工具"><img class="cover" src="/img/default-cover/4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-26</div><div class="title">JUC 并发编程 (三) JUC并发工具</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YuanJW</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XiaoYuanJW" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2754742370@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">JUC 并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.1.</span> <span class="toc-text">多线程的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E8%B5%84%E6%BA%90"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">内存和资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%94%80"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">开销</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">并行和并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">并行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">异步和同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">为什么引入多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.1.3.</span> <span class="toc-text">实现Callable接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable%E5%92%8CThread%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Runnable和Thread源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm-%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">jvm 线程原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.2.3.</span> <span class="toc-text">线程上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程常见的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#start%E5%92%8Crun%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">start和run方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep%E5%92%8Cyield%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">sleep和yield方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">join方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">interrupt方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.5.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">主线程和守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.7.</span> <span class="toc-text">线程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">操作系统层面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-%E5%B1%82%E9%9D%A2"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">JDK 层面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.8.</span> <span class="toc-text">查看进程和线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">查看进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">查看线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.9.</span> <span class="toc-text">线程应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">并发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">共享模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">共享问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">变量线程安全分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.4.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.1.4.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.3.1.4.3.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.4.4.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4-object-header"><span class="toc-number">1.3.1.4.4.1.</span> <span class="toc-text">对象头 - object header</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Monitor"><span class="toc-number">1.3.1.4.4.2.</span> <span class="toc-text">Monitor</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.1.4.5.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.3.1.4.5.1.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">1.3.1.4.5.2.</span> <span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.1.4.5.3.</span> <span class="toc-text">自旋优化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.3.1.4.5.4.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">1.3.1.4.5.5.</span> <span class="toc-text">锁消除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">wait和notify方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3API%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.5.1.</span> <span class="toc-text">相关API方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.5.2.</span> <span class="toc-text">wait和sleep的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.1.5.3.</span> <span class="toc-text">正确实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C"><span class="toc-number">1.3.1.5.4.</span> <span class="toc-text">保护性暂停</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.5.4.1.</span> <span class="toc-text">简单代码实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#join%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.3.1.5.4.2.</span> <span class="toc-text">join底层分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.5.4.3.</span> <span class="toc-text">多任务代码实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.3.1.5.4.4.</span> <span class="toc-text">生产者和消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Park%E5%92%8CunPark%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">Park和unPark方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.6.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait%E5%92%8Cpark%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.6.2.</span> <span class="toc-text">wait和park方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.3.1.6.3.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">活跃性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.1.7.1.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.1.7.1.1.</span> <span class="toc-text">定位死锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">1.3.1.7.1.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">1.3.1.7.2.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">1.3.1.7.3.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.1.8.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">1.3.1.8.2.</span> <span class="toc-text">可重入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-number">1.3.1.8.3.</span> <span class="toc-text">可打断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-number">1.3.1.8.4.</span> <span class="toc-text">锁超时</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.8.4.1.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.3.1.8.5.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.1.8.6.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.1.8.6.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/05/jvm-2-%E5%AE%9E%E6%88%98/" title="jvm 实战"><img src="/img/default-cover/34.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jvm 实战"/></a><div class="content"><a class="title" href="/2024/01/05/jvm-2-%E5%AE%9E%E6%88%98/" title="jvm 实战">jvm 实战</a><time datetime="2024-01-04T16:00:00.000Z" title="Created 2024-01-05 00:00:00">2024-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/28/jvm-5-%E9%9D%A2%E8%AF%95/" title="No title"><img src="/img/default-cover/39.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2023/12/28/jvm-5-%E9%9D%A2%E8%AF%95/" title="No title">No title</a><time datetime="2023-12-28T07:53:16.603Z" title="Created 2023-12-28 15:53:16">2023-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/28/jvm-1-%E5%9F%BA%E7%A1%80/" title="jvm 基础"><img src="/img/default-cover/25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jvm 基础"/></a><div class="content"><a class="title" href="/2023/12/28/jvm-1-%E5%9F%BA%E7%A1%80/" title="jvm 基础">jvm 基础</a><time datetime="2023-12-27T16:00:00.000Z" title="Created 2023-12-28 00:00:00">2023-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/06/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/" title="JVM性能调优工具"><img src="/img/default-cover/37.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM性能调优工具"/></a><div class="content"><a class="title" href="/2023/09/06/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/" title="JVM性能调优工具">JVM性能调优工具</a><time datetime="2023-09-06T00:31:22.000Z" title="Created 2023-09-06 08:31:22">2023-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/24/MybatisX%20%E8%87%AA%E5%AE%9A%E4%B9%89%20FreeMarker%20%E6%A8%A1%E5%9D%97/" title="MybatisX 自定义 FreeMarker 模块"><img src="/img/default-cover/14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MybatisX 自定义 FreeMarker 模块"/></a><div class="content"><a class="title" href="/2023/06/24/MybatisX%20%E8%87%AA%E5%AE%9A%E4%B9%89%20FreeMarker%20%E6%A8%A1%E5%9D%97/" title="MybatisX 自定义 FreeMarker 模块">MybatisX 自定义 FreeMarker 模块</a><time datetime="2023-06-24T00:31:22.000Z" title="Created 2023-06-24 08:31:22">2023-06-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By YuanJW</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>