<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-26T12:37:54.011Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YuanJW</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jvm 实战</title>
    <link href="http://example.com/2024/01/05/jvm-2-%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2024/01/05/jvm-2-%E5%AE%9E%E6%88%98/</id>
    <published>2024-01-04T16:00:00.000Z</published>
    <updated>2024-01-26T12:37:54.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm-实战"><a href="#jvm-实战" class="headerlink" title="jvm 实战"></a>jvm 实战</h1><h2 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h2><h3 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h3><ul><li><p>内存泄漏（memory leak）</p><ul><li>定义：在程序在运行时，由于一些不再使用的对象无法被垃圾回收机制及时释放，导致已不再需要的内存仍然被占用，最终可能导致系统内存溢出。</li><li>内存泄漏大多数情况是由堆内存泄漏引起的。</li></ul></li><li><p>内存溢出（memory overflow）</p><ul><li>定义：程序在运行时请求的内存超过了JVM所能提供的最大内存限制，导致程序无法继续执行，通常会抛出OutOfMemoryError异常。</li><li>内存溢出并不只有内存泄漏这一种原因。</li></ul></li></ul><h4 id="解决内存溢出问题"><a href="#解决内存溢出问题" class="headerlink" title="解决内存溢出问题"></a>解决内存溢出问题</h4><ul><li><h5 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h5></li></ul><blockquote><p>使用监控工具对于jvm堆内存进行监控和告警</p></blockquote><ul><li><h5 id="诊断问题"><a href="#诊断问题" class="headerlink" title="诊断问题"></a>诊断问题</h5></li></ul><blockquote><p>通过分析工具诊断问题产生原因，定位到源代码</p></blockquote><ul><li><h5 id="修复问题"><a href="#修复问题" class="headerlink" title="修复问题"></a>修复问题</h5></li></ul><ul><li><h5 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h5></li></ul><h3 id="常用内存监控"><a href="#常用内存监控" class="headerlink" title="常用内存监控"></a>常用内存监控</h3><blockquote><p>使用监控工具对于jvm堆内存进行监控和告警</p></blockquote><h4 id="常用内存监控工具"><a href="#常用内存监控工具" class="headerlink" title="常用内存监控工具"></a>常用内存监控工具</h4><h5 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h5><p>top命令是一个在Linux系统上用于查看系统实时性能数据的命令行工具。它可以显示系统的实时运行状态，包括CPU、内存、进程等信息。</p><p>进入显示页面后，按 <code>m</code> 键，可以按照内存使用率进行排序。</p><p><img src="https://s2.loli.net/2024/01/05/YyB8O6wV9pFH2lK.png" alt="image-20240105094015543"></p><p>共享内存通常包括系统库和一些共享的数据，是多个进程共享的内存，因此进程的实际占用内存为 RES(常驻内存) -SHR(共享内存)</p><p>top 命令操作简单，但只能看到基础的进程信息，无法应用程序看到每个部分的内存占用情况（堆、方法区等）和 变化趋势图，无法准确定位问题。</p><h5 id="visualvm"><a href="#visualvm" class="headerlink" title="visualvm"></a>visualvm</h5><p><a href="https://visualvm.github.io/">visualvm</a> 是一个开源的 jvm 监控、管理和性能分析的可视化工具，可以进行故障排查和性能分析，支持插件扩展，功能强大。</p><p><img src="https://s2.loli.net/2024/01/05/clvZ2jqFXm3ux7N.png" alt="    "></p><p>visualvm 不仅可以监控分析本地服务，同时可以监控和分析远程服务，通过 JMX (Java Management Extensions) 连接到远程 java 进程。</p><h6 id="确保目标远程应用允许JMX连接"><a href="#确保目标远程应用允许JMX连接" class="headerlink" title="确保目标远程应用允许JMX连接"></a>确保目标远程应用允许JMX连接</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=&#123;host_ip&#125; \</span><br><span class="line">-Dcom.sun.management.jmxremote \ # 启用JMX远程访问</span><br><span class="line">-Dcom.sun.management.jmxremote.port=&#123;port_number&#125; \ # 指定了JMX远程连接的端口（与接口访问接口不同）</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false \ # 禁用SSL和身份验证</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false \  </span><br><span class="line">-jar xxx.jar</span><br></pre></td></tr></table></figure><h6 id="启动visualvm添加远程主机"><a href="#启动visualvm添加远程主机" class="headerlink" title="启动visualvm添加远程主机"></a>启动visualvm添加远程主机</h6><p>缺点：对于分布式集群部署的java应用不易管理分析</p><h5 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h5><blockquote><p><a href="https://arthas.aliyun.com/doc/">Arthas</a> 是一款 线上java应用 性能监控和诊断工具，可以全局实时的查看应用负载，内存清空，垃圾回收，线程状态等信息。</p><p>在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p></blockquote><p>同时 Arthas 支持应用的集群管理，可以通过 <a href="https://arthas.aliyun.com/doc/tunnel.html#arthas-tunnel">arthas tunnel</a> 来远程管理/连接多个 Agent。</p><p>基本原理：部署一个 tunnel server 将 多个 java应用服务 注册信息到 tunnel server 中，通过 tunnel 提供的网页使用 arthas 访问注册的每一个应用。</p><p>步骤：</p><ul><li><p>下载部署 <a href="https://github.com/alibaba/arthas/releases">arthas tunnel server</a> </p><ul><li>启动jar包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar -Darthas.enable-detail-pages=true arthas-tunnel-server-3.7.2-fatjar.jar &amp;</span><br></pre></td></tr></table></figure><p>默认情况下，arthas tunnel server 的 web 端口是<code>8080</code>，arthas agent 连接的端口是<code>7777</code></p></li><li><p>springboot添加 arthas 依赖，配置 tunnel 服务端地址进行注册</p><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.taobao.arthas/arthas-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.taobao.arthas<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>arthas-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">arthas:</span></span><br><span class="line"><span class="attr">tunnel-server:</span> <span class="string">ws://xxx.xx.xx.xx:7777</span> <span class="string">/ws</span> <span class="comment"># 指定了Arthas Tunnel服务器的地址</span></span><br><span class="line"><span class="attr">app-name:</span> <span class="string">$&#123;spring.application.name&#125;</span>      <span class="comment"># 指定了你的Spring Boot应用程序的名称</span></span><br><span class="line"><span class="attr">http-port:</span> <span class="string">8xxx</span><span class="comment"># arthas http访问端口号</span></span><br><span class="line"><span class="attr">telnet-port:</span> <span class="string">9xxx</span><span class="comment"># arthas 远程连接端口号</span></span><br></pre></td></tr></table></figure></li><li><p>打开 tunnel 页面，查看进程列表，并选择进行使用 arthas 进行监控</p><p>tunnel 应用页面是 <a href="http://xxx.xx.xx.xx:8080/apps.html">http://xxx.xx.xx.xx:8080/apps.html</a></p></li></ul><h5 id="promethues"><a href="#promethues" class="headerlink" title="promethues"></a>promethues</h5><blockquote><p>prometheus和grafana 是企业中目前最常用的监控方案，其中 prometheus 负责监控数据采集和存储，grafana 指定 prometheus 中存储指标信息作为数据源，提供可视化面板和分析工具。</p></blockquote><p>这套方案支持系统级别和应用级别的监控，可以监控 linux 系统，java 应用，redis，mysql等。同时可以整合告警并允许自定义告警指标。</p><p>由于本人有文章已经详细介绍了这套监控组建的安装和配置，这里就只简单的说明</p><img src="https://s2.loli.net/2023/12/13/x2RFjgAkXLu1Ecf.png" alt="Prometheus architecture" style="zoom: 25%;" /><p>流程：</p><ul><li><p>java 应用暴露指标并转换为prometheus可识别的格式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 集成micrometer，将监控数据存储到prometheus --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">prometheus:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">prometheus:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>​    此时可以访问 <a href="http://xxx.xxx.xx.xx:xxx/actuator/prometheus">http://xxx.xxx.xx.xx:xxx/actuator/prometheus</a></p><ul><li><p>prometheus 定时拉取指标信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"> <span class="comment"># 采集任务名称</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;server-node&#x27;</span></span><br><span class="line">    <span class="comment"># 采集时间间隔</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="comment"># 采集数据路径</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/actuator/prometheus&#x27;</span></span><br><span class="line">    <span class="comment"># 采集服务的地址</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;xx.xx.xxx.xxx:xxxx&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>grafana 添加 prometheus 作为数据源并添加面板</p></li></ul><p>查看堆内存信息信息</p><img src="https://s2.loli.net/2024/01/05/HktrZsj4RmCQIEx.png" alt="image-20240105113533972" style="zoom:33%;" /><h4 id="内存泄漏监控分析"><a href="#内存泄漏监控分析" class="headerlink" title="内存泄漏监控分析"></a>内存泄漏监控分析</h4><h5 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h5><ul><li>在应用程序处理业务时，堆内存的曲线会上下起伏，并且始终维持在一个区间内<ul><li>业务对象频繁的创建导致内存升高</li><li>但内存达到阈值时，导致minor gc触发，内存会下降</li></ul></li><li>手动执行Full GC内存会骤降并且每次Full GC后大小接近</li></ul><img src="https://s2.loli.net/2024/01/05/IBcsVC4TGZWYKup.png" alt="image-20240105131218745" style="zoom:33%;" /><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><ul><li>堆的内存曲线持续升高，触发minor gc后，也不会下降很多</li><li>手动执行Full GC后的内存相比于上次Full GC比较大即 对象没有办法被回收</li></ul><img src="https://s2.loli.net/2024/01/05/dI4Zl6UrcLzogqO.png" alt="image-20240105131517631" style="zoom:25%;" /><h3 id="内存泄漏常见场景"><a href="#内存泄漏常见场景" class="headerlink" title="内存泄漏常见场景"></a>内存泄漏常见场景</h3><h4 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h4><h5 id="equals-和hashCode"><a href="#equals-和hashCode" class="headerlink" title="equals()和hashCode()"></a>equals()和hashCode()</h5><blockquote><p>在java中，equals() 和 hashCode() 是用于处理对象相等的重要方法，在定义一个新的类时，如果没有重写equals()和hashCode()方法，则会使用父类即Object类提供的实现。</p><p>当使用HashMap或者HashSet等集合的场景下，由于这些集合依赖于对象的equals()和hashCode()方法来进行元素的唯一性检查，</p><p>当对象没有正确重写这两个方法时，会导致相同数据的对象唯一性检查结果不同，相同数据的对象被保存多个。</p></blockquote><p>jdk8为例，HashSet 在添加新元素时，首先调用 hashcode 方法计算出哈希值，如果不相同，则直接添加元素，如果相同，则调用 equals() 方法进行判断，如果false，添加元素，如果true，则不添加元素</p><p>当对象没有重写equals() 和 hashCode()方法时，则按照Object默认来实现，Object的hashCode()算法里面有随机数参与运算，因此导致数据相同的哈希值不一定相同，同时 Object的equals()判断的是对象的引用相等性即对象的地址是否相同。</p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"># Student </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟大对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Byte[] bytes = <span class="keyword">new</span> <span class="title class_">Byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="comment">//        if (this == o) return true;</span></span><br><span class="line"><span class="comment">//        if (o == null || getClass() != o.getClass()) return false;</span></span><br><span class="line"><span class="comment">//        Student student = (Student) o;</span></span><br><span class="line"><span class="comment">//        return Objects.equals(id, student.id) &amp;&amp; Objects.equals(name, student.name) &amp;&amp; Arrays.equals(bytes, student.bytes);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">//        int result = Objects.hash(id, name);</span></span><br><span class="line"><span class="comment">//        result = 31 * result + Arrays.hashCode(bytes);</span></span><br><span class="line"><span class="comment">//        return result;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次循环100次 休眠10ms 防止主进程一直工作 visualvm无法监控</span></span><br><span class="line">            <span class="keyword">if</span> (count++ % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            student.setId(<span class="number">1L</span>);</span><br><span class="line">            student.setName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="comment">// 数据相同的对象添加到 hashset</span></span><br><span class="line">            set.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例，当没有重写实体类的 hashcode() 和 equals() 方法时，使用 hashset 导致了内存溢出问题：</p><p>使用 object hashcode有随机值导致可能不相同，object equals比较对象内存地址，导致不同，因此 HashSet 中存放了 大量数据相同的数据。</p><img src="https://s2.loli.net/2024/01/05/jMJwWgP57VqNiGx.png" alt="image-20240105141858584" style="zoom:33%;" /><h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><ul><li>定义实体类时，始终重写它的equals()和hashCode()方法，重写时注意使用哪一个字段作为标识来区分对象</li></ul><h5 id="内部类引用外部类"><a href="#内部类引用外部类" class="headerlink" title="内部类引用外部类"></a>内部类引用外部类</h5><blockquote><p><strong>非静态类的内部类</strong>的实例默认持有外部类的引用，当有地方引用了内部类，会导致也会被引用，垃圾回收时无法回收这个外部类。</p><p><strong>匿名内部类</strong>对象如果在<strong>非静态方法</strong>中被创建，会持有调用者对象示例，垃圾回收时无法回收调用者。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟大对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Byte[] bytes = <span class="keyword">new</span> <span class="title class_">Byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Inner&gt; inners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次循环100次 休眠10ms 防止主进程一直工作 visualvm无法监控</span></span><br><span class="line">            <span class="keyword">if</span> (count++ % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            inners.add(<span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/01/05/CuRJE4TrBIyehlF.png" style="zoom:33%;" /><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><blockquote><p>ThreadLocal 是 java 中的一个类，用于存放线程本地变量，这些变量在不同的线程中有独立的副本，互不影响。</p><p>当 ThreadLocal 对象不在使用时，需要手动调用 remove 方法进行清理，防止发生内存泄漏。</p><p>注意，当我们销毁线程时，ThreadLocal 对象也会被回收。但是如果我们使用是线程池（线程不一定回收），ThreadLocal 就不一定会被回收，从而可能导致内存泄漏。如果线程没有被回收，也没有调用 ThreadLocal 的 remove 方法则会导致 ThreadLocal 无法被回收，导致内存泄漏。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;());</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                threadLocal.set(<span class="keyword">new</span> <span class="title class_">Byte</span>[<span class="number">1024</span>]);</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/01/05/1hDTRrC7tBpAWaH.png" alt="image-20240105204455701" style="zoom:33%;" /><h6 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h6><p>线程执行完毕后，一定要手动调用ThreadLocal的remove方法清理对象。</p><h5 id="string-intern方法"><a href="#string-intern方法" class="headerlink" title="string intern方法"></a>string intern方法</h5><p>如果很多不同的字符串使用intern方法被大量调用并且引用(不被引用的话，当字符串常量池过大时，可能触发垃圾收集 - jdk6 字符串常量池回收 ｜ jdk7 堆回收)，字符串常量池会不停变大超过（jdk6 永久代｜ jdk7 方法区）上限会产生内存溢出问题。</p><p>jdk6时，字符串常量池处于堆内存的永久代中， jdk7及之后，字符串常量池位于堆内存中。</p><p><img src="https://s2.loli.net/2024/01/05/OqmxZfzbyH3tIAJ.png" alt="image-20240103154047381"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// list.add 保证强引用关系 避免被 gc 回收</span></span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h6><ul><li>谨慎使用 <code>intern()</code> 方法，过度使用可能会对性能和内存占用产生影响</li><li>jdk6 增大永久代空间大小，根据实际的情况和测试结果进行设置，可以设置 <code>-XX:MaxPermSize=256M</code>（默认为64M）</li></ul><h5 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h5><blockquote><p>静态变量引用的对象不会被垃圾回收，如果这些对象不再使用，就会导致内存泄露</p></blockquote><h6 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h6><ul><li>排查掉无效的静态变量并且避免在静态变量里引用大对象</li><li>使用单例模式时，如果对象不是经常被使用，可以使用懒加载来避免不使用但是去创建</li><li>spring的bean对象不要长期存放大对象，部分bean对象可以使用 @Lazy 懒加载(即真正需要使用该 bean 时才进行初始化)</li></ul><h5 id="资源没有正确关闭"><a href="#资源没有正确关闭" class="headerlink" title="资源没有正确关闭"></a>资源没有正确关闭</h5><blockquote><p>连接和IO流资源对象会占用内存，如果使用完毕后没有及时关闭，这部分内存可能会导致内存泄露（不一定导致）</p></blockquote><p>解决方案</p><ul><li><p>try-catch-finally 在 finally 块中关闭不再使用的资源</p></li><li><p>jdk7 推荐使用 try-with-resources 语法用于自动关闭资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (...<span class="comment">//申请资源对象) &#123;</span></span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="并发层面"><a href="#并发层面" class="headerlink" title="并发层面"></a>并发层面</h4><blockquote><p>正常情况下，用户向java应用程序发送请求来获取数据，java应用将数据加载到内存中并返回至客户端，在此之后，数据将在内存汇被释放掉。</p><p>但当用户请求并发量比较大的时候，数据处理的过程时间也比较长，导致大量的数据存在于内存中，最终超过了内存的上限即产生内存溢出。</p></blockquote><p>遇到这种问题，处理思路需要首先定位问题的根源即对象产生的根源。</p><h5 id="Jmeter-并发测试工具"><a href="#Jmeter-并发测试工具" class="headerlink" title="Jmeter 并发测试工具"></a>Jmeter 并发测试工具</h5><blockquote><p><code>apache jmeter</code> 是一款开源测试软件，可以进行并发请求测试。</p><p>下载地址：<a href="https://github.com/apache/jmeter/releases">https://github.com/apache/jmeter/releases</a></p></blockquote><ul><li><p>在 测试计划 中添加线程组并配置</p><img src="https://s2.loli.net/2024/01/06/gkDKxOA8zS5bfMB.png" alt="image-20240106195456534" style="zoom:33%;" /><img src="https://s2.loli.net/2024/01/06/ZX4NSK67CMWnziU.png" alt="image-20240106195913237" style="zoom:33%;" /></li><li><p>在线程组中添加http请求</p><img src="https://s2.loli.net/2024/01/06/F9VtBOC5ero6ikm.png" alt="image-20240106200137536" style="zoom:33%;" /><p><img src="https://s2.loli.net/2024/01/06/j5VlcawsH4FTteK.png" alt="image-20240106200438157"></p></li><li><p>推荐监听器的聚合报告，启动程序观察报告</p><img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20240106201034477.png" alt="image-20240106201034477" style="zoom:50%;" /></li></ul><h4 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h4><blockquote><p>通过分析工具，诊断问题的产生原因，定位出现问题的源代码</p></blockquote><p>当发生内存溢出时，将堆内存溢出时的整个堆内存信息保存下来，生成内存快照（Heap Profile）文件</p><ul><li>生成内存快照的jvm参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError # 当发生 OutOfMemoryError 错误时生成堆转储（heap dump）文件即hprof内存快照文件</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt; # 指定hprof文件的路径</span><br></pre></td></tr></table></figure><ul><li>使用MAT打开hprof文件并选择内存泄露检测功能，自动根据内存快照中保存的数据进行分析，从而找到内存泄露的根源</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1MB</span></span><br><span class="line">            Byte[] bytes = <span class="keyword">new</span> <span class="title class_">Byte</span>[<span class="number">1024</span> *<span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line">            list.add(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jvm 配置如下：</p><img src="https://s2.loli.net/2024/01/07/fNyKD6g2ZLbxtAQ.png" alt="image-20240107004440548" style="zoom:33%;" /><p>hropf 文件生成</p><img src="https://s2.loli.net/2024/01/07/8JBKbiLgUNp64cw.png" alt="image-20240107005005879" style="zoom:33%;" /><p>使用MAT打开hropf文件</p><img src="https://s2.loli.net/2024/01/07/uwWA8FeDSiJETXm.png" alt="image-20240107005243237" style="zoom:50%;" /><p>生成内存泄漏嫌疑报告</p><img src="https://s2.loli.net/2024/01/07/uwWA8FeDSiJETXm.png" alt="image-20240107005329337" style="zoom:33%;" /><img src="https://s2.loli.net/2024/01/07/uBdXw17OxjnVyAg.png" alt="image-20240107005731313" style="zoom:33%;" /><h5 id="MAT内存泄漏检测原理"><a href="#MAT内存泄漏检测原理" class="headerlink" title="MAT内存泄漏检测原理"></a>MAT内存泄漏检测原理</h5><blockquote><p>MAT 使用 支配树（Dominator Tree）用于分析对象之间支配关系。支配树显示了在java 堆中对象对其他对象具有支配权，这对于查找内存泄漏和优化内存使用非常有用。</p><p>在对象的引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B</p><img src="https://s2.loli.net/2024/01/07/duU546WglMYkCbD.png" alt="image-20240107010754331" style="zoom:33%;" /></blockquote><p>支配树的深堆（retained heap）和浅堆（shallow heap）是两个重要的概念</p><ul><li>浅堆 - Shallow Heap：指一个对象本身所占用的内存大小，而不考虑该对象引用的其他对象<ul><li>用于表示一个对象的直接开销，包括对象头、实例变量等</li></ul></li><li>深堆 - Retained Heap：指一个对象及该对象所支配的对象的总内存大小<ul><li>用于表示如果该对象被回收，可以释放多大的内存空间</li></ul></li></ul><p>示例</p><p>通过参数 <code>-XX:HeapDumpBeforeFullGC</code> 在执行 FullGC 之前生成内存快照，通过这种方式即可在不发生内存溢出的情况下生成堆内存快照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestClass</span> <span class="variable">testClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClass</span>();</span><br><span class="line">        <span class="type">TestClass</span> <span class="variable">testClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClass</span>();</span><br><span class="line">        <span class="type">TestClass</span> <span class="variable">testClass3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;str1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;str2&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;str3&quot;</span>;</span><br><span class="line"></span><br><span class="line">        testClass1.list.add(s1);</span><br><span class="line"></span><br><span class="line">        testClass2.list.add(s1);</span><br><span class="line">        testClass2.list.add(s2);</span><br><span class="line"></span><br><span class="line">        testClass3.list.add(s3);</span><br><span class="line"></span><br><span class="line">        s1 = <span class="literal">null</span>;</span><br><span class="line">        s2 = <span class="literal">null</span>;</span><br><span class="line">        s3 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/01/08/FXWvy74Nwo8uBJV.png" alt="image-20240108151306858" style="zoom:33%;" /><p>使用 MAT 查看 支配树 </p><p><img src="https://s2.loli.net/2024/01/08/4ufLHj8sMYOTZDF.png" alt="image-20240108152737808"></p><p>MAT 会根据支配树，从叶子节点向根节点遍历，如果发现深堆的大小超过了整个堆内存的一定比例阈值，则会将其标记为内存泄露的”嫌疑对象”。</p><h5 id="运行内存快照导出和MAT分析"><a href="#运行内存快照导出和MAT分析" class="headerlink" title="运行内存快照导出和MAT分析"></a>运行内存快照导出和MAT分析</h5><p>如何导出运行中的系统的内存快照 - 注意只需要导出标记为存活对象</p><ul><li><p>使用 JDK自带的 <code>jmap</code> 命令导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=/xx/xxx.hprof &lt;PID&gt; # live 只保存存活对象</span><br><span class="line">jmap -dump:format=b,file=/xx/xxx.hprof &lt;PID&gt; # 保存全部对象</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/08/SCxVetAMmyhBvs3.png" alt="image-20240108154053835"></p></li><li><p>使用 arthas 的 heapdump 命令导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapdump --live /xx/xxx.hprof</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/08/iRDyeXCZlk16q5H.png" alt=" "></p></li></ul><p>使用 MAT 分析 hprof 文件</p><p><img src="https://s2.loli.net/2024/01/08/ATnr9Ye4iUduaLO.png" alt="image-20240108154720875"></p><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>在实际开发场景中，在开发者电脑的内存范围之内的快照文件都可以直接在开发者电脑使用MAT打开分析，如果遇到内存快照文件过大超过开发者电脑的内存范围，开发者电脑将无法正常打开此类的内存快照，需要下载服务器操作系统对应的MAT，直接在服务器上直接生成内存分析报告。</p><p>下载地址：<a href="https://eclipse.dev/mat/downloads.php">https://eclipse.dev/mat/downloads.php</a></p><p>使用MAT-Linux脚本直接生成内存检测报告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ParseHeapDump.sh /xx/xxx.hprof org.eclipse.mat.api:suspects org.eclipse.mat.api:overview org.eclipse.mat.api:top_components</span><br></pre></td></tr></table></figure><p>注意：默认MAT分析时只使用了1G的堆内存，如果快照文件超过1G，需要修改MAT目录下的 MemoryAnalyzer.ini配置文件调整最大堆内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1024m</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/08/yWdPRlD6XYc3piw.png" alt="image-20240108191031007"></p><p>生成的压缩包下载解压是静态文件，可以直接用网页打开</p><p><img src="https://s2.loli.net/2024/01/08/noepDmuPd76tvWX.png" alt="image-20240108191639042"></p><h3 id="内存泄漏解决方案"><a href="#内存泄漏解决方案" class="headerlink" title="内存泄漏解决方案"></a>内存泄漏解决方案</h3><p>代码层面的内存泄露只需要修改代码即可。但是并发引起的内存溢出主要可能由于 jvm参数设置不当 和 业务设计不当，需要开发者调整 jvm 参数 和 优化设计方案。</p><h4 id="问题解决思路"><a href="#问题解决思路" class="headerlink" title="问题解决思路"></a>问题解决思路</h4><ul><li>设置jvm启动参数，在发生OOM内存溢出时，生成内存快照</li><li>使用 MAT 分析内存快照，找到内存溢出的对象</li><li>尝试在开发环境中重现问题，分析代码中问题产生的原因</li><li>修改代码后测试并验证结果</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><h5 id="分页查询接口"><a href="#分页查询接口" class="headerlink" title="分页查询接口"></a>分页查询接口</h5><blockquote><p>当分页接口没有限制最大单次访问条数时，并且分页单个数据字段占用过大的内存，在并发较高的场景下，会加载到内存的对象占用大量内存空间。</p></blockquote><p>解决方案</p><ul><li>限制最大单次访问条数</li><li>分页接口清除与业务无关的字段</li><li>对于服务进行限流保护</li></ul><h5 id="导出大文件接口"><a href="#导出大文件接口" class="headerlink" title="导出大文件接口"></a>导出大文件接口</h5><blockquote><p>excel文件导出如果使用Apache POI的XSSFWorkbook，在数据量比较大的场景下，会占用大量的内存。</p></blockquote><p>解决方案</p><ul><li>使用Apache POI的SXSSFWorkbook，优化内存开销</li><li>使用Hutool提供的BigExcelWriter减少内存开销</li><li>使用easyexcel工具分批导出，对于内存进行大量的优化</li></ul><h5 id="ThreadLocal拦截器内存泄漏"><a href="#ThreadLocal拦截器内存泄漏" class="headerlink" title="ThreadLocal拦截器内存泄漏"></a>ThreadLocal拦截器内存泄漏</h5><blockquote><p>在很多场景下，会使用拦截器在prehandle方法解析请求头中的数据，并放入到ThreadLocal中方便后续使用，当没有调用remove清理掉时，这些数据将一直保存在tomcat的核心线程中，造成了内存泄漏。</p></blockquote><p>解决方法在HandlerInterceptor拦截器的afterCompletion方法中，必须调用remove方法，将ThreadLocal中的数据清理掉。</p><h5 id="异步业务处理问题"><a href="#异步业务处理问题" class="headerlink" title="异步业务处理问题"></a>异步业务处理问题</h5><blockquote><p>在项目中采用异步方案解决部分耗时业务时，</p><p>我们首先想到是开启线程池，将任务提交到线程池中，但是这样的方案存在一定的问题，线程池的参数设置不当会导致大量线程的创建或者队列中保存了大量的数据，这些都会导致内存溢出；其次当没有将任务进行持久化时，队列中保存满了后任务走拒绝策略或者服务宕机或者掉电时，会导致任务丢失。</p><p>进一步优化后，我们引入阻塞队列LinkedBlockingQueue来保存任务，线程池从队列中一直获取任务执行，阻塞队列数据量过大，持久化业务设计复杂</p><p>引入消息队列组建，使用rabbitmq保存任务，拆分生产者和消费者模型，rabbitmq存储任务数据避免jvm内存溢出，同时rabbitmq实现了持久化机制，防止任务丢失。</p></blockquote><h3 id="诊断问题的两种方案对比"><a href="#诊断问题的两种方案对比" class="headerlink" title="诊断问题的两种方案对比"></a>诊断问题的两种方案对比</h3><h4 id="生成内存快照并分析"><a href="#生成内存快照并分析" class="headerlink" title="生成内存快照并分析"></a>生成内存快照并分析</h4><p>优点：通过完整的内存快照可以准确的判断问题产生的原因</p><p>缺点：内存较大时，生成内存快照较慢，生成内存的过程会导致进行阻塞即程序无法对外提供服务</p><p>​     MAT分析内存快照时，需要提供比内存快照大1.5-2倍大小的内存空间</p><h4 id="在线定位问题"><a href="#在线定位问题" class="headerlink" title="在线定位问题"></a>在线定位问题</h4><p>优点：无需生成内存快照，整个过程对于用户的影响比较小</p><p>缺点：无法查看详细的内存信息</p><p>​     需要通过 arthas 和 btrace 等工具调测，发生问题产生的原因，开发者需要具备一定的经验</p><h5 id="在线定位问题步骤"><a href="#在线定位问题步骤" class="headerlink" title="在线定位问题步骤"></a>在线定位问题步骤</h5><ul><li><p>Arthas</p><ul><li>使用 <code>jmap -histo:live &lt;PID&gt; &gt; /xx/xxx.txt</code> 命令将内存中存活的对象以直方图的形式保存到文件中，在此过程中会阻塞应用程序，但是相对于生成内存快照，停顿时间较短</li><li>分析直方图文件中内存占用较多的对象，查找内存泄漏的嫌疑对象</li><li>使用 arthas 的 stack 命令，追踪对象方法被调用的调用路径，找到对象创建即内存泄漏的根源</li></ul></li><li><p>BTrace</p><blockquote><p>BTrace 是 一个 java 平台上执行的追踪工具，可以有效的用于线上运行系统的方法追踪，具有侵入性小，对性能影响微乎其微的特点。在项目中可以使用 BTrace 工具，打印出方法被调用栈信息</p></blockquote><ul><li><p>下载 <code>BTrace</code> 工具，下载地址：<a href="https://github.com/btraceio/btrace/releases/">https://github.com/btraceio/btrace/releases/</a></p></li><li><p>编写一个 <code>BTrace</code> 脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.btrace.core.annotations.BTrace;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.btrace.core.annotations.OnMethod;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tracing</span> &#123;</span><br><span class="line">    <span class="meta">@OnMethod(</span></span><br><span class="line"><span class="meta">            clazz = &quot;com.example.entity.DemoEntity&quot;,</span></span><br><span class="line"><span class="meta">            method = &quot;/.*/&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traceExecute</span><span class="params">()</span> &#123;</span><br><span class="line">      jstack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将 Btrace 工具和脚本上传到服务器中，在服务器上运行 <code>btrace &lt;PID&gt; 脚本文件名</code></p><ul><li><p>配置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BTRACE_HOME=/xxx/xxx/btrace/bin</span><br><span class="line">PATH=$PATH:$BTRACE_HOME/bin</span><br><span class="line">export PATH BTRACE_HOME</span><br></pre></td></tr></table></figure></li><li><p>执行脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btrace &lt;PID&gt; Tracing.java</span><br></pre></td></tr></table></figure></li></ul></li><li><p>观察执行结果</p></li></ul></li></ul><h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><blockquote><p>GC调优 指的是 对于jvm垃圾回收（Garbage Collection）进行调优。</p><p>GC调优的目的是 避免由垃圾回收引起的程序性能下降。</p></blockquote><p>GC 调优的核心分为三部分：</p><ul><li>通用 jvm 参数设置</li><li>选择合适的垃圾回收器并对它进行参数设置</li><li>解决频繁Full GC导致的程序性能下降的问题</li></ul><p>注意 GC调优没有唯一的答案，如何调优与硬件，程序本身，使用情况等诸多因素相关，所以重要的是调优的工具和方法。</p><h3 id="GC-调优核心指标"><a href="#GC-调优核心指标" class="headerlink" title="GC 调优核心指标"></a>GC 调优核心指标</h3><blockquote><p>如何判断GC指标是否需要调优，需要从三个方面考虑</p></blockquote><ul><li><p><strong>吞吐量</strong> - ThroughPut：</p><p>吞吐量分为业务吞吐量和垃圾回收吞吐量</p><ul><li>业务吞吐量指的是在一段时间内，程序需要完成的业务数量</li><li>垃圾回收的吞吐量指的是 CPU用于执行用户业务时间与CPU总执行时间（执行用户业务时间 + GC时间）的比值</li></ul><p>保证高吞吐量的常规手段包括：</p><ul><li>优化业务执行性能，减少单次业务的执行时间</li><li>优化垃圾回收吞吐量</li></ul></li><li><p><strong>延迟</strong> - Latency：</p><p>延迟指的是从用户发起请求到用户收到响应其中经历的时间。</p><p>延迟 = GC 延迟 + 业务执行时间</p></li><li><p><strong>内存使用量</strong></p><p>内存使用量指的是java应用占用系统内存的最大值，可以通过jvm参数调整，在满足上述两个指标的前提下，该值越小越好</p></li></ul><h3 id="GC-调优方法"><a href="#GC-调优方法" class="headerlink" title="GC 调优方法"></a>GC 调优方法</h3><h4 id="GC-调优步骤"><a href="#GC-调优步骤" class="headerlink" title="GC 调优步骤"></a>GC 调优步骤</h4><blockquote><p>发现问题：通过监控工具提前发现GC时间过长，频率过高的现象</p><p>诊断问题：通过分析工具来诊断问题产生的原因</p><p>修复问题：调整jvm参数或者修复源代码中存在的问题</p><p>测试问题：测试环境部署验证问题是否解决</p></blockquote><h5 id="发现问题-1"><a href="#发现问题-1" class="headerlink" title="发现问题"></a>发现问题</h5><h6 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h6><blockquote><p><code>jstat</code> 是 jdk自带的一个监控和性能分析工具，用于收集和显示与jvm相关的各种统计信息。它可以提供有关堆内存、垃圾回收、类加载、线程等方面的实时数据，帮助开发人员和系统管理员进行性能调优和故障排除</p></blockquote><p>查看垃圾回收统计信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc &lt;PID&gt; &lt;interval&gt; &lt;count&gt; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;PID&gt; java进程号</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;interval&gt; 采样间隔（以毫秒为单位）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;count&gt; 采样次数</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/09/PhYKQVGZmqLA3jo.png" alt="image-20240109085618929"></p><ul><li>C - capacity容量 U - used使用量</li><li>s - 幸存者区 E - 伊甸园区 o - 老年代区 M - 元空间</li><li>YGC - young gc 次数    YGCT - young gc总耗时（单位：秒）</li><li>FGC - full gc 次数     FGCT - full gc总耗时（单位：秒）</li><li>GCT - gc总耗时</li></ul><p>以上重点关注 full gc的次数和耗时 - fgc 和 fgct</p><p>优点：操作简单，jdk 自带工具</p><p>缺点：无法精准定位gc产生时间和问题，只能用于判断gc是否存在问题</p><h6 id="visualvm-1"><a href="#visualvm-1" class="headerlink" title="visualvm"></a>visualvm</h6><blockquote><p>visualvm 提供了一款 visual tool 的插件，实时监控java进程的 堆内存结构、堆内存变化趋势以及垃圾回收时间的变化趋势，同时可以监控对象晋升的直方图。</p></blockquote><p>安装插件</p><img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20240109090951567.png" alt="image-20240109090951567" style="zoom:33%;" /><p>查看插件</p><img src="https://s2.loli.net/2024/01/09/Rs5YgcGp8aITj9x.png" alt="image-20240109091407604" style="zoom:33%;" /><p>优点：只适合开发环境使用，可以直观看到堆内存和GC的变化趋势</p><p>缺点：visualvm需要收集信息，对于程序运行有一定的影响；生产环境开发者一般没有权限进行操作</p><h6 id="prometheus和grafana"><a href="#prometheus和grafana" class="headerlink" title="prometheus和grafana"></a>prometheus和grafana</h6><blockquote><p>prometheus和grafana 是企业中目前最常用的监控方案，其中 prometheus 负责监控数据采集和存储，grafana 指定 prometheus 中存储指标信息作为数据源，提供可视化面板和分析工具。</p></blockquote><p><img src="https://s2.loli.net/2024/01/09/6daLHNCv5z9ZInt.png" alt="image-20240109093943676"></p><p>这种监控工具的内容相对于比较简单，可以发现问题，但是无法定位问题</p><h6 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h6><blockquote><p>通过GC日志，可以将看到垃圾回收细节上数据，从而更好的发现问题。</p></blockquote><p>使用方法：</p><ul><li>JDK8，<code>-XX:+PrintGCDetails -Xloggc:/xx/xxx.log</code></li><li>JDK9，<code>-Xlog:gc*:file=/xx/xxx.log</code></li></ul><h6 id="GC-Viewer"><a href="#GC-Viewer" class="headerlink" title="GC Viewer"></a>GC Viewer</h6><p>GCViewer 是一个将GC日志转换为可视化图表的小工具，地址：<a href="https://github.com/chewiebug/GCViewer/releases">https://github.com/chewiebug/GCViewer/releases</a></p><p>使用方法: <code>java -jar gcviewer-x.xx.jar</code></p><img src="https://s2.loli.net/2024/01/09/MeaXcGxSnU6pg74.png" alt="image-20240109104423379" style="zoom:33%;" /><h6 id="GCeasy"><a href="#GCeasy" class="headerlink" title="GCeasy"></a>GCeasy</h6><blockquote><p>GCeasy 是业界首款使用AI机器学习技术在线进行GC分析和诊断工具，定位内存泄漏，GC延迟高的问题，提供jvm参数优化建议，支持在线可视化工具图表战术。</p><p>官方网站：<a href="https://gceasy.io/">https://gceasy.io/</a></p></blockquote><img src="https://s2.loli.net/2024/01/09/VZi3Hh9GkWvoBrY.png" alt="image-20240109110154337" style="zoom:33%;" /><h5 id="分析模式"><a href="#分析模式" class="headerlink" title="分析模式"></a>分析模式</h5><blockquote><p>根据监控软件上的堆内存的趋势图，判断内存是否存在问题或者垃圾回收是否存在问题。</p></blockquote><h6 id="正常情况-1"><a href="#正常情况-1" class="headerlink" title="正常情况"></a>正常情况</h6><p>特点：内存趋势图呈现锯齿形，对象创建后内存上升，垃圾回收后内存下降至”底部”，并且每次下降后的内存接近，存留的对象较少。</p><img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20240109112501363.png" alt="image-20240109112501363" style="zoom:33%;" /><h6 id="缓存对象过多"><a href="#缓存对象过多" class="headerlink" title="缓存对象过多"></a>缓存对象过多</h6><p>特点：内存趋势图呈现锯齿形，对象创建后内存上升，垃圾回收后内存下降至”底部”，并且每次下降后的内存接近，但是处于比较高的位置。</p><p>产生原因：运行程序中保存了大量的缓存对象，导致gc之后无法释放，可以使用MAT或者HeapHero等工具分析内存占用的原因</p><img src="https://s2.loli.net/2024/01/09/fdzGJCoeu5MqFZL.png" alt="image-20240109112455515" style="zoom:33%;" /><h6 id="内存泄漏-1"><a href="#内存泄漏-1" class="headerlink" title="内存泄漏"></a>内存泄漏</h6><p>特点：内存趋势图呈现锯齿形，对象创建后内存上升，垃圾回收后下降的位置越来越高，最后由于垃圾回收无法回收对象释放空间导致新创建的对象无法分配，导致内存溢出问题</p><p>问题产生原因：程序中保存了大量的内存泄漏对象，导致gc之后无法释放</p><img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20240109112901587.png" alt="image-20240109112901587" style="zoom:33%;" /><h6 id="持续FullGC"><a href="#持续FullGC" class="headerlink" title="持续FullGC"></a>持续FullGC</h6><p>特点：在某个时间段发生了多次FullGC，CPU使用率同时飙高，用户请求无法处理，吞吐量大大下降，但是过了一段时间就恢复正常，</p><p>问题产生原因：运行应用在时间段内请求量飙高，导致不量对象呗创建，垃圾收集器的回收效率无法跟上对象的创建速率，导致持续的进行Full GC。</p><img src="https://s2.loli.net/2024/01/09/e6BsaF7hIRqJ8tp.png" alt="image-20240109112952891" style="zoom: 50%;" /><h6 id="元空间不足"><a href="#元空间不足" class="headerlink" title="元空间不足"></a>元空间不足</h6><p>特点：堆内存的大小不是特别大，但是持续发生full gc</p><p>问题产生原因：元空间大小不足，导致持续发生full gc来回收元空间数据</p><img src="https://s2.loli.net/2024/01/09/ztyeTpKQwH8FfJO.png" alt="image-20240109113924694" style="zoom:50%;" /><h5 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h5><blockquote><p>解决GC问题的常用手段如下：</p><ul><li>优化基础jvm参数</li><li>减少对象产生</li><li>更换垃圾回收器</li><li>优化垃圾回收器参数</li></ul><p>其中前三种是比较推荐的手段，第四种只会在前三种都没有办法使用时选用</p></blockquote><h6 id="优化基础jvm参数"><a href="#优化基础jvm参数" class="headerlink" title="优化基础jvm参数"></a>优化基础jvm参数</h6><p>不同jdk的参数可以在官网文档中查找，地址：<a href="https://docs.oracle.com/en/java/javase/index.html">https://docs.oracle.com/en/java/javase/index.html</a></p><ul><li><p>-Xmx和-Xms</p><p>Xmx参数设置的是最大堆内存，Xms参数设置的初始堆内存</p><p>计算最大堆内存时，需要将元空间，操作系统和其他软件服务占用的内存排除</p><p>最合理的设置方式是根据最大的并发量估算出服务器的配置，然后再根据服务器的配置计算最大堆内存的值</p><p><img src="https://s2.loli.net/2024/01/09/NtpGT7ubyJxYUWV.png" alt="image-20240109131330508"></p><p>注意：建议将-Xms和-Xmx设置成一样大</p><ul><li>运行时性能更好，因为堆的扩容和缩容需要向操作系统申请内存，这样会导致程序性能短期下降</li><li>可用性问题，如果扩容时，服务器中的其他程序使用大量的内存，很容易导致申请操作系统内存分配失败，导致内存溢出</li><li>启动速度更快，如果初始堆大小，java 应用程序启动会变慢，因为 jvm 被迫频繁执行垃圾收集，直到堆增长到更合理的大小。为了获得最佳启动性能，应该将初始堆内存和最大堆内存设置相同。</li></ul></li><li><p>-XX:MaxMetaspaceSize 和 -XX:MetaspaceSize</p><p>-XX:MaxMetaspaceSize=<size> 参数指的是最大元空间，默认值为-1即可以一直向操作系统空间申请内存，如果元空间发生了内存泄漏，会一直向操作系统申请内存，导致操作系统内存不可控，建议按照部署实际情况设置最大值，一般可以设置为 256m</p><p>-XX:MetaspaceSize=<size> 参数值的是 元空间使用量第一次达到该阈值时会触发FullGC，后续该阈值会由jvm自动计算获得，如果设置和MaxMetaspaceSize一样的大小，则元空间的对象将一直不会被回收，直到达到最大元空间，建议不用设置该值。</p></li><li><p>-Xss </p><p>—Xss 参数指的是虚拟机栈大小，jvm将创建一个具有默认大小的栈，该默认大小取决于操作系统和计算机体系结构，例如 linux x86 64位默认栈的大小为1MB，正常情况下，不需要用这么大的栈内存，完全可以将此值调小来节省内存空间，合理值为 256k - 1m 之间。建议设置 -Xss256k</p></li><li><p>不建议手动设置的参数</p><ul><li><p>-Xmn 年轻代的大小，默认值为整个堆的1/3</p><p>（很多文章表明可以根据峰值流量计算最大的年轻代大小，尽量让对象只存放在年轻代，不进入老年代中。但是在实际的场景中，接口的响应时间，创建对象的大小，程序内部的其他任务等不确定的因素都会导致这个值的大小不准确，此外，g1垃圾回收器会动态的调整年轻代的大小）</p></li><li><p>—XX:SurvivorRatio 伊甸园区和幸存者区的大小比例，默认值为8</p></li><li><p>—XX:MaxTenuringThreshold 最大晋升阈值，当对象年龄大于此值，会从年轻代进入老年代。</p></li></ul></li><li><p>其他参数</p><ul><li><p>-XX:DisableExplicitGC：使代码中调用的system.gc()方法无效</p></li><li><p>-XX:+HeapDumpOnOutOfMemeryError：发生内存溢出OutOfMemeryError时，自动生成内存快照hprof文件</p><p>-XX:HeapDumpPath=<path>：指定hprof文件的输出路径</p></li><li><p>打印GC日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -Xloggc:/xx/xxx.log #  JDK8及之前</span><br><span class="line">-Xlog:gc*:file=/xx/xxx.log #  JDK9及之后</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>jvm参数模版</p><blockquote><p> 堆内存大小和栈内存大小需要根据实际情况灵活调整</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">jdk8及之前</span></span><br><span class="line">-Xms&lt;size&gt;</span><br><span class="line">-Xmx&lt;size&gt;</span><br><span class="line">-Xss256k</span><br><span class="line">-XX:MaxMetaspaceSize=256m </span><br><span class="line">-XX:+DisableExplicitGC</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/xx/xxx.hprof</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:/xx/xxx.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">jdk9及之后</span></span><br><span class="line">-Xms&lt;size&gt;</span><br><span class="line">-Xmx&lt;size&gt;</span><br><span class="line">-Xss256k</span><br><span class="line">-XX:MaxMetaspaceSize=256m </span><br><span class="line">-XX:+DisableExplicitGC</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/xx/xxx.hprof</span><br><span class="line">-Xlog:gc*:file=/xx/xxx.log</span><br></pre></td></tr></table></figure><h6 id="减少对象产生"><a href="#减少对象产生" class="headerlink" title="减少对象产生"></a>减少对象产生</h6><blockquote><p>使用合理的方式，优化代码，减少对象的产生频率和大对象的产生</p></blockquote><h6 id="更换垃圾回收器"><a href="#更换垃圾回收器" class="headerlink" title="更换垃圾回收器"></a>更换垃圾回收器</h6><blockquote><p>根据具体的业务场景，选择适合的垃圾回收器</p></blockquote><p><img src="https://s2.loli.net/2024/01/09/iZ1mIp4qwrhlxWS.png" alt="image-20240109155502560"></p><p>jdk8之前版本</p><ul><li>默认采用 ParallelScavenge 和 ParallellOld 的组合，在高并发的场景下，响应时间较长，但是整体吞吐量好，建议在执行任务和数据处理的应用上使用比较好</li><li>采用 ParNew 和 CMS 的组合，在高并发的场景下，整体延迟好于默认组合，但是虽然延迟低，但是GC的次数比较多。</li></ul><p>jdk9 建议使用 g1 垃圾收集器</p><h6 id="优化垃圾收集器参数"><a href="#优化垃圾收集器参数" class="headerlink" title="优化垃圾收集器参数"></a>优化垃圾收集器参数</h6><blockquote><p>优化垃圾回收器的参数，在一定程度上提升GC效率</p><p>(jvm gc参数参考地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a>)</p><p>注意：gc 优化在一般的场景下是无需考虑的</p></blockquote><p>示例 ：CMS 并发模式失败</p><p>当使用CMS回收老年代即使用并发模式时，由于CMS的垃圾清理线程用户线程是并行的，如果在并发清理的过程中，老年代的空间不足以容纳新放入老年代的对象，会产生并发模式失败现象，此现象会导致jvm虚拟机使用serialold（即发生退化）单线程进行fullgc对老年代进行回收，出现长时间的停顿。</p><p>解决方案：</p><ul><li><p>减少对象和产生以及对象的晋升</p></li><li><p>增加堆内存大小</p></li><li><p>优化垃圾回收器的参数，<code>-XX:CMSInitiatingOccupancyFraction=值</code>当老年代大小到达该阈值时，会自动进行CMS垃圾回收，通过这个参数让jvm提前进行老年代的垃圾回收，减少其大小，防止出现发生退化卡顿现象。</p><p>jdk8中默认这个参数值为 -1，它是根据其他几个参数计算出阈值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((100 - MinHeapFreeRatio) + (double)(CMSTriggerRatio * MinHeapFreeRatio) / 100.0)</span><br></pre></td></tr></table></figure><p>注意上述参数需要设置开启 <code>-XX:+UseCMSInitiatingOccupancyOnly</code> 参数才可以生效</p></li></ul><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><ul><li>通过在线工具gceasy分析GC日志，初步判断是否存在gc问题或者内存问题</li><li>本地jmeter压测重现并查看吞吐量和响应时间，再次分析GC日志，通过visualvm连接本地服务查看内存情况</li><li>通过jmap或者arthas将堆内存快照存储，可以通过在线工具heaphero或者mat分析内存问题</li><li>修复问题测试，并发布到测试环境进行测试</li></ul><p>注意事项</p><ul><li>在并发压力比较大的服务中，尽量不要存放大量的缓存或者定时任务，会影响服务的内存使用</li><li>内存分析时，可以通过导出线程栈的方式来查看线程的运行情况，辅助定位到内存问题</li></ul><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>应用程序在运行过程中常见的性能问题有：</p><ul><li>cpu占用率高 - 通过 top 命令查看</li><li>单个请求服务处理时间过长 - 使用 skywalking 监控系统链路</li><li>在内存和cpu正常的情况下，应用程序无法处理任何请求即出现了”假死” - 线程耗尽</li></ul><h3 id="发现问题-2"><a href="#发现问题-2" class="headerlink" title="发现问题"></a>发现问题</h3><ul><li><p>线程转储文件 - Thread Dump </p><p>线程存储提供了所有运行中的线程当前状态的快照。可以通过 jstack 和 visualvm 等工具获取，这份快照包含了 线程名、 线程ID、线程优先级、线程状态、线程栈信息等等内容。通过线程存储文件可以定位解决 CPU占用率高 、死锁等问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack &lt;PID&gt; &gt; /xx/xxx.tdump</span><br></pre></td></tr></table></figure><p>本地测试环境可以使用 visualvm 连接后，点击 Threads 的 Thread Dump 生成线程转储文件</p><p><img src="https://s2.loli.net/2024/01/15/8CZHJiYBMOaoXV2.png" alt="image-20240115084521764"></p><p>线程转储文件的几个核心内容如下：</p><ul><li>线程名称</li><li>优先级 - prio：线程的优先级（优先级越高，更容易获得cpu的时间片，由操作系统的调度算法决定）</li><li>java id - tid：jvm中线程的唯一id</li><li>本地ID - nid：操作系统中线程的唯一id</li><li>状态 - state：线程的状态<ul><li>NEW - 新创建的线程，尚未开始执行</li><li>RUNNABLE - 正在运行或者准备执行</li><li>BLOCKED - 阻塞等待锁</li><li>WAITING - 无限期等待</li><li>TIME_WAITING - 限期等待</li><li>TERMINATED - 已完成执行</li></ul></li><li>栈追踪：显示栈帧信息</li></ul><p><img src="https://s2.loli.net/2024/01/15/LBqPK6Hu2gpOj7W.png" alt="image-20240115090043861"></p><p>线程转储文件可视化在线分析平台：<a href="https://jstack.review/">jstack</a>，<a href="https://fastthread.io/">fastthread</a></p></li></ul><h3 id="诊断问题-1"><a href="#诊断问题-1" class="headerlink" title="诊断问题"></a>诊断问题</h3><h4 id="cpu占用率高"><a href="#cpu占用率高" class="headerlink" title="cpu占用率高"></a>cpu占用率高</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top -c # 通过 top -c 找到cpu占用率高的进程和显示完整的命令行信息 获取&lt;PID&gt;进程ID</span><br><span class="line">top -H -p &lt;PID&gt;  # -H 以 线程 的方式显示进程</span><br><span class="line">| ps -fT -p &lt;PID&gt; </span><br><span class="line">printf &#x27;%x/n&#x27; &lt;tid&gt; # 将10进制表示的线程号转换为16进制的表示的线程号 - 操作系统的线程ID nid</span><br><span class="line">jstack &lt;PID&gt; &gt; /xx/xxx.tdump # 在线程存储文件中，找到nid相同的线程，查看线程基本信息和线程栈帧信息</span><br></pre></td></tr></table></figure><h4 id="服务接口响应时间长"><a href="#服务接口响应时间长" class="headerlink" title="服务接口响应时间长"></a>服务接口响应时间长</h4><p>服务接口响应过长说明该接口方法出现了性能问题，这些方法往往调用嵌套比较多，需要具体定位到哪一个调用方法出现了问题。</p><p>可以通过 arthas的<a href="https://arthas.aliyun.com/doc/trace.html">trace</a>命令 定位具体的方法</p><blockquote><p>arthas trace命令：方法内部调用路径，并输出方法路径上的每个节点上耗时</p><p>使用方法：trace 类权限定名 方法名</p><p>参数：</p><ul><li><p>–skipJDKMethod false </p><p>输出jdk核心包中的方法以及耗时 默认true 即无需输出jdk核心包中的方法以及耗时</p></li><li><p>‘#cost &gt; <millisecond> ‘</p><p>只显示耗时超过该毫秒值的调用</p></li><li><p>-n 数值 </p><p>最多显示该数值条数的数据</p></li></ul><p>监控结束后，使用stop结束监控：arthas 底层使用动态代理的方法，增强这些对象，从而获取接口的调用时间，这会增加方法调用的开销，降低性能。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace xx.xx.xxx.SimpleClass methodName --skipJDKMethod false &#x27;#cost &gt; &lt;millisecond&gt;&#x27; -n 1</span><br></pre></td></tr></table></figure><p>可以通过 arthas的<a href="https://arthas.aliyun.com/doc/watch.html">watch</a>命令 观测 调用方法的参数和返回值</p><blockquote><p>当定位到具体的方法后，可以使用 watch 查看函数执行数据观测即查看方法的参数和返回值。方便在本地测试时，模拟参数进行重现。</p><p>使用方法：watch 类权限定名 方法名 ‘{params, returnObj}’ ‘cost&gt;毫秒值’ -x 2</p><p>参数：</p><ul><li>‘{params, returnObj}’ ：打印出参数和返回值</li><li>-x 2：方法嵌套最多展开两层，允许设置的最大值为4</li></ul><p>监控结束后，使用stop结束监控</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch xx.xx.xxx.SimpleClass methodName &#x27;&#123;params, returnObj&#125;&#x27; -x 2</span><br></pre></td></tr></table></figure><p>此外 arthas的 <a href="https://fastthread.io/">profiler</a>命令 提供了性能火焰图的功能，可以直观的显示所有方法的执行时间</p><blockquote><p>arthas的 <a href="https://fastthread.io/">profiler</a>命令 提供了性能火焰图的功能</p><p>使用方法：profiler start # 开始监控方法执行性能</p><p>​    profiler stop –format html # 结束监控方法并以html方式生成性能火焰图</p><p>火焰图分布：绿色 - java中的栈 红色 - jdk底层的方法调用</p></blockquote><h4 id="线程耗尽"><a href="#线程耗尽" class="headerlink" title="线程耗尽"></a>线程耗尽</h4><p>在内存和cpu正常的情况下，应用程序无法处理任何请求即出现了”假死”，程序进行重启后，依然出现了出现的相同的情况。这是典型的线程被耗尽的问题。</p><blockquote><p>线程被耗尽的问题，一般由执行时间过长导致的：</p><ul><li>死锁情况：两个及以上的线程争夺资源造成了互相等待的情况，无法自动解除的死锁的线程将一直阻塞下去<ul><li>解决方式：检测是否有死锁的情况发生</li></ul></li><li>慢方法情况：大量执行某一个慢方法<ul><li>生成线程转储文件查看是否调用某慢方法</li></ul></li></ul></blockquote><h5 id="线程死锁问题定位"><a href="#线程死锁问题定位" class="headerlink" title="线程死锁问题定位"></a>线程死锁问题定位</h5><ul><li><p>使用 <code>jstack -l &lt;pid&gt;</code> 打印出线程的信息（-l : 包含锁的信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l &lt;PID&gt; &gt; /xx/xxx.tdump</span><br></pre></td></tr></table></figure><p>转储到文件后，搜索文件中的 <code>deadlock</code> 找到死锁的位置</p><p><img src="https://s2.loli.net/2024/01/15/nZyfaFJP681ovRU.png" alt="image-20240115134009582"></p></li><li><p>开发环境可以使用visualvm或者jconsole工具检测死锁</p><p><img src="https://s2.loli.net/2024/01/15/vfnsihFNmISzaKZ.png" alt="image-20240115134211547"></p></li><li><p>可是使用 在线分析网站 <a href="https://fastthread.io/">fastthread</a> 中的 dead lock 查看死锁情况</p></li></ul><h3 id="基准测试框架JMH"><a href="#基准测试框架JMH" class="headerlink" title="基准测试框架JMH"></a>基准测试框架JMH</h3><p>如何判断一个方法的耗时时间是多少？</p><p>接口的响应时间一般可以定义切面统计方法的执行时间，调用接口查看接口的响应时间，或者使用arthas的trace命令查看方法执行时间。但是这些很多因素影响导致结果不准确，这些因素包括对象的<strong>懒加载</strong>机制导致第一次请求时间不准确，虚拟机的<strong>JIT即时编译器</strong>优化导致方法性能得到优化等。</p><h4 id="JMH简介"><a href="#JMH简介" class="headerlink" title="JMH简介"></a>JMH简介</h4><blockquote><p>OpenJDK 提供了一种叫 <a href="https://github.com/openjdk/jmh">JMH</a>（Java Microbenchmark Harness） 的工具，可以准确对于 java 代码进行行基准测试 ，量化方法的执行性能。</p></blockquote><p>JMH 首先会对方法进行预热，确保JIT对于代码进行了优化之后，才开始真正的迭代测试，并</p><p>量化方法的执行性能，输出最后的结果。</p><h4 id="JMH的使用"><a href="#JMH的使用" class="headerlink" title="JMH的使用"></a>JMH的使用</h4><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建基准测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Warmup(iterations = 5, time = 1)</span> <span class="comment">// 预热：iterations次数 time时间</span></span><br><span class="line"><span class="meta">@Fork(value = 1, jvmArgsAppedn = &#123;&quot;-Xms1g&quot;, &quot;-Xmx1g&quot;)</span> <span class="comment">// 启动进程数量配置</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span> <span class="comment">// 显示结果：平均时间</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span> <span class="comment">// 显示结果单位</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span> <span class="comment">// 变量共享范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Benchmark</span>  <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTestMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Your code to be benchmarked</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">          .include(MyBenchmark.class.getSimpleName())</span><br><span class="line">          .forks(<span class="number">1</span>)</span><br><span class="line">          .resultFormat(ResultFormatType.JSON) <span class="comment">// 结果生成json格式文件</span></span><br><span class="line">          .build();</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Runner</span>(opts).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果可以通过 <a href="https://jmh.morethan.io/">JMH Visualizer</a> 在线分析</p><img src="https://s2.loli.net/2024/01/15/eiVuANYPGtphFLr.png" alt="image-20240115153857103" style="zoom: 50%;" /> ]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm-实战&quot;&gt;&lt;a href=&quot;#jvm-实战&quot; class=&quot;headerlink&quot; title=&quot;jvm 实战&quot;&gt;&lt;/a&gt;jvm 实战&lt;/h1&gt;&lt;h2 id=&quot;内存调优&quot;&gt;&lt;a href=&quot;#内存调优&quot; class=&quot;headerlink&quot; title=&quot;内</summary>
      
    
    
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/12/28/jvm-5-%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2023/12/28/jvm-5-%E9%9D%A2%E8%AF%95/</id>
    <published>2023-12-28T07:53:16.603Z</published>
    <updated>2024-01-26T12:37:29.409Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>jvm 基础</title>
    <link href="http://example.com/2023/12/28/jvm-1-%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/12/28/jvm-1-%E5%9F%BA%E7%A1%80/</id>
    <published>2023-12-27T16:00:00.000Z</published>
    <updated>2024-03-07T08:21:19.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm-基础"><a href="#jvm-基础" class="headerlink" title="jvm 基础"></a>jvm 基础</h1><h2 id="初始jvm"><a href="#初始jvm" class="headerlink" title="初始jvm"></a>初始jvm</h2><h3 id="jvm职责"><a href="#jvm职责" class="headerlink" title="jvm职责"></a>jvm职责</h3><blockquote><p>jvm - java virtual machine 即 java虚拟机，是 经过java编译器（javac）编译后的 java程序 的运行环境。</p><p>jvm 是运行在计算机上的程序，他是运行 java字节码的程序，他的职责是运行即将 已经经过java编译器（javac）编译的字节码文件（.class文件）进行加载和执行时解释，执行时通过JIT（just-in-time compilation - 即时编译技术）将字节码解释成机器码，以便于计算机能够理解和执行。</p></blockquote><p>在正常项目过程中，我们会先将java工程编译并打包成jar文件（jar即是包含经过编译后的字节码，资源文件以及相关文件的打包在一起的一种文件格式），jar部署在jvm虚拟机上运行，由于jvm部署所在的计算机无法直接执行字节码（字节码是由一组针对jvm设计的指令构成 - 虚拟机指令），所以jvm需要加载并通过JIT即时编译技术将字节码解释成机器码，交给计算机理解和执行。</p><p>因此，java程序不能直接在计算机上运行的，而是编译后通过jvm加载并执行。</p><img src="https://s2.loli.net/2023/12/28/krslc3HymnoNvdK.png" alt="image-20231228163553436" style="zoom: 33%;" /><p>正是因为 针对不同程序的不同编译器所编译成的相同字节码文件 和 针对不同操作系统的jvm的加载和解释 使得java程序具有跨平台性即可以在不同的操作系统上运行。</p><img src="https://s2.loli.net/2023/12/28/vWS4grG7C3no5kR.png" alt="image-20231228163900743" style="zoom: 33%;" /><h3 id="jvm功能"><a href="#jvm功能" class="headerlink" title="jvm功能"></a>jvm功能</h3><p>上文，我们知道jvm的功能之一就是：</p><ul><li>加载字节码文件的指令并实时解释成机器码交给计算机执行（解释过程支持通过JIT即时编译进行优化，提升热点代码的执行效率）</li></ul><p>其他功能还有：</p><ul><li>自动为对象和方法等分配内存，并配合垃圾回收机制回收不再使用的对象</li></ul><h3 id="java-vs-c"><a href="#java-vs-c" class="headerlink" title="java vs c"></a>java vs c</h3><p>由于java程序需要编译后成字节码（.class）通过jvm加载并实时解释，解释成计算机可以执行的机器码才可以执行；而c程序可以直接编译为计算机可以直接执行的可执行文件(.exe)，即c程序无需加载和解释，c程序的性能要高于java程序。</p><p>但是java之所以保持编译字节码和jvm解释的特性，主要目的是支持跨平台，”一次编译，随处运行”。</p><h3 id="jit-即时编译"><a href="#jit-即时编译" class="headerlink" title="jit - 即时编译"></a>jit - 即时编译</h3><p>由于 java 在性能上的不足主要是由于 jvm解释 的过程导致的，java 后面引入了 jit （just-in-time compilation - 即时编译技术)：</p><p>jvm对于热点字节码进行解释并优化成机器码，并将这个机器码保存在内存中，当再此执行时直接从内存中加载出来直接交给计算机执行，从而节省了对于热点代码解释的工作，大幅度提升了java程序的性能。</p><img src="https://s2.loli.net/2023/12/29/AsgvBqfx7dC2eRl.png" alt="image-20231228170508653" style="zoom: 33%;" /><h3 id="常见的jvm"><a href="#常见的jvm" class="headerlink" title="常见的jvm"></a>常见的jvm</h3><img src="https://s2.loli.net/2023/12/29/Mp5Z7HYwF1sWS6L.png" alt="image-20231228171714480" style="zoom: 50%;" /><p>jvm有很多但是都要满足《<a href="https://docs.oracle.com/javase/specs/index.html">java虚拟机规范</a>》</p><p>上述虚拟机中，jdk默认的虚拟机是Hotspot - Oracle JDK，它是目前应用最广泛、稳定可靠的虚拟机。</p><h4 id="Hotspot-发展历程"><a href="#Hotspot-发展历程" class="headerlink" title="Hotspot 发展历程"></a>Hotspot 发展历程</h4><img src="https://s2.loli.net/2023/12/28/4FjVDeOXMlBTiZS.png" alt="image-20231228172947817" style="zoom:50%;" /><h3 id="jvm-组成"><a href="#jvm-组成" class="headerlink" title="jvm 组成"></a>jvm 组成</h3><ul><li>类加载器 - class loader：<ul><li>功能：负责将 java字节码 加载到 jvm内存 中</li><li>分类：jvm类加载器分为三个层次：启动类加载器（bootstrap class loader）、扩展类加载器（extension class loader）和 应用程序类加载器（application class loader）</li></ul></li><li>运行时数据区 - runtime data area：<ul><li>功能：负责 管理分配给jvm的内存，存储和管理程序运行时所需要的数据</li><li>主要区域：<ul><li>方法区 - method area：存储类的结构信息，包括类的字段、方法、接口等</li><li>本地方法栈 - native method stack：执行本地方法</li><li>堆 - heap：存储对象实例</li><li>栈 - stack：存储局部变量、操作数栈、方法出口等</li><li>程序计数器 - program counter register：记录当前线程执行的字节码行号</li></ul></li></ul></li><li>执行引擎 - execution engine：<ul><li>功能：执行编译后的字节码<ul><li>主要组件：<ul><li>解释器 - interpreter：逐行解析字节码并执行</li><li>即时编译器 - just-in-time compiler（JIT compiler）：提供字节码即时编译，提高执行效率</li></ul></li></ul></li></ul></li><li>本地接口 - native interface：<ul><li>功能：提供与本地库（如：c/c++）交互的接口或者方法，允许java代码调用    </li><li>例如：jvm 提供的c/c++方法</li></ul></li></ul><h2 id="字节码文件"><a href="#字节码文件" class="headerlink" title="字节码文件"></a>字节码文件</h2><h3 id="字节码文件定义"><a href="#字节码文件定义" class="headerlink" title="字节码文件定义"></a>字节码文件定义</h3><blockquote><p>字节码文件（.class 文件）是 源代码 经过编译之后的内容，是一个以8位字节为基础单位的二进制流即通过 二进制 方式存储。由于 并没有指定字符编码方式，所以无法直接通过记事本等工具打开。</p></blockquote><p>我们可以使用 <a href="https://github.com/ingokegel/jclasslib/releases">jclasslib</a> 打开字节码文件</p><h3 id="字节码文件的组成"><a href="#字节码文件的组成" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h3><ul><li><p>基础信息：</p><ul><li><p>魔数 - Magic Number</p><ul><li><p>定义：每个class文件开头的4个字节（OxCAFEBABE）成为魔数 </p><p>​     由于文件名是可以随意修改的（但不会影响文件的内容），因此文件是无法通过文件扩展名来确定文件类型的。</p><p>​     因此魔术用于校验文件的类型，很多类型的文件都有自己对应的”魔术”</p></li><li><p>作用：确定文件是一个java编译后的class文件 即识别一个文件是否为特定的类型</p></li></ul></li><li><p>文件版本：</p><ul><li>定义：紧随着魔数的4个字节为 编译字节码文件 对应的jdk版本号，包括类主版本号和次版本号</li><li>作用：判断字节码文件的版本和运行时的版本是否兼容（jdk版本是向后的兼容，低版本无法加载运行高版本的字节码文件）</li></ul></li><li><p>访问标识 - Access Flags：</p><ul><li>定义：标识文件是类、接口还是枚举等，以及他的属性和访问类型</li></ul></li><li><p>类、父类、接口索引：</p><ul><li>定义：表示当前类、父类和实现接口在常量池中的索引</li><li>作用：确定类的继承关系</li></ul></li></ul></li><li><p>常量池 - Constant Pool：</p><ul><li><p>定义：常量池是一个表，存储了各种字面量和符号引用。它包括类名、方法名、字段名等信息。</p><p>​     常量池的索引从1开始，0被保留用于表示不引用任何常量。</p></li><li><p>作用：节省字节码文件部分空间，避免相同的内容重复定义，而只需要引用常量池中的内容</p></li></ul></li><li><p>字段表 - Field Table：</p><ul><li>作用：描述接口和类中声明的字段的名称、类型和访问修饰符等信息</li></ul></li><li><p>方法表 - Method Table：</p><ul><li>作用：描述接口和类中声明的方法的名称、类型、访问修饰符以及方法信息等</li></ul></li><li><p>属性表 - Attribute Table：</p><ul><li>作用：描述类、字段或方法等附加信息</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面以一个简单的例子来展示一下字节码文件的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleClass.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 javac 生成 字节码文件 SimpleClass.class</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac SimpleClass.java</span><br></pre></td></tr></table></figure><p>打卡生成的class文件</p><img src="https://s2.loli.net/2023/12/29/crV2UHXFJ5WmNqR.png" alt="image-20231229131338804" style="zoom: 50%;" /><p>前4个字节（OxCAFEBABE）是 魔数，jvm判断并接受以”caff babe”开头的class文件，这四个字节的作用即字节码的身份识别。</p><p>紧接着的4个字节为编译器jdk的版本号，前2位（0x0000）是次版本号，后2位（0x0040）为主版本号，将0x0040转换为十进制为64，所以字节码文件编译器的jdk版本为20（64-44）。</p><p>使用 jclasslib 打开该字节码文件</p><h5 id="一般信息"><a href="#一般信息" class="headerlink" title="一般信息"></a>一般信息</h5><img src="https://s2.loli.net/2023/12/29/RoU8PSs9kgyNjOE.png" alt="image-20231229131543978" style="zoom:33%;" /><h5 id="常量池引用"><a href="#常量池引用" class="headerlink" title="常量池引用"></a>常量池引用</h5><p>字段信息 引用常量池中的内容</p><p>常量池中放数据都有一个编号，编号从1开始。在指令中，可以通过编号快速找到引用的相应数据。</p><p>字节码指令可以通过编号引用到常量池的内容称之为 符号引用</p><img src="https://s2.loli.net/2023/12/29/1KAFIjflmbVaQcJ.png" alt="image-20231229132120760" style="zoom:33%;" /><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>字节码文件的方法区存放了方法字节码指令</p><img src="https://s2.loli.net/2023/12/29/yVUaSgxRTWPrd2f.png" alt="image-20231229133815275" style="zoom:33%;" /><h4 id="字节码指令执行分析"><a href="#字节码指令执行分析" class="headerlink" title="字节码指令执行分析"></a>字节码指令执行分析</h4><p>在理解字节码指令的流程，我们需要分析一下两个在jvm执行时相关的重要的概念：操作数栈（operand stack）和 局部变量表（local variable table）</p><p>操作数栈(栈)：用于存储方法执行过程中的操作数。各种指令将操作数压入或弹出操作数栈并进行相应的运算操作。</p><img src="https://s2.loli.net/2023/12/29/oWnQwxIMym7c8tF.png" alt="image-20231229142811892" style="zoom: 50%;" /><p>局部变量表(数组)：用于存储方法中方法参数和方法定义的局部变量的表，每个方法执行前都会创建一个局部变量表。</p><p>​        当一个方法被调用时，方法的参数将被传递给局部变量表中的相应位置，并且方法内部的局部变量也会在表中占据一定的位置，供方法执行过程中使用。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>下面的代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量表如下：</p><img src="https://s2.loli.net/2023/12/29/eJb7BEvAXOcdCSD.png" alt="image-20231229141933896" style="zoom:33%;" /><p>上面代码的字节码指令如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_0 # 将整数常量<span class="number">0</span>推送到操作数栈</span><br><span class="line"><span class="number">1</span> istore_1 # 从操作数栈弹出值，放入局部变量表位置<span class="number">1</span></span><br><span class="line"><span class="number">2</span> iload_1 # 局部变量表的位置<span class="number">1</span>加载整数值到操作数栈</span><br><span class="line"><span class="number">3</span> iconst_1 # 将整数常量<span class="number">1</span>推送到操作数栈</span><br><span class="line"><span class="number">4</span> iadd # 操作数栈栈顶弹出两个整数，相加，将结果推送回栈</span><br><span class="line"><span class="number">5</span> istore_2 # 从操作数栈弹出值，存储到局部变量表的位置<span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span> # 从当前方法返回，方法返回值在栈顶</span><br></pre></td></tr></table></figure><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  i = i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是i最终的赋值为0，下面从字节码指令的执行过程分析一下为什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_0 # 将整数常量<span class="number">0</span>推送到操作数栈</span><br><span class="line"><span class="number">1</span> istore_1 # 从操作数栈弹出值，存储到局部变量表的位置<span class="number">1</span></span><br><span class="line"><span class="number">2</span> iload_1 # 从局部变量表的位置<span class="number">1</span>加载整数值到操作数栈</span><br><span class="line"><span class="number">3</span> iinc <span class="number">1</span> by <span class="number">1</span> # 局部变量表的位置<span class="number">1</span>中的整数值增加<span class="number">1</span> </span><br><span class="line"><span class="number">6</span> istore_1 # 从操作数栈弹出值，存储到局部变量表的位置<span class="number">1</span> (此处和上一步是关键)</span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>局部变量表的位置1的整数直接加1，操作栈的数保持不变直接弹出存储到局部变量表位置1中，覆盖掉了自增后的值</p><p>对比 i = ++i 的指令，指令是先自增再加载到操作栈中，因此i等于1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_0</span><br><span class="line"><span class="number">1</span> istore_1</span><br><span class="line"><span class="number">2</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">5</span> iload_1</span><br><span class="line"><span class="number">6</span> istore_1</span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="字节码文件常见的工具"><a href="#字节码文件常见的工具" class="headerlink" title="字节码文件常见的工具"></a>字节码文件常见的工具</h3><p>除了上文提到了 jclasslib 工具外，还有很多工具可以查看并分析字节码文件，它们的适用场景各不相同。</p><h4 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h4><blockquote><p>javap 的 jdk 内置的反编译工具，可以反编译字节码文件并通过控制台查看字节码文件的内容。</p><p>语法：javap <options> <classes></p><p>适用：适合在服务器上查看字节码文件内容</p></blockquote><p>options 的选项如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--help -help -h -?               输出此帮助消息</span><br><span class="line">-version                         版本信息</span><br><span class="line">-v  -verbose                     输出附加信息</span><br><span class="line">-l                               输出行号和本地变量表</span><br><span class="line">-public                          仅显示公共类和成员</span><br><span class="line">-protected                       显示受保护的/公共类和成员</span><br><span class="line">-package                         显示程序包/受保护的/公共类</span><br><span class="line">                                 和成员 (默认)</span><br><span class="line">-p  -private                     显示所有类和成员</span><br><span class="line">-c                               对代码进行反汇编</span><br><span class="line">-s                               输出内部类型签名</span><br><span class="line">-sysinfo                         显示正在处理的类的</span><br><span class="line">                                 系统信息（路径、大小、日期、SHA-256 散列）</span><br><span class="line">-constants                       显示最终常量</span><br><span class="line">--module &lt;module&gt;  -m &lt;module&gt;   指定包含要反汇编的类的模块</span><br><span class="line">-J&lt;vm-option&gt;                    指定 VM 选项</span><br><span class="line">--module-path &lt;路径&gt;             指定查找应用程序模块的位置</span><br><span class="line">--system &lt;jdk&gt;                   指定查找系统模块的位置</span><br><span class="line">--class-path &lt;路径&gt;              指定查找用户类文件的位置</span><br><span class="line">-classpath &lt;路径&gt;                指定查找用户类文件的位置</span><br><span class="line">-cp &lt;路径&gt;                       指定查找用户类文件的位置</span><br><span class="line">-bootclasspath &lt;路径&gt;            覆盖引导类文件的位置</span><br><span class="line">--multi-release &lt;version&gt;        指定要在多发行版 JAR 文件中使用的版本</span><br></pre></td></tr></table></figure><p>常见用法：</p><p>到服务器的指定jar包路径下，执行<code>jar -xvf</code>命令解压jar包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -xvf xx.jar</span><br></pre></td></tr></table></figure><p>执行解压后，会生成一个<code>BOOT_INF</code>目录，执行javap查看字节码信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p xx</span><br></pre></td></tr></table></figure><p>在终端控制台可能查看的效果不好，可以直接将展示的信息写入到txt文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p xx &gt; /xx/xx.txt</span><br></pre></td></tr></table></figure><h4 id="IDEA插件jclasslib"><a href="#IDEA插件jclasslib" class="headerlink" title="IDEA插件jclasslib"></a>IDEA插件jclasslib</h4><p>搜索安装插件后，编译代码，选中当前类，点击 视图 - Show Bytecode With Jclasslib 来查看该类编译后的字节码显示面板</p><img src="https://s2.loli.net/2023/12/29/l4wiEW1AFfpv5Nr.png" alt="image-20231229154246747" style="zoom:50%;" /><h4 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h4><p>上述工具都是根据源代码编译后的字节码文件，来查看字节码文件的信息，而如果只有正在运行的程序，如何查看字节码的信息？</p><blockquote><p><a href="https://arthas.aliyun.com/doc/">Arthas</a> 是一款 线上java应用 性能监控和诊断工具，可以全局实时的查看应用负载，内存清空，垃圾回收，线程状态等信息。</p><p>在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p></blockquote><h5 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h5><p>下载<code>arthas-boot.jar</code>，然后用<code>java -jar</code>的方式启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><h5 id="功能概览"><a href="#功能概览" class="headerlink" title="功能概览"></a>功能概览</h5><p>相关命令教程可以查看地址：<a href="https://arthas.aliyun.com/doc/commands.html">https://arthas.aliyun.com/doc/commands.html</a></p><img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20231229164553637.png" alt="image-20231229164553637" style="zoom:50%;" /><p>本章主要介绍如何查看字节码信息：</p><h5 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h5><blockquote><p>dump 已加载类的字节码文件(到特定目录 - 可选)</p></blockquote><p>参数：</p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td>class-pattern</td><td>类名表达式匹配</td></tr><tr><td>-c</td><td>类所属 ClassLoader 的 hashcode</td></tr><tr><td>-classLoaderClass</td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td>-d</td><td>设置类文件的目标目录</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -d /xxx/xxx class-pattern</span><br></pre></td></tr></table></figure><h5 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h5><blockquote><p>dump 反编译指定已加载类的源码</p><p>适用于 查看线上应用的源代码</p></blockquote><table><thead><tr><th><strong>参数名称</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td>class-pattern</td><td>类名表达式匹配</td></tr><tr><td>-c</td><td>类所属 ClassLoader 的 hashcode</td></tr><tr><td>-classLoaderClass</td><td>指定执行表达式的 ClassLoader 的 class name</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad class-pattern</span><br></pre></td></tr></table></figure><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><blockquote><p>类的生命周期描述了一个类从加载到虚拟机的内存、到使用、最后到卸载出内存的整个过程。 </p><p>掌握类的生命周期可以更好地理解和优化执行的过程，是后续很多知识点的基础。类加载器的作用、运行时常量池、多态、类的加密和解密 与 类的生命周期都有密不可分的关联</p></blockquote><p>类的生命周期会经历 加载（Loading） - 连接（Linking） - 初始化（Initialization） - 使用（Using）- 卸载（Unloading），其中 连接 包含了三个部分分别是 验证（Verification）、准备（Preparation）和解析（Resolution）。</p><img src="https://s2.loli.net/2023/12/29/sVG6veTqf1RXDWO.png" alt="image-20231229215507721" style="zoom: 50%;" /><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote><p>加载阶段是类的生命周期的第一阶段</p><p>主要是将类的字节码从磁盘或其他介质加载到内存中，并为之创建一个 <code>java.lang.Class</code> 类的实例。</p></blockquote><ul><li>类加载器通过一个类的全限定名从磁盘、其他介质等中获取类字节码文件（二进制字节流）</li><li>jvm 将 字节码加载到内存中，并生成一个表示类信息的数据结构InstanceKlass 存储在 方法区 中<ul><li>InstanceKlass 保持了类信息的基本信息、字段、方法等以及实现特定功能的信息（例如：实现多态的虚方法表）</li></ul></li><li>在 jvm 的堆中的创建一个 <code>java.lang.Class</code> 类的实例，作为对方法区类信息的访问入口<ul><li><code>java.lang.Class</code> 类是 jvm 运行时自动创建和维护的，代表一个类的元数据信息，是在 java 层面上对类信息的一种抽象表示，包含了描述类的各种信息，可以用于获取类的字段、方法、构造器等信息。</li></ul></li></ul><img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20231230160545240.png" alt="image-20231230160545240" style="zoom:33%;" /><h5 id="java-lang-Class类的实例"><a href="#java-lang-Class类的实例" class="headerlink" title="java.lang.Class类的实例"></a>java.lang.Class类的实例</h5><blockquote><p>为什么在堆中保存 <code>java.lang.Class</code> 类的实例？</p><ul><li>java 语言层面访问：java.lang.Class 类提供了一些 java 语言层面操作类信息的方法<ul><li>例如获取类的名称，获取父类，获取实现的接口等，这些方法是通过 java.lang.Class 类提供的，而不是通过 InstanceKlass 类</li></ul></li><li>反射：java 的反射机制就是基于 <code>java.lang.Class</code> 类实现的。通过反射可以在运行时获取并操作类的信息，创建类的实例、调用方法等。</li><li>动态代理： 动态代理也是基于 <code>java.lang.Class</code> 实现的。通过 <code>Proxy.newProxyInstance</code> 方法，可以动态地生成代理类，并在运行时处理代理类的方法调用。</li></ul><p>总结：虽然 InstanceKlass 在虚拟机层面保存了类的底层信息（c语言），用于虚拟机层面管理类的信息，但 <code>java.lang.Class</code> 对象提供了更高层次的抽象，使得开发者可以更方便地在 java 代码中访问和操作类的信息，以便实例化对象和访问类的成员变量等。</p></blockquote><p>如何在代码层面获取 Class 对象即 java.lang.Class 类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 使用.class字面常量</span><br><span class="line">Class&lt;?&gt; clazz = xxClass.class;</span><br><span class="line"></span><br><span class="line"># 使用 Class.forName 方法</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.xxClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用对象的 getClass 方法</span><br><span class="line"><span class="type">XxClass</span> <span class="variable">classObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxClass</span>();</span><br><span class="line">Class&lt;?&gt; clazz = classObj.getClass();</span><br></pre></td></tr></table></figure><p><code>java.lang.Class</code> 类的实例 和 new 构建的对象实例不同：</p><p>java.lang.Class 是 jvm 运行时自动创建和维护的，代表一个类的元数据信息，是在  java 层面上对类信息的一种抽象表示，而 new 构建的对象实例是在堆内存中为该类创建一个对象的实例，代表着类的一个具体对象，使用 <code>new</code> 关键字创建对象，都会在堆内存中分配一块新的内存空间，实例相互独立；</p><p><code>java.lang.Class</code> 实例通常不会被垃圾回收，一旦创建，它就会一直存在于应用的生命周期中，直到应用结束。而 new 的对象实例在堆内存中分配，它的生命周期和引用情况有关，当对象不再被引用了就会变成一个不可达对象，在垃圾回收机制中成为一个潜在可回收的对象。</p><h5 id="查看jvm内存结构"><a href="#查看jvm内存结构" class="headerlink" title="查看jvm内存结构"></a>查看jvm内存结构</h5><blockquote><p>jdk 自带的hsdb工具 可以查看 jvm内存信息，工具位于 jdk 安装目录下的lib文件夹中的 sa-jdi.jar 中</p></blockquote><p>启动命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp sa-jdi.jar sun.jvm.hotspot.HSDB # -cp 指定HSDB为启动类</span><br></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><blockquote><p>连接（Linking）阶段包含了三个部分分别是 验证（Verification）、准备（Preparation）和解析（Resolution）。</p></blockquote><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><blockquote><p>验证（Verification）：检测类的字节码文件是否合法以及符合《java虚拟机的规范》来确保字节码的安全性和正确性。目的是确保jvm能够安全地执行这些类的字节码，防止恶意代码和非法字节码的执行。</p></blockquote><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><blockquote><p>准备（Preparation）：jvm 为类的静态变量分配内存并为设置初始值。这里的初始值为一个初始默认值（初始赋值是在初始化时进行赋值），通常是数据类型的零值，如零、null、false等。</p></blockquote><p>假设一个类的静态变量定义为 public static int value = 1; 在准备阶段后，初始值为0，这时候尚未执行任何java方法，把value赋值为1的会在初始化才会执行（赋值的put static指令在程序编译后存放在类构造器<code>&lt;clinit&gt;()</code>方法之中）</p><p>注意 <strong>final</strong> 修饰的<strong>基本数据类型的静态变量</strong>，在准备阶段会分配内存并进行赋值。final 表示一个常量时候，一旦赋值就不能被修改。在准备阶段就被确定，并且在后续的初始化阶段不会再改变。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><blockquote><p>解析（Resolution）：将类、字段、方法等符号引用解析为直接引用的过程。直接引用不再使用编号，而是使用内存地址引用，以便jvm更高效的执行。</p></blockquote><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>jvm 执行类的初始化代码，为静态变量正确的赋值并执行静态代码块。</p><p>初始化阶段会执行字节码文件中<code>&lt;clinit&gt;()</code>部分的字节码指令。</p><p>类初始化是一个线程安全的操作，多个线程同时尝试初始化同一个类时，只有一个线程会执行初始化过程，其他线程会等待初始化完成。</p><p>初始化阶段的执行是有序的，按照类加载的顺序依次执行。</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        value = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20231231014601030.png" alt="image-20231231014601030" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_2# 将整数常量<span class="number">2</span>推送到操作数栈</span><br><span class="line"><span class="number">1</span> putstatic #<span class="number">7</span> &lt;SimpleClass.value : I&gt; # 将 栈顶整数（即常量<span class="number">2</span>）存储到SimpleClass类的静态变量value中</span><br><span class="line"><span class="number">4</span> iconst_1 # 将整数常量<span class="number">2</span>推送到操作数栈</span><br><span class="line"><span class="number">5</span> putstatic #<span class="number">7</span> &lt;SimpleClass.value : I&gt; # 将 栈顶整数（即常量<span class="number">1</span>）存储到SimpleClass类的静态变量value中</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span> # 返回，方法执行完毕</span><br></pre></td></tr></table></figure><p>从上面示例中，我们可以看出 初始化阶段时按照类加载的顺序依次执行 即 clinit 方法中的执行顺序与源代码编写顺序一致。</p><h5 id="初始化的触发"><a href="#初始化的触发" class="headerlink" title="初始化的触发"></a>初始化的触发</h5><ul><li>创建类的实例</li></ul><p>通过new关键字创建类的实例时，如果当前类没有被初始化，则会触发类的初始化过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XxClass</span> <span class="variable">xxClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxClass</span>(); </span><br></pre></td></tr></table></figure><ul><li>访问类的静态变量和静态方法（不被final修饰的）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">staticVariable</span> <span class="operator">=</span> MyClass.staticVariable;</span><br><span class="line">MyClass.staticMethod();</span><br></pre></td></tr></table></figure><ul><li>调用 class.forName 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.XxClass&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>执行 <code>main</code> 方法的当前类</li><li>初始化子类会导致会导致父类的初始化（优先初始化父类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass initialization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass initialization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SubClass</span> <span class="variable">subClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(); <span class="comment">// 先触发 SuperClass 类的初始化，再触发 SubClass 类的初始化</span></span><br></pre></td></tr></table></figure><p>添加参数 -XX:+TraceClassLoading 可以打印出加载并初始化的类</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>执行程序代码，创建类的实例</p></blockquote><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><blockquote><p>释放不再被使用的类的内存</p></blockquote><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote><p>类加载器 （classloader）负责将字节码文件（.class文件）加载到内存中。jvm 提供给应用程序实现获取字节码的技术。</p></blockquote><p>在整个加载阶段在通过类加载器将字节码文件加载到内存中后，类加载器会调用本地接口（JNI - java native interface 允许使用java语言调用jvm本地方法 c++编写的方法）来在方法区生成类信息的数据结构InstanceKlass和堆上生成java.lang.Class类的实例。所以类加载器在加载阶段只负责获取字节码并加载到内存中。</p><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><blockquote><p>从java虚拟机的角度出发，类加载器分为两类：jvm底层实现的类加载器和java代码自定义类加载器。</p></blockquote><ul><li><p>jvm 底层实现的类加载器</p><p>源代码位于 jvm 虚拟机的源码中，实现语言和虚拟机底层实现语言一致</p><p>作用：保存程序运行中的类被正确的加载，保证其可靠性。</p></li><li><p>java 代码自定义类加载器</p><p>jdk 中默认提供了多种处理不同介质来源的类加载器，开发者也可以自定义类加载器 以实现特定的加载需求。</p><p>自定义加载器需要继承 <code>ClassLoader</code>类并实现 <code>findClass</code> 方法。</p></li></ul><p>在jdk8及之前的版本中，默认的类加载器包括以下几种：</p><ul><li><p>jvm 底层实现的类加载器</p><ul><li>Bootstrap Class Loader - 启动类加载器：加载java的核心类库</li></ul></li><li><p>java 代码自定义类加载器</p><ul><li>Extension Class Loader - 扩展类加载器：加载java的扩展类库</li><li>Application Class Loader - 应用程序类加载器：加载应用程序中的类</li></ul></li></ul><p>如何查看当前程序远行时的类加载器的详细信息，可以通过 arthas 中的 classloader命令来查看。</p><blockquote><p><a href="https://arthas.aliyun.com/doc/classloader.html">classloader命令</a> 查看 classloader 的继承树，urls，类加载信息。</p></blockquote><img src="https://s2.loli.net/2024/01/01/d8Qwn2hOrmxHegc.png" alt="image-20240101144226364" style="zoom:50%;" /><h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h5><blockquote><p>启动类加载器（Bootstrap ClassLoader）由虚拟机提供，由虚拟机底层实现。</p><p>默认加载jvm安装目录/jre/lib下的类文件。</p><p>由于启动类加载器由jvm底层实现，我们无法通过java源代码xxClass.getClassLoader()和arthas工具直接获取到，所以当为null时，即该类由启动类加载器加载。</p></blockquote><p>如何让启动加载器加载一些开发者扩展的类，用于jdk基础类的扩展：</p><ul><li>将开发者扩展的jar包放入到/jre/lib目录下扩展（不推荐 - 文件名需要满足jvm规范，不满足则不会被加载）</li><li>使用启动参数 -Xbootclasspath:/xx/xx.jar 来扩展。</li></ul><h5 id="扩展加载器和应用加载器"><a href="#扩展加载器和应用加载器" class="headerlink" title="扩展加载器和应用加载器"></a>扩展加载器和应用加载器</h5><p>扩展加载器和应用加载器由jdk提供，使用java语言实现，它们的源码是位于 sun.misc.launcher 中的一个静态内部类，继承自 URLClassloader 以具备通过目录或者指定jar包将字节码文件加载到内存中。</p><p>下图继承关系如下：</p><img src="https://s2.loli.net/2024/01/01/fbKuVcjQeIELmSN.png" alt="image-20240101151806770" style="zoom:50%;" /><p>ClassLoader：抽象类。定义了类加载器的具体行为模式，将字节码文件加载到内存中后通过JNI调用底层的jvm方法来来在方法区生成类信息的数据结构InstanceKlass和堆上生成java.lang.Class类的实例。</p><p>SecureClassLoader：使用证书机制提升类加载器的安全性。</p><p>URLClassLoader：利用URL获取目录下或者执行的jar包进行加载，获取字节码信息。</p><h6 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h6><p>扩展类加载默认加载 jdk 安装目录下的 /jre/lib/ext 下的类文件。</p><p>和上面一样，可以使用启动次数 -Djava.ext.dirs = /xx/xx/ 修改扩展加载器加载的目录位置进行扩展，注意该方法会覆盖掉原始目录，因此可以使用追加的方式进行添加目录(;使用分号分割) -Djava.ext.dirs = /jre/lib/ext/;/xx/xxx/</p><h6 id="应用类加载器"><a href="#应用类加载器" class="headerlink" title="应用类加载器"></a>应用类加载器</h6><p>应用类加载器加载 classpath 下的类文件即加载项目中开发者编写的类和接口文件和第三方jar包类和接口的文件。</p><p>通过 <code>classloader -c hash值</code> 可以查看类加载器的加载目录和文件</p><p><img src="https://s2.loli.net/2024/01/01/ajcfvqngX9AShHR.png" alt="image-20240101154437880"></p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote><p>双亲委派机制（Delegation Model）是Java中类加载器（ClassLoader）的一种工作机制，用于加载Java类和资源。</p><p>它的作用是将类加载的责任委托给父类加载器，从而形成一种层次结构，保证类加载的顺序和一致性。</p><p>简而言之，jvm 中有多个类加载器，双亲委派机制解决了一个类到底由哪一个加载器加载的问题。通过双亲委派机制可以保持类加载的有序性、避免类的冲突、提高安全性并且能够实现类的共享。</p></blockquote><p>双亲委派模式对类加载器定义了层级，如图所示。</p><p><img src="https://s2.loli.net/2024/01/02/GMAbg4ldeJ8Ph3R.png" alt="image-20240102113437845"></p><p>双亲委派机制：当一个类加载器处理类加载任务时，会自低向上的查找类是否加载过，再由顶向下的进行尝试加载。</p><p>当一个类需要加载的时候，首先自低向上委派父类加载器进行检查是否加载过，如果检查加载过，会直接返回class对象，加载过程结束，这样能避免一个类的重复加载。如果未加载过，则由顶向下的进行尝试加载，如果所有父类无法加载该类，则由当前类加载器尝试加载。</p><p>本质上双亲委派机制是起到了一个加载优先级的作用。</p><blockquote><p>可以通过 <code>classloader -t</code> 查看类加载器的层级信息。</p><p><img src="https://s2.loli.net/2024/01/02/pAaOFX5DfqBUdC8.png" alt="image-20240102091656380"></p></blockquote><h5 id="双亲委派机制的作用"><a href="#双亲委派机制的作用" class="headerlink" title="双亲委派机制的作用"></a>双亲委派机制的作用</h5><ul><li><p>保证类加载的安全性</p><ul><li>防止恶意类的加载。java核心类库都只能由被信任的类加载器加载，确保了系统的安全性。</li></ul></li><li><p>避免同一个类的重复加载：</p><ul><li>双亲委派机制通过一层一层的委派，确保了类加载的顺序，防止同一个类被多个类加载器加载，从而避免了类的冲突和混乱。</li><li>当一个类加载器需要加载类时，它首先会委派给其父类加载器去尝试加载。如果父类加载器已经加载了该类，就不会再次加载，避免了重复加载和的性能开销。提高了性能，也保证了类不会冲突和混乱。 </li></ul></li><li><p>确保类的一致性</p><ul><li>同一个类在在整个类加载器层次结构中只有一份，不会出现不同加载器加载同名类导致类型不一致的问题。</li></ul></li></ul><h4 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制"></a>如何打破双亲委派机制</h4><h5 id="为什么要打破双亲委派机制？"><a href="#为什么要打破双亲委派机制？" class="headerlink" title="为什么要打破双亲委派机制？"></a>为什么要打破双亲委派机制？</h5><p>先举例一个场景，在tomcat中运行多个Web应用，如果两个应用中存在相同限定名的类，通常情况下双亲委派机制会导致只有第一个加载的类被使用。</p><p>为了解决这个问题，tomcat使用不同的类加载器实现应用之间类的隔离。每个web应用会有一个自己独立的类加载器加载对应的类。    </p><h5 id="双亲委派机制的实现原理"><a href="#双亲委派机制的实现原理" class="headerlink" title="双亲委派机制的实现原理"></a>双亲委派机制的实现原理</h5><p>要想打破双亲委派机制，首先要了解双亲委派机制的实现。</p><p>查看类加载类的抽象类 Classloader，该类中有4个核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 类加载的入口方法，默认实现会委托给双亲类加载器来完成加载</span><br><span class="line"># 在加载类的过程中，它会调用findClass方法来查找类，并最终调用defineClass方法来定义类</span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name);</span><br><span class="line"></span><br><span class="line"># 用于在类加载器的查找过程中实际定位和加载类的字节码</span><br><span class="line"># 默认的ClassLoader中findClass方法是抽象的，具体实现由子类加载器实现</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name);</span><br><span class="line"></span><br><span class="line"># 校验类名，调用了虚拟机底层方法将类的字节码转换为一个Class对象并加载到虚拟机内存中，</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len);</span><br><span class="line"></span><br><span class="line"># 用于连接并准备类，确保类的正确性</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure><p>查看类加载的入口的方法 loadClass(String)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">   <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 加锁 保证只有一个线程可以加载，避免重复加载和线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">      <span class="comment">// 判断当前类（权限定名）是否被当前类加载器加载过，加载过则返回当前类，否则为空 </span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 如果parent即父类加载器不为空，则委派到父加载器加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果parent为空，则说明当前类为扩展加载器，其父加载器为启动器加载器，委派到启动器加载器加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">              <span class="comment">// 父类加载器都没有加载到，则调用当前类加载器进行加载，在classloader抽象类中，并没有实现findClass的具体逻辑，而是由子类继承类并重写实现方法</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 判断是否执行连接阶段</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="打破双亲委派机制的方式"><a href="#打破双亲委派机制的方式" class="headerlink" title="打破双亲委派机制的方式"></a>打破双亲委派机制的方式</h5><ul><li>自定义类加载器</li></ul><p>查看上面代码查看双亲委派机制的具体实现，因此需要打破双亲委派机制，则需要继承 ClassLoader 类并对于 loadClass 方法进行重新实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 具体实现来获取字节码 byte[] bytes</span></span><br><span class="line">    <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, data.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义加载器如果没有手动设置parent，默认会指向应用程序类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ClassLoader类中提供了构造方法设置parent的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">if</span> (ParallelLoaders.isRegistered(<span class="built_in">this</span>.getClass())) &#123;</span><br><span class="line">            parallelLockMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">            package2certs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">            assertionLock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no finer-grained lock; lock on the classloader instance</span></span><br><span class="line">            parallelLockMap = <span class="literal">null</span>;</span><br><span class="line">            package2certs = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">            assertionLock = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数构造方法，父类加载器由getSystemClassLoader()方法设置，该方法返回的是 appClassLoader</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果在自定义加载器加载相同限定名的类，并不会产生任何冲突，在jvm中，只有相同类加载器和相同类限定名才可以被认定为是同一个类</p><p>使用arthas的 <code>sc -d 类名</code> 查看类的具体的情况</p></blockquote><p>如果不想打破双亲委派机制，从不同的渠道获取类字节码，则可以自定义类加载继承classloader抽象类并重写findclass方法，实现获取类字节码并调用defineClass来加载内存。</p><ul><li><p>线程上下文类加载器</p><p>jdbc和jndi等使用了线程上下文加载器加载类，下面我们以jdbc为例，说明线程上下文加载器</p><p>jdbc 中使用 driverManager 来管理项目中引入的不同数据库的驱动，以实现对接不同数据库的目的</p><p>在 driverManager 加载驱动jar包中类的过程中，我们发现它打破了双亲委派机制</p><p>driverManager类位于 rt.jar 包中，由启动类加载器bootstrapClassLoader进行加载，而 driverManager 需要加载引入不同的数据库驱动类，这些类由应用类加载器加载。driverManager 由 启动类加载加载，而 driverManager 管理的驱动类需要委托给应用程序类加载器进行加载，这违反了双亲委派机制。</p><p>首先，我们需要了解 driverManager 如何知道jar中需要加载的驱动类的位置的，这里使用就是SPI机制（Seriver Provider Interface）  - JDK 内置的一种松散耦合的服务提供发现机制。</p><p>在数据库驱动的加载中，<code>DriverManager</code>通过 SPI 机制来查找和加载具体的数据库驱动。</p><p>SPI的工作原理：</p><ul><li><p>驱动加载配置文件：</p><p>在驱动jar中的classpath路径下的META-INF/services/文件夹z中，有以接口的全限定名来命名文件名，文件中有具体接口实现类的全限定名。</p></li><li><p>ServiceLoader 加载驱动</p><p><code>ServiceLoader</code> 是 java 提供的用于加载服务提供者的工具类，它会在类路径下查找 <code>META-INF/services/</code> 目录下的配置文件，并加载其中指定接口的服务提供者的类名，通过类加载器加载对应的类并创建对象注册到 DriverManager 中。</p><p><img src="https://s2.loli.net/2024/01/02/HP24DTUp3MlEhiV.png" alt="image-20240102112120324"></p></li></ul><p>在 SPI 中，驱动的jar包的类是通过应用加载器加载的，那么 driverManager 是通过启动器加载器的，那么启动器加载器是如何获取应用程序类加载器的？</p><blockquote><p>SPI 中使用了 线程上下文 保存类加载器进行类的加载，该类加载器一般是应用程序类加载器。</p><p><img src="https://s2.loli.net/2024/01/02/kxBXuzjMIqaKWsS.png" alt="image-20240102112802722"></p></blockquote></li><li><p>osgi框架类加载器</p></li></ul><blockquote><p>OSGi框架的类加载机制是基于模块化的概念的。在OSGi中，应用程序被组织成模块（bundles），每个模块都有自己的类加载器。它存在同级之间的类加载器的委托加载。 </p></blockquote><h4 id="热部署的类加载"><a href="#热部署的类加载" class="headerlink" title="热部署的类加载"></a>热部署的类加载</h4><blockquote><p>热部署是指服务在不停机的情况下，动态地更新字节码文件到内存中。</p></blockquote><p>使用arthas实现热部署</p><ul><li><p>将反编译的文件写入到执行文件中并修改文件源代码</p><blockquote><p>jad –source-only 全限定类名 &gt; /xx/xxx.java</p></blockquote></li><li><p>查看当前类的类加载器的hashcode</p><blockquote><p>sc -d xx.java</p></blockquote></li><li><p>编译修改过的源代码</p><blockquote><p>mc -c 类加载器的hashcode /xx/xxx.java -d /jar包所在目录</p></blockquote></li><li><p>使用 retrantsform 命令加载新的字节码</p><blockquote><p>retransform /类字节文件所在目录/xxx.class</p></blockquote></li></ul><p>注意：</p><blockquote><p>注意：retransform 命令是将字节码信息更新到内存中，程序重启之后，字节码文件会恢复</p><p>retransform 命令无法在已经在的类上添加字段和方法。因为 arthas 允许现有方法的修改，比如添加、修改或删除方法体中的代码，但不支持结构性的更改，比如添加字段或者方法</p><p>retransform 命令也不能作用于正在执行的方法中，正在执行的方法字节码是被锁定的，此时不能将其进行重新转换。</p></blockquote><h4 id="jdk-类加载器的变化"><a href="#jdk-类加载器的变化" class="headerlink" title="jdk 类加载器的变化"></a>jdk 类加载器的变化</h4><blockquote><p>jdk9前后类加载器发生了变化。</p><p>在jdk9之前，扩展类加载器和应用程序加载器的源代码位于 rt.jar 包中 sun.misc 包中，这两个都继承自 java.net.URLClassLoader (通过 指定目录 找到jar包以及jar包中的字节码文件)</p><p>在jdk9之后，引入module的概念，加载器类不在存放在jar包中，java 类 会被模块化为一个一个jmod文件，字节码不在从jar包中获取，而是从jmod文件中获取。</p></blockquote><p>在jdk9及之后，启动类加载器不在由jvm底层的c/c++编写，使用java编写，位于jdk.internal.loader.ClassLoaders 类中。同时启动类加载器会继承自 BuiltinClassLoader 实现从模块文件中找到要加载的字节码资源文件。值的注意的是，尽管如此，我们依旧无法在java代码中获取到启动类加载器，获取到结果依旧是 null, 这是为类保证统一。</p><p>新增的类加载器 平台类加载器（Platform Class Loader）遵循模块化方式加载字节码文件，以从模块中加载字节码文件到内存中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>类加载器的作用：负责在类加载的过程中，获取字节码并加载到内存中，并通过JNT本地方法调用调用底层方法将来在方法区生成类信息的数据结构InstanceKlass和堆上生成java.lang.Class类的实例</p><p>常见的类加载器：启动类加载器 - 加载java核心类</p><p>​         扩展类加载器 - 加载java扩展类</p><p>​         应用程序加载器 - 加载应用classpath中的类</p><pre><code>     自定义类加载器 - 重写 findClass 方法</code></pre><p>双亲委派机制：类加载器的层次结构</p><p>​        自低向上的判断是否加载过，再自顶向下的进行加载，避免核心类被应用程序重写导致安全问题，保证加载类的顺序性和一致性，避免重复加载，提高了性能          </p><p>如何打破双亲委派机制：</p><p>  继承classloader类重写loadClass方法，不再实现双亲委派机制。</p><p>  使用SPI机制加载类字节码使用了上下文类加载器。</p><p>  OSGi框架实现了一整套类加载机制，允许同级类加载器的相互调用。</p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><blockquote><p>jvm 在执行java程序的过程中管理的内存区域被称为 运行时数据区，在执行过程中，运行时数据区划分为若干的不同数据区域。</p></blockquote><p>根据《Java虚拟机规范》的规定，运行时数据区将会包括以下 运行时数据区域：</p><p><img src="https://s2.loli.net/2024/01/02/jaGvAJ3kgrDBzPo.png" alt="image-20240102141247168"></p><p>线程私有：程序计数器 本地方法栈 虚拟机栈</p><p>线程共享：方法区 堆</p><h3 id="运行时内存结构"><a href="#运行时内存结构" class="headerlink" title="运行时内存结构"></a>运行时内存结构</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><blockquote><p>程序计数器（Program Counter Register）是每个线程会通过程序计数器记录当前需要执行的字节码指令的内存地址，可以看作当前线程所执行的字节码的”行号指示器”，属于线程私有的，是一个较小的固定长度的内存空间。</p></blockquote><p>字节码指令在jvm类的加载阶段被加载到内存中，会源文件中的指令偏移量转换为内存地址，每一条字节码指令都会有一个对应的内存地址</p><img src="https://s2.loli.net/2024/01/02/JMhu8qty2SkaDCc.png" alt="image-20240102160613196" style="zoom:50%;" /><p>在代码的执行过程中，程序计数器记录 下一个字节码指令的内存地址，当当前指令执行完成后，虚拟机的执行引擎会根据程序计数器记录的内存地址找到对应的指令来执行下一行指令</p><h5 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h5><ul><li><p>程序计数器是程序控制流的指示器，可以实现分支、循环、跳转、异常等逻辑。</p></li><li><p>在多线程运行的情况下，线程轮流切换来分配处理器执行时间，程序计数器会记录当前线程接下来需要执行的指令，以便线程切换后恢复到正确的执行位置从而继续执行。</p></li></ul><p>根据《Java虚拟机规范》，程序计数器是没有规定任何OutOfMemoryError情况的区域，同时开发者无需对于程序计数器做任何的处理。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><blockquote><p>java 虚拟机栈（Java Virtual Machine Stack）是 采用栈的数据结构来保存每个方法调用的基本数据。栈是一种先进后出的数据结构，每一个方法的调用信息将使用一个栈帧（Stack Frame）来保存即每个栈帧对应一个个调用方法调用。</p><p>虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，jvm 都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程即每个方法执行伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong>，线程上的每一个方法都对应着一个栈帧。</p><p>虚拟机栈的生命周期和线程相同，随着线程的创建而创建，随着线程的销毁而回收。</p></blockquote><p> 通过IDEA的debug工具可以查看栈帧的内存</p><img src="https://s2.loli.net/2024/01/02/UloFNvkE8eJA6i3.png" alt="image-20240102170325870" style="zoom:50%;" /><h5 id="栈帧的组成"><a href="#栈帧的组成" class="headerlink" title="栈帧的组成"></a>栈帧的组成</h5><blockquote><p>虚拟机栈的栈帧中，存储着：局部变量表（Local Variables）、操作数栈（Operend Stack）、动态链接（Dynamic Linking）、方法返回地址（Return Address)、附加信息等。</p></blockquote><p><img src="https://s2.loli.net/2024/01/03/VOcUgfdZQBve9qH.jpg" alt="jvm-stack-frame"></p><p><img src="https://s2.loli.net/2024/01/10/XpUFP8orcvGwJaQ.png" alt="image-20240110164003715"></p><h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><blockquote><p>用于存储方法参数和方法内部定义的局部变量。局部变量表的容量是在编译期确定的，存储的数据类型包括基本数据类型（如int、float）和对象引用</p></blockquote><p>栈中的局部变量表本质上是一个 数组，数组中每一个位置被称之为一个槽（slot），其中 long 和 double 类型占用两个槽，其他类型和引用类型专用一个槽</p><p>在实例方法中，局部变量序号为0的位置存放的是this，指的是当前调用方法的对象（即对象实例的引用），运行时会在内存中存放对象的地址。当静态方法中则无需在序号为0的位置存放对象的引用。方法参数也需要保存在局部变量表中，其顺序和方法参数定义顺序一致。</p><p>因此局部变量表中包含了方法参数、局部变量、对象实例的引用和返回值等。</p><p>为了节省局部变量表的空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以被复用。</p><h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h6><blockquote><p>用于执行计算操作的栈。在方法执行过程中，操作数栈用于暂存计算过程中的中间结果。</p><p>在编译器可以确定操作数栈的最大深度，从而执行时正确的分配内存大小。</p></blockquote><h6 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h6><blockquote><p>动态链接指向方法区的运行时常量池的方法引用，用于方法调用过程中的动态链接。</p><p>在类的生命周期的连接-解析阶段，会将符号引用转换为直接引用。当前类的字节码指令引用了其他类的属性和方法时，符号引用在类的连接阶段不会直接变成直接引用，因此在运行时需要将符号引用和对应运行时常量池中的内存地址映射关系。</p><p>动态链接中保存了符号引用到运行时常量池的内存地址的映射关系。当字节码指令执行过程中，就可以根据当前的符号引用从动态链接中快速找到运行时常量池对应的数据。</p></blockquote><img src="https://s2.loli.net/2024/01/03/lhLe9oR1r62PaBY.jpg" alt="jvm-dynamic-linking" style="zoom: 33%;" /><h6 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h6><blockquote><p>当一个方法执行结束或者异常后，会从栈顶弹出，此时程序计数器需要知道下一个方法指令的地址，而方法出口保存了指向下一个方法指令的地址。</p></blockquote><h6 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h6><blockquote><p>异常表存放了代码中的异常的处理信息，包含了try代码和catch代码指令执行后跳转字节码的指令位置。</p></blockquote><h5 id="虚拟机的栈内存"><a href="#虚拟机的栈内存" class="headerlink" title="虚拟机的栈内存"></a>虚拟机的栈内存</h5><blockquote><p>在java虚拟机栈的大小一般是固定的，即在启动时通过命令行参数或者其他配置方法指定并在运行时不会动态的调整；jvm 如果栈帧过多，因此会出现内存溢出。</p><p>在《Java虚拟机规范》中，如果线程请求分配的栈容量超过虚拟机所设置允许的最大容量，将抛出栈溢出StackOverflowError异常。</p></blockquote><p>在不指定栈的大小的情况下，jvm 会创建一个默认大小的栈，栈的大小取决于操作系统和计算机的体系结构。</p><p>可以通过虚拟机参数<code>-Xss</code>或者 <code>-XX:ThreadStackSize</code> 来设置线程的最大栈空间。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xss &lt;size&gt; （默认字节，此时必须1024的倍数，其他单位：k和kb，m和MB, g和GB）</span><br><span class="line">-XX:ThreadStackSize=&lt;size&gt;</span><br></pre></td></tr></table></figure><p>注意：hotspot jvm 对栈大小的最大值和最小值有要求</p><p>​     栈的可达深度取决于栈的大小和每个栈帧的大小</p><p>调优：在一般情况下，栈的大小不会超过256k，通过减小栈的大小，可以在一定程度上减小每个线程消耗的内存，手动指定<code>-Xss256k</code>来节省内存</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><blockquote><p>java 虚拟机栈存储的是java方法调用的栈帧，而本地方法栈存储的是native本地方法的栈帧。</p><p>在hotspot虚拟机上，java虚拟机栈和本地方法栈实现上使用了同一个栈空间。</p></blockquote><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><blockquote><p>java堆是jvm管理的内存最大的一部分，被所有线程共享，该区域用于存放对象实例。</p><p>在java虚拟机栈的栈帧上的局部变量表上，可以存放了堆上对象的引用，方法区的静态变量可以存放堆对象的引用（因此通过静态变量可以实现对象在线程之前的共享）</p></blockquote><p>java 虚拟机规范规定，堆大小存在上限，如果在java堆中没有内存完成实例分配，并且堆也无法再扩展时，java虚拟机将会抛出OutOfMemoryError异常。</p><p>堆空间有三个值得关注的值：used、total、max</p><p>used（已使用）：表示当前已经被使用的堆空间大小</p><p>total（总计）：已经分配的可用堆内存</p><p>max（最大）：可以分配的最大堆内存</p><p>当堆内存达到max时，应用程序尝试分配更多内存超过这个值时，会触发OutOfMemoryError错误。</p><p>可以使用arthas的 dashbroad 和 memory 命令查看jvm的堆内存占用情况：</p><p><img src="https://s2.loli.net/2024/01/03/FLCvOtRMlnKeVIY.png" alt="image-20240103110849137"></p><h5 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h5><blockquote><p>在不设置任何的虚拟机参数的情况下，max（即已经分配的可用堆内存）默认是系统内存的1/4，total（即可以分配的最大堆内存）默认是系统内存的1/64。在实际应用中一般都需要设置 total和max的值</p></blockquote><p>可以使用虚拟机参数 <code>-Xmx</code> 和 <code>-Xms</code> 来分别设置 total 和 max:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms &lt;size&gt; -Xmx &lt;size&gt;</span><br></pre></td></tr></table></figure><p>限制：Xmx必须大于2MB，Xms必须大于1MB</p><p>调优：建议将 <code>-Xmx</code> 和 <code>-Xms</code> 设置为相同的值，这样程序启动时，堆空间一次性分配，避免了在程序运行时，内存不足动态申请和分配堆空间的开销，以及内存过剩时堆内存收缩的情况。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><blockquote><p>方法区（method area）被所有线程共享，该区域用于存储被虚拟机加载的类型信息，常量、静态变量、即时编译器优化后的代码等数据的内存区域。</p></blockquote><h5 id="方法区设计"><a href="#方法区设计" class="headerlink" title="方法区设计"></a>方法区设计</h5><p>方法区是 jvm 规范中定义的一个概念，不同 jvm 实现不同，hotspot在不同的版本的设计也不同：</p><ul><li><p>jdk8之前的版本，方法区存放在堆区域的永久代空间（permanent generation），堆大小由虚拟机参数 <code>-XX:MaxPermSize=&lt;size&gt;</code> 控制</p></li><li><p>jdk8及之后的版本，方法区存放在元空间（namespcace），元空间位于操作系统维护的直接内存中，默认情况下，不超过操作系统内存上限，即可一直分配。但是可以使用参数 <code>-XX:MaxMetaspaceSize=&lt;size&gt;</code>设置元空间的最大大小</p><p><img src="https://s2.loli.net/2024/01/03/4unbKgAlTNOJS6h.png" alt="image-20240103131055200"></p></li></ul><h5 id="方法区组成"><a href="#方法区组成" class="headerlink" title="方法区组成"></a>方法区组成</h5><h6 id="类的基础信息"><a href="#类的基础信息" class="headerlink" title="类的基础信息"></a>类的基础信息</h6><p>方法区存储了每一个被加载的类的基础信息（即元信息），一般称为<code>InstanceKlass</code>对象（其中包含了类基本信息，常量池引用、字段引用、方法引用、虚方法表等）。</p><h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>此外，方法区存放了运行时常量池，运行时常量池存放的是字节码中的常量池的内容。在加载阶段，字节码中的常量池被加载到方法区，此时为常量池中的值为符号引用，所以被称之为静态常量池。在连接阶段后，符号引用转换为直接引用，可以通过内存地址快速定位常量池中的内容，此时常量池为运行时常量池。</p><h6 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h6><p>方法区还有一个区域是字符串常量池（StringTable），字符串常量池用于存储在代码中定义的常量字符串的内容。</p><img src="https://s2.loli.net/2024/01/03/Jjo1ILtxEN5QhBs.png" alt="image-20240103134240458" style="zoom:33%;" /><p>jdk7前方法区采用永久代存放在堆中，运行时常量池逻辑上包含了字符串常量；jdk7将字符串常量池从永久代中移除，放到了堆上；jdk8及之后版本，hotspot 移除了永久代使用了元空间取而代之，字符串常量却仍然存在于堆中。</p><p><img src="https://s2.loli.net/2024/01/03/oAj57qilVa8ymv1.png" alt="image-20240103154047381"></p><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c == d); # 输出 <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">7</span> &lt;<span class="number">1</span>&gt; # 将字符串常量池中索引为<span class="number">7</span>的地址引用推送至栈顶</span><br><span class="line"> <span class="number">2</span> astore_1 # 栈顶地址引用保存到局部变量表的第一个位置</span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">9</span> &lt;<span class="number">2</span>&gt;</span><br><span class="line"> <span class="number">5</span> astore_2</span><br><span class="line"> <span class="number">6</span> ldc #<span class="number">11</span> &lt;<span class="number">12</span>&gt;</span><br><span class="line"> <span class="number">8</span> astore_3</span><br><span class="line"> <span class="number">9</span> aload_1</span><br><span class="line"><span class="number">10</span> aload_2</span><br><span class="line"><span class="number">11</span> invokedynamic #<span class="number">13</span> &lt;makeConcatWithConstants, BootstrapMethods #<span class="number">0</span>&gt; # 动态调用字符串拼接，生成一个新的字符串存放在堆内存中</span><br><span class="line"><span class="number">16</span> astore <span class="number">4</span> # 将新的字符串的堆内存地址引用保存到局部变量表的第四个位置</span><br><span class="line"><span class="number">18</span> getstatic #<span class="number">17</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class="line"><span class="number">21</span> aload_3</span><br><span class="line"><span class="number">22</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">24</span> if_acmpne <span class="number">31</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">27</span> iconst_1</span><br><span class="line"><span class="number">28</span> goto <span class="number">32</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">31</span> iconst_0</span><br><span class="line"><span class="number">32</span> invokevirtual #<span class="number">23</span> &lt;java/io/PrintStream.println : (Z)V&gt;</span><br><span class="line"><span class="number">35</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>==</code> 比较的是两者的内存地址引用是否相等，显然上面一个是c在局部变量中存储的是 字符串常量池的引用，d时在堆内存上的字符串地址引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> + <span class="string">&quot;2&quot;</span>;</span><br><span class="line">System.out.println(c == d); # 输出 <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>字符串字面量的拼接在编译时就会被优化直接连接，d直接引用字符串常量池的地址，因此地址一样输出 true</p><p>String的intern</p><p>String的<code>intern</code>方法用于在运行时将字符串对象添加到字符串常量池中，并返回字符串常量池中对应的引用地址。在jdk7前，intern()方法会将第一次遇到的字符串实例从堆内存中复制到永久代的字符串常量池中， 此时返回的是永久代中字符串常量池的字符串的实例的引用。而jdk7及之后，方法会将第一次遇到的字符串的引用存入到字符串常量池中，返回到是字符串常量池的字符串的引用的引用，因此次数它的字符串地址和堆内存地址相同。</p><p>类的静态变量</p><blockquote><p>类的静态变量的存储在哪里?</p><p>jdk6及之前的版本中，静态变量是存放在方法区中的 instanceKlass，也就是永久代中。</p><p>jdk7及之后的版本中，静态变量是存放在堆中的java.lang.Class对象中</p></blockquote><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是 在jdk8及之后，方法区存储在直接内存中。</p><p>直接内存解决了jdk1.4引入NIO机制后带来了的问题：</p><p>NIO 支持使用 native 函数直接分配直接内存，通过存储在java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作，避免了数据在直接内存和堆中的来回复制，提升了性能。</p><p><img src="https://s2.loli.net/2024/01/03/iD2U47Mqasg9e8B.png" alt="image-20240103152502254"></p></blockquote><p>使用 arthas 的 memory 命令可以看到 直接内存的情况</p><p><img src="https://s2.loli.net/2024/01/03/BxZrvPFeb1uztEW.png" alt="image-20240103152750154"></p><h4 id="直接内存的配置"><a href="#直接内存的配置" class="headerlink" title="直接内存的配置"></a>直接内存的配置</h4><p>直接内存的分配收到操作系统的影响，不可能无限制的增大，当各个内存区域总和大于物理内存限制，会出现OutOfMemoryError异常。</p><p>使用参数 <code>-XX:MaxDirectMemorySize=&lt;size&gt;</code> 来手动调整直接内存的大小，在默认情况下，jvm会自动选择最大分配的大小（如果系统底层使用了NIO，建议手动设置）。</p><h3 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><blockquote><p>内存溢出（Memory Overflow）指的是程序在运行过程中请求的内存超过了虚拟机所能提供的最大限制，导致程序运行出现错误。</p></blockquote><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><blockquote><p>在c/c++语言中，没有自动垃圾回收机制，一个对象如果不再使用需要手动进行释放即进行垃圾回收，否则就会出现内存泄漏（Memory Leak）。</p></blockquote><h3 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h3><p><strong>内存泄漏</strong>（<strong>Memory Leak</strong>）：程序中<strong>已经不再使用的对象或者资源没有被正常释放</strong>，导致这部分内存无法再被程序访问和利用。</p><p><strong>内存溢出</strong>（<strong>Memory Overflow</strong>）：程序在运行过程中<strong>需要的内存超过了系统所能提供的最大限制</strong>，导致程序无法正常运行。</p><blockquote><p>内存泄漏的积累会导致内存溢出</p></blockquote><p>java 简化了对象的释放，引入了自动垃圾回收（Garbage Collection，下文简称GC）机制。通过垃圾回收器对于不再使用的对象进行自动的回收。</p><p>垃圾回收器属于jvm执行引擎的一部分，主要负责对堆上的不使用的对象内存进行回收。</p><blockquote><p>对于线程私有的部分（程序计数器、java虚拟机栈、本地方法栈）是无需垃圾收集器进行回收的，因为这三部分是存放在线程内部的，伴随着线程的生命周期，随着线程的创建而创建，随着线程的销毁而销毁。同时，方法栈帧会在方法执行完毕后，栈帧会自动弹出栈并释放栈的内存。</p></blockquote><h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>对于方法区中的回收主要是 不再使用的类：</p><p>判断一个类是否可以被回收，需要同时满足以下条件：</p><ul><li>类的所有实例对象均被回收：堆内存中不存在该类实例对象和该类的子类对象</li><li>类的加载器的生命周期结束</li><li>类对应的 java.lang.Class 对象没有被任何地方引用</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">URLClassLoader</span> <span class="variable">urlClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;/xxx/xxx&quot;</span>));</span><br><span class="line">  Class&lt;?&gt; clazz = urlClassLoader.loadClass(<span class="string">&quot;com.xxx.xx&quot;</span>);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">  </span><br><span class="line">  System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，循环体中的对象在进入下一个循环时就没有引用了，因此会进行回收。</p><p>执行方法时，添加虚拟机启动参数：<code>-XX:+TraceClassLoading</code> 和 <code>-XX:+TraceClassUnloading</code>来打印类加载和卸载的信息</p><p><code>System.gc()</code>: 可以手动触发垃圾回收</p><p>​        不一定会立即触发垃圾回收，而是向jvm发送一个垃圾回收的请求，具体是否需要执行垃圾回收则需要虚拟机自行判断。</p><p>由于正常程序的类是由应用加载器来加载的，应用加载器在运行的过程中是不会被回收的，所以这些类都在运行中是不会被回收的。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在一些例如OSGi和jsp的热部署等应用场景中，例如jsp的热部署，每一个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载了这个jsp的加载器和类信息，重新创建类加载器，重新加载jsp文件，从而实现jsp热部署。</p><h3 id="堆回收"><a href="#堆回收" class="headerlink" title="堆回收"></a>堆回收</h3><h4 id="判断对象是否需要回收"><a href="#判断对象是否需要回收" class="headerlink" title="判断对象是否需要回收"></a>判断对象是否需要回收</h4><blockquote><p>java中的垃圾回收机制基于对象的引用关系。一个对象是否能够被垃圾回收主要取决于是否存在对该对象的引用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Coder</span> <span class="variable">coder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coder</span>();</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/03/XJ5uW39ESH4cwYU.png" alt="image-20240103203722674"></p><blockquote><p>常见判断的对象是否有被引用的方法有两种：引用计数法和可达性分析法。</p></blockquote><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><blockquote><p>引用计数法（Reference Counting）为每个对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p></blockquote><p>引用计数器实现简单，判定效率也很高。但是总在一些问题：</p><ul><li><p>每个对象都占用一些额外的内存空间来计数，并且引用的确认和失效都需要维护这个引用计数器，对于系统的开销有一定的影响。</p></li><li><p>存在循环引用问题</p><p>如果对象objA和objB都有字段instance，赋值令 objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已 经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也 就无法回收它们。</p></li></ul><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">SimpleClass</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleClass</span>();</span><br><span class="line">      <span class="type">SimpleClass</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleClass</span>();</span><br><span class="line">      objA.instance = objB;</span><br><span class="line">      objB.instance = objA;</span><br><span class="line">      objA = <span class="literal">null</span>;</span><br><span class="line">      objB = <span class="literal">null</span>;</span><br><span class="line">      System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>-verbose:gc</code> 查看垃圾回收日志</p><p><img src="https://s2.loli.net/2024/01/03/1UpGzZLXveKWInS.png"></p><p>上图可以看到内存回收日志中内存空间变化，意味着jvm没有因为这两个对象互相引用而放弃回收它们，则jvm并不是通过引用计数算法来判定对象是否是否存活。</p><h5 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h5><blockquote><p>jvm 通过 可达性算法（Reachability Analysis）算法来判定对象是否存活的。</p><p>可达性算法的对象被分为两类：垃圾回收的根对象（GC Root）和 普通对象。</p><p>可达性算法就是通过一系列称为”GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连即从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p></blockquote><p><img src="https://s2.loli.net/2024/01/03/1elKgyBIs9q7Twu.png" alt="image-20240103212130937"></p><h6 id="GC-Root对象"><a href="#GC-Root对象" class="headerlink" title="GC Root对象"></a>GC Root对象</h6><p>GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈中引用的对象（局部变量，方法参数、临时变量等）</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>jvm 内部引用</li><li>监视器对象即被同步锁持有的对象</li></ul><h6 id="如何查看GC-ROOT"><a href="#如何查看GC-ROOT" class="headerlink" title="如何查看GC ROOT"></a>如何查看GC ROOT</h6><p>通过 arthas 和 eclipse memory analyzer(MAT) 查看 GC ROOT</p><blockquote><p>MAT 工具是 java堆内存的检测工具</p></blockquote><ul><li>使用 arthas 的 <code>heapdump</code> 命令将<strong>堆内存快照</strong>保存到本地磁盘中</li></ul><img src="https://s2.loli.net/2024/01/03/cmXLWew5kU6uZyv.png" alt="image-20240103220015710" style="zoom:33%;" /><ul><li><p>使用 MAT 工具打开堆内存快照文件</p></li><li><p>选择 GC Roots 功能查看所有的GC Root   <img src="https://s2.loli.net/2024/01/03/kKbEh42ZMdY1BP7.png" alt="image-20240103222648481"></p></li></ul><h5 id="四种对象引用"><a href="#四种对象引用" class="headerlink" title="四种对象引用"></a>四种对象引用</h5><blockquote><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和”引用”有关。</p><p>在JDK 1.2版之后，java 对引用的概念进行了扩充，将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p></blockquote><h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><blockquote><p>强引用（Strongly Reference）是最传统和最普遍的引用的定义。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>回收情况：强引用指向的对象无论任何情况都<strong>不会被回收</strong></p><h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><blockquote><p>软引用用来描述一些还有用但是非必需的对象，软引用通过 <code>SoftReference</code> 类来实现(格式：new SoftReference&lt;对象类型&gt;(对象))。</p><p>软引用一般用于<strong>缓存</strong>中，即对象的存在对程序性能有帮助必须的场景。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>()； # <span class="keyword">new</span> <span class="title class_">Object</span>() 在堆中创建Object示例并使用obj建立强引用</span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj); # <span class="keyword">new</span> <span class="title class_">SoftReference</span>在堆中创建软引用对象包装obj并使用softRef建立软引用</span><br><span class="line">obj = <span class="literal">null</span>; # 清除obj强引用关联</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/01/04/vTRNrg3O5x2p6Iu.png" alt="image-20240104104152984" style="zoom:33%;" /><p>回收情况：软引用中的对象只有<strong>在内存不够的情况</strong>下才会被回收</p><blockquote><p>注意：内存不够的情况下，会回收掉使用SoftReference包装的对象，堆中创建的SoftReference对象本身也需要进行回收。</p><p>SoftReference 提供了一套队列机制，使用引用队列（ReferenceQueue）来监控软引用对象的回收。通过检查引用队列中是否包含软引用对象，可以得知SoftReference对象是否被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), referenceQueue);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 检查引用队列中是否包含软引用对象</span></span><br><span class="line">SoftReference&lt;Object&gt; polledRef = (SoftReference&lt;Object&gt;) referenceQueue.poll();</span><br><span class="line"><span class="keyword">if</span> (polledRef != <span class="literal">null</span>) &#123;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><blockquote><p>弱引用用于描述一些非必须的对象，它的强度比软引用更弱一点。弱引用应用于 ThreadLocal 中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>回收情况：当垃圾收集器开始垃圾回收时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。</p><h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><blockquote><p>虚引用也称为“幽灵引用”或者“幻影引用”，不能通过虚引用对象获取对象实例。虚引用的唯一用途是 当对象被收集器回收时收到一个系统通知。</p></blockquote><p>jdk 提供 <code>PhantomReference</code> 类来实现虚引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><blockquote><p>对象垃圾回收分为两个阶段：标记阶段和清理阶段</p><ul><li>标记阶段（Marking）：标记内存中存活的对象<ul><li>标记过程中，未被标记的对象将被认为是不可达的，即垃圾对象。</li></ul></li><li>清理阶段（Sweeping）：垃圾回收器清理并回收那些不存活的对象所占用的内存空间。</li></ul></blockquote><blockquote><p>jvm 垃圾回收过程会通过单独的垃圾回收线程来执行。因为垃圾回收是相对耗时的操作，如果在主线程中执行，会导致应用程序停顿，影响用户体验。</p><p>不同的垃圾回收算法和 jvm 有不同的线程管理策略，但不管使用哪一种垃圾回收算法，都会有部分阶段，整个应用程序的所有线程都被暂停，不再执行任何指令，此阶段被称为 STW 即 stop the world。如果STW的时间越长越会影响用户的体验，因此此过程越短越好。</p></blockquote><h5 id="垃圾回收算法的评价标准"><a href="#垃圾回收算法的评价标准" class="headerlink" title="垃圾回收算法的评价标准"></a>垃圾回收算法的评价标准</h5><ul><li>吞吐量：吞吐量是指在一定时间内应用程序实际运行的时间占总时间的比例。高吞吐量通常意味着垃圾回收的效率较高。<ul><li>总时间 = 应用程序实际运行 + 垃圾回收时间</li></ul></li><li>暂停时间： 应用程序的暂停时间是指在进行垃圾回收时，应用程序中断执行的时间。<ul><li>低延迟的应用，较短的暂停时间通常是一个关键的性能指标。尤其是最大暂停时间不能过长。</li></ul></li><li>内存利用率：有效提高内存利用率是一个重要的标准。同时减少内存碎片的问题也会减少对于后续的内存分配的影响。</li></ul><p>不同的垃圾回收算法需要结合具体应用场景的需求进行选择。</p><h5 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h5><h6 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h6><blockquote><p>标记-清除（Mark and Sweep）：将存活的对象进行标记，然后清理掉未被标记的对象即非存活对象。</p></blockquote><img src="https://s2.loli.net/2024/01/04/j4tsmZ9QEc1Hzrp.jpg" alt="image"  /><p>优点：实现简单（只需要在标记阶段给每一个对象维护一个标志位）</p><p>缺点：执行效率不高，标记和清除过程的执行效率随着对象的数量的增长而降低</p><p>​     内存空间碎片化问题，标记清除产生大量不连续的内存碎片，导致内存较大对象无法分配以及分配速度需要遍历导致速度慢的问题（通常通过“分区空闲分配链 表”来进行内存分配）</p><h6 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h6><blockquote><p>复制算法（Copying）：将内存划分为大小相等的两块，一半是活动对象的当前存放地（from），另一半是空闲区（to）。当这一块内存用完了就将还存活的对象复制到另一块上面并有序排列，然后再把使用过的内存空间进行一次清理。</p></blockquote><p><img src="https://s2.loli.net/2024/01/04/DeQnjVuSshlyKMC.png" alt="image-20240104114033697"></p><p>优点：不会出现内存碎片化问题（对象复制到另一块内存空间会按顺序存放），内存分配速度快，按顺序分配即可</p><p>缺点：内存使用效率低，可用内存空间缩小到原来的一半</p><p>​     当有大量对象存活时会产生大量内存复制的开销</p><h6 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h6><blockquote><p>标记-整理（Mark and Compact）：标记过程和”标记-清除”算法一样，但是后续整理阶段让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。</p></blockquote><p><img src="https://s2.loli.net/2024/01/04/RgAVKCpQXxqyhZt.png" alt="image-20240104132131609"></p><p>优点：内存使用率较高、不会产生内存碎片，内存分配性能好</p><p>缺点：整理阶段的效率不高并且阻塞用户程序（移动存活对象并更新所有引用这些对象的地方）</p><h6 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h6><blockquote><p>分代垃圾回收算法（Generational）：根据对象的存活周期将内存划分为几块，不同的块采用不同垃圾回收算法</p><p>一般将堆内存划分为 新生代和老年代, 其中新生代又被划分 <code>Eden</code>区，<code>s0</code> 和 <code>s1</code> 区</p><ul><li>新生代：存放存活时间比较短的对象</li><li>老年代：存放存活时间比较长的对象</li></ul></blockquote><p>添加启动参数 <code>-XX:userSerialGC</code> 参数使用<code>分代垃圾回收器</code>运行程序，然后使用 arthas 的 memory 命令查看内存结构和占用情况</p><p><img src="https://s2.loli.net/2024/01/04/RqS3wk7AIWsOrv2.png" alt="image-20240104134610689"></p><p>参数设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseSerialGC SimpleClass # -XX:+UseSerialGC 使用的是基于分代算法的串行垃圾回收器</span><br><span class="line">-Xms #  设置 java 堆内存的初始大小</span><br><span class="line">-Xmx # 设置 java 堆内存的最大大小</span><br><span class="line">-Xmn # 设置 java 堆内存的新生代的大小</span><br><span class="line">-XX:NewRatio=2  # 设置老生代和新生代的比例</span><br><span class="line">-XX:SuriviorRatio # 设置新生代中 Eden 区和 单个Survivor 区的比例。SurvivorRatio 的默认值是 8 即  Eden 区占新生代的 8 部分，每个 Survivor 区各占 1 部分</span><br><span class="line">-XX:PrintGCDetails # 启用垃圾回收日志详细信息的打印</span><br><span class="line">-verbose:gc # 启用垃圾回收的详细输出【前者更加详细】</span><br></pre></td></tr></table></figure><p>分代垃圾回收流程</p><ul><li><p>分配阶段 - Allocation：新创建的对象首先被分配到新生代的 Eden 区</p></li><li><p>新生代垃圾回收 - Minor GC：当 Eden 区满时，会触发 Minor GC（也称 Young GC）</p><ul><li><p>Minor GC 采用 <code>标记-复制</code> 算法识别和标记仍然存活的对象，将存活的对象复制到一个 Survivor 区并清空 Eden 区</p><p>再次 Minor GC 时，将上一个 Survivor 区和 Eden 区仍然存活的对象复制到另一个 Survivor 区</p></li></ul></li><li><p>老化 - Aging：每次 Minor GC 都会为存活的对象记录年龄，初始值为0，每次 GC 存活对象的年龄增 1，当对象年龄到达阈值（最大15，默认值与垃圾回收器有关），对象会晋升到老年代（注：当新生代的空间不足时，部分对象也会晋升到老年代）</p></li><li><p>老年代垃圾回收 - Major GC：当老年代空间不足时，尝试进行 Minor GC 后仍然无法满足内存需求时，就会触发 Major GC （也称 Full GC），Major GC 会对整个堆内存进行回收，包括新生代和老年代。</p></li></ul><blockquote><p>Minor GC 频繁发生，会导致短暂的STW</p><p>Major GC 发生频率较低，整个堆都需要被扫描和清理会导致较长的STW，开销较高</p><p>​         如果 Major GC 后老年代仍然无法容纳新对象，会导致内存溢出</p></blockquote><p>为什么分代思想将堆划分为年轻代和老年代？</p><blockquote><p>新生代和老年代分别采用不同的垃圾回收算法和策略，以优化不同生命周期的对象的回收效率，减小每次垃圾回收的停顿时间，并提高整体垃圾回收的吞吐量。</p><p>开发者可以更加灵活的设置年轻代和老年代的比例来适应不同类型的应用程序（例如：并发比较高的应用可以适当增加年轻代，反正新生代内存占满后，对象提前晋升最终导致老年代占满频繁 Major GC 甚至导致内存溢出）</p></blockquote><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><blockquote><p>垃圾收集器就是内存回收算法的具体实现</p></blockquote><h5 id="常见的垃圾回收器"><a href="#常见的垃圾回收器" class="headerlink" title="常见的垃圾回收器"></a>常见的垃圾回收器</h5><h6 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h6><p>各款经典收集器之间的关系如下</p><p><img src="https://s2.loli.net/2024/01/04/mbjwQ6RvxkHEfnO.png" alt="image-20240104145042847"></p><h5 id="垃圾回收器的使用"><a href="#垃圾回收器的使用" class="headerlink" title="垃圾回收器的使用"></a>垃圾回收器的使用</h5><h6 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h6><blockquote><p>Serial收集器是<strong>单线程串行</strong>回收的<strong>年轻代</strong>收集器，采用 <strong>标记-复制</strong> 算法</p><p>单线程强调的是它在进行垃圾回收时，必须暂停其他所有工作线程，直到它收集结束。</p></blockquote><p><img src="https://s2.loli.net/2024/01/04/pRtbS2QiV8k4uNE.png"></p><p>优点：简单、高效，适用于单线程环境，单CPU处理器下吞吐量大</p><p>缺点：单线程执行不适用于多核处理器，可能导致停顿时间较长</p><p>使用场景：单核CPU小型应用、客户端应用</p><h6 id="SerialOld收集器"><a href="#SerialOld收集器" class="headerlink" title="SerialOld收集器"></a>SerialOld收集器</h6><blockquote><p>Serial Old是 Serial 收集器的老年代版本，是<strong>单线程串行</strong>回收的<strong>老年代</strong>收集器，采用 <strong>标记-整理</strong> 算法</p></blockquote><p><img src="https://s2.loli.net/2024/01/04/I1ZEShtwcy6gxOb.png" alt="image-20240104151248065"></p><p>优缺点和使用场景和 Serial收集器 一致。</p><blockquote><p>使用启动参数 <code>-XX:+UseSerialGC</code> 开启 Serial收集器 和 SerialOld收集器 的单线程串行垃圾收集器组合。</p></blockquote><h6 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h6><blockquote><p>ParNew收集器是Serial收集器的多线程并行版本，使用<strong>多线程</strong>进行垃圾回收的<strong>年轻代</strong>收集器，采用  <strong>标记-整理</strong> 算法</p><p>使用参数 <code>-XX:+UseParNewGC</code> 开启新生代使用 ParNew 回收器，老年代使用串行回收器。</p></blockquote><p><img src="https://s2.loli.net/2024/01/04/TMFioBOWgp9q8jf.png" alt="image-20240104161804887"></p><p>优点：多线程执行垃圾回收，提高了垃圾回收的吞吐量；多核处理器停顿时间减少</p><p>缺点：不满足对停顿时间要求极高的场景</p><p>使用场景：中等规模的应用，对停顿时间要求不是特别严格的场景</p><h6 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h6><blockquote><p>CMS 收集器（Concurrent Mark-Sweep GC）是一种<strong>旨在获取最短回收停顿时间为目标</strong>的老年代收集器，采用  <strong>标记-清理</strong> 算法，在部分步骤中，采用了并发的执行方式，以尽量减小在垃圾回收过程中应用程序的停顿时间。</p><p>使用参数 <code>-XX:+UseConcMarkSweepGC</code> 开启老年代使用 CMS 回收器。</p></blockquote><p><img src="https://s2.loli.net/2024/01/04/oOM9EpRed2wPcNA.png" alt="image-20240104153222282"></p><p>整个过程分为四个步骤，包括：</p><ul><li>初始标记（CMS initial mark） - <strong>STW</strong>：用较短的时间识别并标记与根对象（GC Root）直接关联的对象</li><li>并发标记（CMS concurrent mark）：并发标记，遍历对象图，标记所有可达的对象</li><li>重新标记（CMS remark） - <strong>STW</strong>：在并发标记期间可能产生的新的存活对象，进行一次短暂的新对象重新标记并进行修正</li><li>并发清除（CMS concurrent sweep）：并行清理标记为垃圾的对象，释放空间</li></ul><p>初始标记和重新标记阶段会造成短暂的停顿，并发标记和并发清除阶段是并发执行，占据上面流程中较长的时间。</p><p>优点：部分并发执行，减少了停顿时间</p><p>缺点：标记清除导致的内存碎片问题；在老年代内存分配对象不足的情况下会推化为SerialOld单线程串行垃圾回收器；</p><p>​     产生“浮动垃圾”问题，无法处理在并法清理阶段产生的垃圾对象；</p><p>​     并发阶段占用CPU资源造成性能影响</p><p>使用场景：适用于对于停顿时间要求较高的中大型应用，请求数据量大和频率高的场景（jdk14后，cms被废弃）</p><h6 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h6><blockquote><p>Parallel Scavenge是jdk8默认的年轻代垃圾回收器，在诸多特性从表面上看和ParNew非常相似，多线程并行回收。</p><p>Parallel Scavenge和与其他收集器不同的关注点，CMS等收集器的关注点是尽可能 地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐 量（Throughput）。</p><img src="https://s2.loli.net/2024/01/04/JFReA2YqvSZ9GdC.png" alt="image-20240104162047479" style="zoom:33%;" /><p>Parallel Scavenge 可以通过参数打开 GC 自适应的调节策略（GC Ergonomics），jvm 会自动根据系统的配置和应用程序的行为进行调整堆参数（堆内存的大小、结构，晋升阈值等等），以提供最合适的停顿时间或者最大的吞吐量。</p></blockquote><p>优点：吞吐量高，自适应调节</p><p>缺点：不能保证每一次的停顿时间</p><p>适用场景：适用于执行时间较长、计算密集型的后台任务（例如：大数据处理和大文件导出），对吞吐量要求较高并且停顿时间要求相对宽松的场景</p><h6 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h6><blockquote><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持<strong>多线程并发收集</strong>，基于<strong>标记-整理</strong>算法的老年代收集器。</p></blockquote><blockquote><p>使用参数 <code>-XX:+UseParallGC</code>或者 <code>-XX:+UserParallelOldGC</code> 开启使用 Parallel Scavenge 和 Parallel old 回收器的组合，但是jdk8默认启用的是这种组合，可以使用 <code>java -XX:+PrintCommandLineFlags --version</code> 查看当前 jvm 默认参数。</p></blockquote><p>优缺点和适用场景和 Parallel Scavenge 相似。</p><blockquote><p>Parallel scavenge 和 Parallel old 的组合时的参数设置：</p><p>Oracle官方建议，在使用这个组合时，不要设置堆内存的最大值，垃圾回收器会根据最大暂停时间和吞吐量 自动调整内存大小。</p><ul><li><code>-XX:MaxGCPauseMillis=n</code>：设置每次垃圾回收时的最大停顿毫秒数</li><li><code>-XX:GCTimeRatio=n</code>：设置吞吐量为n（用户线程执行时间 = n/n + 1)</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存参数的开关（默认为 true）</li></ul></blockquote><h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><blockquote><p>G1（Garbage First）收集器是 jdk9及之后默认的垃圾收集器，jdk9之后最推荐使用的垃圾收集器。</p><p>它是一款主要面向服务端应用的垃圾收集器，在 多CPU 和 大内存 的场景下有很好的性能。</p></blockquote><p>G1之前的垃圾收集器，内存结构一般是连续的，如下图</p><p><img src="https://s2.loli.net/2024/01/04/qPx1payzNDCk6Jm.png" alt="image-20240104170509132"></p><p>而G1也仍是遵循分代收集理论设计的，但是它堆内存的布局与其他收集器有非常明显的差异。</p><p>它把 连续的jvm堆 划分为 多个大小相等的独立区域（Region），使得新生代和老年代不再物理隔离，每个区域可以根据需求扮演不同的空间（新生代eden空间、Survior空间或者老年代空间），这样更有利于控制垃圾回收的时间。</p><img src="https://s2.loli.net/2024/01/04/nRrgIoLJXimOUF1.png" alt="image-20240104171231201" style="zoom:33%;" /><h6 id="Region-Size"><a href="#Region-Size" class="headerlink" title="Region Size"></a>Region Size</h6><p>region 的大小 = 堆空间大小/2048 M，也可以通过参数 <code>-XX:G1HeapRegionSize=&lt;size&gt;</code>指定大小。</p><p>region size必须是2的指数幂，取值范围从1M到32M(1,2,4,8,16.32)。</p><h6 id="G1-垃圾回收方法"><a href="#G1-垃圾回收方法" class="headerlink" title="G1 垃圾回收方法"></a>G1 垃圾回收方法</h6><blockquote><p>G1 垃圾收集器的垃圾回收方法包括 Minor GC（年轻代垃圾回收）和 Mixed GC（混合垃圾回收）两种</p></blockquote><ul><li>Minor GC<ul><li><strong>触发时机</strong>：当年轻代中的Eden填满（Eden区最多占用60%）时，触发 Minor GC</li><li><strong>工作内容</strong>：Minor GC 主要采用 <strong>标记-复制</strong> 对年轻代进行垃圾回收。</li><li><strong>停顿时间</strong>：会导致短暂的STW，可以通过参数 <code>-XX:MaxGCPauseMillis=n</code>(单位：毫米，默认200) 设置每次垃圾回收时的最大暂停时间毫秒数。</li></ul></li><li>Mixed GC<ul><li><strong>触发时机</strong>：当老年代的占用达到一定的阈值（默认为45%，可通过<code>-XX:InitiatingHeapOccupancyPercent</code> 配置）时，触发 Mixed GC</li><li><strong>工作内容</strong>：Mixed GC 采用<strong>标记-复制</strong>收集所有年轻代、一部分老年代以及大对象区</li><li><strong>停顿时间</strong>： Mixed GC 的停顿时间相对较短，因为它只处理了部分老年代</li></ul></li></ul><h6 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h6><ul><li>Minor GC</li></ul><blockquote><p>新创建的对象会首先被分配到年轻代的Eden区，当G1判断到年轻代（包括Eden区和Survivor区）的空间不足以分配新对象时（年轻代默认初始占用堆空间百分比为5%，默认最大占用堆空间百分比为60%，可以由 <code>-XX:G1NewSizePercent</code> 和 <code>-XX:G1MaxNewSizePercent</code>进行配置）即当年轻代占用空间接近60%时，就会触发 Minor GC。Minor GC首先标记住Eden和Survivor区域中的存活对象，然后根据”Pause Prediction Model”算法和配置的最大暂停时间（通过 <code>-XX:MaxGCPauseMillis</code> 选项配置）来动态选择合适的区域进行垃圾回收并将存活的对象复制到新的Survivor区中，同时对象年龄+1，然后清空之前相应的区域。当某个存活的对象年龄达到了阈值（默认15），则晋升至老年代。</p><p>此处注意一个特殊情况，如果存在大对象超过参数HumongousThreshold（默认2M），它将占用，则会将它直接放入<code>Humongous</code>区域。</p></blockquote><ul><li><p>Mixed GC</p><blockquote><p>当老年代的占用达到一定的阈值（通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 配置，默认为45%）时，G1会触发 Mixed GC，主要目标是同时采用<strong>标记-复制</strong>（本质上，也是整理，不容易产生内存碎片）收集所有年轻代、一部分老年代（保证回收的最大暂停时间）以及大对象区。            </p></blockquote></li><li><p>Full GC</p><blockquote><p>当发现没有足够的空 region 存放转移的对象，会出现Full GC，此时单线程执行标记-整理算法，这个执行过程会导致用户线程暂停即STW。因此尽量保证应用的堆内存有一定的空间，防止出现内存溢出的情况。</p></blockquote></li></ul><h6 id="G1-垃圾混合回收过程"><a href="#G1-垃圾混合回收过程" class="headerlink" title="G1 垃圾混合回收过程"></a>G1 垃圾混合回收过程</h6><ul><li>初始标记 - STW：用于标记根对象（GC Root）与根对象直接关联的对象。</li><li>并发标记：通过 <code>Snapshot-At-The-Beginning</code>（SATB）原始快照算法并发标记所有存活的对象</li><li>最终标记 - STW：确认已经标记的信息的准确性，不会标记 并发标记阶段产生的新对象</li><li>并发清理：选择部分存活度较低的区域，将其中存活的对象复制到其他空闲的region中（本质整理，不容易产生内存碎片）</li></ul><p><img src="https://s2.loli.net/2024/01/04/OLQVvlA4JPMEDqf.png" alt="image-20240104214130716"></p><blockquote><p>和CMS不同点在于:最终标记不会对于并发标记阶段产生的新对象进行标记，提高了性能。</p><p>​              并发清理采用了复制算法，而CMS采用了标记清理算法，同时G1并发清理不会清理整个堆上的，而是选择部分存活度较低的区域。</p></blockquote><h6 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h6><blockquote><p>jdk8版本 g1 收集器还不够成熟，可以通过 <code>-XX:UseG1GC</code> 打开，jdk9 默认采用了g1收集器，无需参数启用。</p><p>可以通过 <code>-XX:MaxGCPauseMillis=&lt;millis&gt;</code> 设置最大暂停时间，默认200ms</p></blockquote><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>面对大堆的场景，延迟可控</li><li>不会产生内存碎片</li><li>并发标记采用 SATB算法 效率和准确性高</li></ul><h5 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h5><blockquote><ul><li>jdk8 <ul><li>单核or客户端应用：serial + serialold</li><li>关注暂停时间 - 互联网用户应用：parNew + CMS</li><li>关注吞吐量 - 后台任务：parallel scavenge + parallel old</li></ul></li><li>jdk9 g1</li></ul></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm-基础&quot;&gt;&lt;a href=&quot;#jvm-基础&quot; class=&quot;headerlink&quot; title=&quot;jvm 基础&quot;&gt;&lt;/a&gt;jvm 基础&lt;/h1&gt;&lt;h2 id=&quot;初始jvm&quot;&gt;&lt;a href=&quot;#初始jvm&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能调优工具</title>
    <link href="http://example.com/2023/09/06/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2023/09/06/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/</id>
    <published>2023-09-06T00:31:22.000Z</published>
    <updated>2023-09-07T02:57:47.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM性能调优工具"><a href="#JVM性能调优工具" class="headerlink" title="JVM性能调优工具"></a>JVM性能调优工具</h1><h2 id="常见命令行命令"><a href="#常见命令行命令" class="headerlink" title="常见命令行命令"></a>常见命令行命令</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><blockquote><p><code>jps</code>主要用于输出<code>JVM</code>中运行的进程状态信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [<span class="built_in">hostid</span>]</span><br><span class="line"><span class="comment"># [hostid]:不指定hostid默认当前主机或服务器</span></span><br><span class="line"><span class="comment"># [options]: -q：不输出类名、Jar名和传人main方法的参数</span></span><br><span class="line"><span class="comment"># -m：输出传人main方法的参数</span></span><br><span class="line"><span class="comment">#            -l：输出main类或Jar的全限名</span></span><br><span class="line"><span class="comment">#            -v：输出传人JVM的参数</span></span><br></pre></td></tr></table></figure><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><blockquote><p><code>jstack</code>主要查看某个<code>Java</code>进程内的线程堆栈信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] &lt;PID&gt;</span><br><span class="line"><span class="comment"># [options]：-l 打印额外的锁信息 jstack -l pid</span></span><br><span class="line"><span class="comment">#          ：-m 输出堆栈信息</span></span><br><span class="line"><span class="comment"># 首先找到进程ID</span></span><br><span class="line">top -H</span><br><span class="line"><span class="comment"># 查看线程信息</span></span><br><span class="line">ps -mp &lt;PID&gt; -o THREAD,tid,time</span><br><span class="line"><span class="comment"># ps -Lfp &lt;PID&gt;</span></span><br><span class="line"><span class="comment"># top -Hp &lt;PID&gt;</span></span><br><span class="line"><span class="comment"># 打印出16进制的线程ID</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> &lt;TID&gt;</span><br><span class="line"><span class="comment"># 输出进程的堆栈信息(此处TID为16进制)</span></span><br><span class="line">jstack &lt;PID&gt; | grep &lt;TID&gt;</span><br></pre></td></tr></table></figure><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><blockquote><p><code>jmap</code> 查看堆内存使用情况</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;PID&gt;</span><br><span class="line"><span class="comment"># 当运行在64位的jvm上：jmap -permstat pid</span></span><br><span class="line"><span class="comment"># [options]：-heap 进程堆内存的使用情况（GC算法、堆配置参数和各种中堆内存使用情况）</span></span><br><span class="line"><span class="comment">#            -dump dump文件离线分析 jmap -heap:format=b,file=/tmp/dump.dat &lt;PID&gt;</span></span><br><span class="line"><span class="comment"># dump文件可以通过jhat或者可视化工具visualVM等工具查看</span></span><br></pre></td></tr></table></figure><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc &lt;PID&gt; 10000 4</span><br><span class="line"><span class="comment"># 输出gc信息，采样时间间隔10000ms，采样数为4</span></span><br></pre></td></tr></table></figure><h2 id="实战问题"><a href="#实战问题" class="headerlink" title="实战问题"></a>实战问题</h2><h3 id="CPU飙高"><a href="#CPU飙高" class="headerlink" title="CPU飙高"></a>CPU飙高</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的进程信息</span></span><br><span class="line">top -H</span><br><span class="line"><span class="comment"># 查看指定进程的线程信息</span></span><br><span class="line">ps -mp &lt;PID&gt; -o THREAD,tid,time</span><br><span class="line"><span class="comment"># 将10进制线程号转为16进制</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> &lt;TID&gt;</span><br><span class="line"><span class="comment"># 拉取堆栈信息</span></span><br><span class="line">jstack &lt;PID&gt; | grep &lt;TID*&gt;</span><br></pre></td></tr></table></figure><h3 id="OOM问题"><a href="#OOM问题" class="headerlink" title="OOM问题"></a>OOM问题</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找java进程</span></span><br><span class="line">jps </span><br><span class="line"><span class="comment"># 查看gc信息(1秒钟查询4次)</span></span><br><span class="line">jstat -gc &lt;PID&gt; 1000 4</span><br><span class="line"><span class="comment"># 安装并运行arthas</span></span><br><span class="line">curl -O https://alibaba.github.io/arthas/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br><span class="line"><span class="comment"># 打卡监控仪表盘</span></span><br><span class="line">dashboard</span><br><span class="line"><span class="comment"># 堆转储</span></span><br><span class="line">heapdump /tmp/dump-1.hprof</span><br><span class="line"><span class="comment"># 使用 visualvm 离线分析</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM性能调优工具&quot;&gt;&lt;a href=&quot;#JVM性能调优工具&quot; class=&quot;headerlink&quot; title=&quot;JVM性能调优工具&quot;&gt;&lt;/a&gt;JVM性能调优工具&lt;/h1&gt;&lt;h2 id=&quot;常见命令行命令&quot;&gt;&lt;a href=&quot;#常见命令行命令&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MybatisX 自定义 FreeMarker 模块</title>
    <link href="http://example.com/2023/06/24/MybatisX%20%E8%87%AA%E5%AE%9A%E4%B9%89%20FreeMarker%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2023/06/24/MybatisX%20%E8%87%AA%E5%AE%9A%E4%B9%89%20FreeMarker%20%E6%A8%A1%E5%9D%97/</id>
    <published>2023-06-24T00:31:22.000Z</published>
    <updated>2023-09-07T02:58:27.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MybatisX-自定义-FreeMarker-模块"><a href="#MybatisX-自定义-FreeMarker-模块" class="headerlink" title="MybatisX 自定义 FreeMarker 模块"></a>MybatisX 自定义 FreeMarker 模块</h1><p><img src="https://s2.loli.net/2023/06/24/RQoyYXu3NUFlHqr.png" alt="image-20230624174416631"></p><h2 id="meta-xml"><a href="#meta-xml" class="headerlink" title=".meta.xml"></a>.meta.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">templates</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;controller.ftl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.fileName&#125;Controller&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.java&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePackage&#125;.controller&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.encoding&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePath&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;serviceInterface&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;serviceInterface.ftl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.fileName&#125;Service&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.java&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePackage&#125;.service&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.encoding&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePath&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;serviceImpl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;serviceImpl.ftl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.fileName&#125;ServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.java&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePackage&#125;.service.impl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.encoding&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePath&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapperInterface&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapperInterface.ftl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.fileName&#125;Mapper&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.java&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePackage&#125;.mapper&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.encoding&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePath&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapperXml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapperXml.ftl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.fileName&#125;Mapper&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.encoding&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意: 实体类无论如何都会生成 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1.5.x 开始 configName=domain的配置会被特殊处理, 其他配置跟随实体的配置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主要用于生成 request,response 类型的对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;domain&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;domain.ftl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.fileName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.java&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePackage&#125;.domain&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.encoding&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;domain.basePath&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">templates</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="domain-ftl"><a href="#domain-ftl" class="headerlink" title="domain.ftl"></a>domain.ftl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> $&#123;domain.packageName&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.Accessors;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.SuperBuilder;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">&lt;#list tableClass.importList as fieldType&gt;$&#123;<span class="string">&quot;\n&quot;</span>&#125;<span class="keyword">import</span> $&#123;fieldType&#125;;&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* $&#123;tableClass.shortClassName&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> YuanJW</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> $&#123;.now?string(&#x27;yyyy-MM-dd&#x27;)&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="meta">@TableName(value =&quot;$&#123;tableClass.tableName&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;$&#123;tableClass.shortClassName&#125;&quot;, description = &quot;$&#123;tableClass.remark!&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>&#123;tableClass.shortClassName&#125; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">&lt;#list tableClass.pkFields as field&gt;</span><br><span class="line">    &lt;#<span class="keyword">if</span> !field.nullable&gt;&lt;#<span class="keyword">if</span> field.jdbcType==<span class="string">&quot;VARCHAR&quot;</span>&gt;<span class="meta">@NotBlank(message = &quot;[$&#123;field.remark!&#125;]不能为空&quot;)</span>&lt;#<span class="keyword">else</span>&gt;<span class="meta">@NotNull(message = &quot;[$&#123;field.remark!&#125;]不能为空&quot;)</span>&lt;/#<span class="keyword">if</span>&gt;&lt;/#<span class="keyword">if</span>&gt;&lt;#<span class="keyword">if</span> field.jdbcType==<span class="string">&quot;VARCHAR&quot;</span>&gt;$&#123;<span class="string">&quot;\n    &quot;</span>&#125;<span class="meta">@Size(max = $&#123;field.columnLength?c&#125;, message = &quot;编码长度不能超过$&#123;field.columnLength?c&#125;&quot;)</span>&lt;/#<span class="keyword">if</span>&gt;&lt;#<span class="keyword">if</span> field.jdbcType==<span class="string">&quot;VARCHAR&quot;</span>&gt;<span class="meta">@Length(max = $&#123;field.columnLength?c&#125;, message = &quot;编码长度不能超过$&#123;field.columnLength?c&#125;&quot;)</span>&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;$&#123;field.columnName&#125;&quot;&lt;#if field.autoIncrement&gt;, type = IdType.AUTO&lt;/#if&gt;)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;$&#123;field.remark!&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> $&#123;field.shortTypeName&#125; $&#123;field.fieldName&#125;;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line">&lt;#list tableClass.baseBlobFields as field&gt;</span><br><span class="line">    &lt;#<span class="keyword">if</span> !field.nullable&gt;&lt;#<span class="keyword">if</span> field.jdbcType==<span class="string">&quot;VARCHAR&quot;</span>&gt;<span class="meta">@NotBlank(message = &quot;[$&#123;field.remark!&#125;]不能为空&quot;)</span>&lt;#<span class="keyword">else</span>&gt;<span class="meta">@NotNull(message = &quot;[$&#123;field.remark!&#125;]不能为空&quot;)</span>&lt;/#<span class="keyword">if</span>&gt;&lt;/#<span class="keyword">if</span>&gt;&lt;#<span class="keyword">if</span> field.jdbcType==<span class="string">&quot;VARCHAR&quot;</span>&gt;$&#123;<span class="string">&quot;\n    &quot;</span>&#125;<span class="meta">@Size(max = $&#123;field.columnLength?c&#125;, message = &quot;编码长度不能超过$&#123;field.columnLength?c&#125;&quot;)</span>&lt;/#<span class="keyword">if</span>&gt;&lt;#<span class="keyword">if</span> field.jdbcType==<span class="string">&quot;VARCHAR&quot;</span>&gt;$&#123;<span class="string">&quot;\n    &quot;</span>&#125;<span class="meta">@Length(max = $&#123;field.columnLength?c&#125;, message = &quot;编码长度不能超过$&#123;field.columnLength?c&#125;&quot;)</span>&lt;/#<span class="keyword">if</span>&gt;&lt;#<span class="keyword">if</span> field.jdbcType==<span class="string">&quot;TIMESTAMP&quot;</span>&gt;$&#123;<span class="string">&quot;\n    &quot;</span>&#125;<span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span>&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;$&#123;field.remark!&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> $&#123;field.shortTypeName&#125; $&#123;field.fieldName&#125;;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mapperInterface-ftl"><a href="#mapperInterface-ftl" class="headerlink" title="mapperInterface.ftl"></a>mapperInterface.ftl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> $&#123;mapperInterface.packageName&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $&#123;tableClass.fullClassName&#125;;</span><br><span class="line">&lt;#<span class="keyword">if</span> tableClass.pkFields??&gt;</span><br><span class="line">    &lt;#list tableClass.pkFields as field&gt;&lt;#assign pkName&gt;$&#123;field.shortTypeName&#125;&lt;/#assign&gt;&lt;/#list&gt;</span><br><span class="line">&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* $&#123;mapperInterface.fileName&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> YuanJW</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> $&#123;.now?string(&#x27;yyyy-MM-dd&#x27;)&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">$</span>&#123;mapperInterface.fileName&#125; <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;$&#123;tableClass.shortClassName&#125;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 新增$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> $&#123;tableClass.shortClassName?uncap_first&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> save$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据id查询$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> $&#123;tableClass.shortClassName&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    $&#123;tableClass.shortClassName&#125; get$&#123;tableClass.shortClassName&#125;ById(Long id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据搜索条件获取$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;列表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> $&#123;tableClass.shortClassName?uncap_first&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    List&lt;$&#123;tableClass.shortClassName&#125;&gt; list$&#123;tableClass.shortClassName&#125;s($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> $&#123;tableClass.shortClassName?uncap_first&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> update$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量删除$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> delete$&#123;tableClass.shortClassName&#125;s(List&lt;Long&gt; ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 统计$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> $&#123;tableClass.shortClassName?uncap_first&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> count$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mapper-ftl"><a href="#mapper-ftl" class="headerlink" title="mapper.ftl"></a>mapper.ftl</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;$&#123;mapperInterface.packageName&#125;.$&#123;baseInfo.fileName&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;$&#123;tableClass.fullClassName&#125;&quot;</span>&gt;</span></span><br><span class="line">    &lt;#list tableClass.pkFields as field&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;$&#123;field.fieldName&#125;&quot;</span> <span class="attr">column</span>=<span class="string">&quot;$&#123;field.columnName&#125;&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;$&#123;field.jdbcType&#125;&quot;</span>/&gt;</span></span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;#list tableClass.baseFields as field&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;$&#123;field.fieldName&#125;&quot;</span> <span class="attr">column</span>=<span class="string">&quot;$&#123;field.columnName&#125;&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;$&#123;field.jdbcType&#125;&quot;</span>/&gt;</span></span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">        &lt;#list tableClass.allFields as field&gt;$&#123;field.columnName&#125;&lt;#sep&gt;,$&#123;&quot;\n        &quot;&#125;&lt;/#list&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Example_Where_Clause&quot;</span>&gt;</span></span><br><span class="line">    &lt;#list tableClass.allFields as field&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;$&#123;field.fieldName&#125; != null&quot;</span>&gt;</span>and $&#123;field.columnName&#125; = $&#123;&#x27;#&#x27;&#125;&#123;$&#123;field.fieldName&#125;,jdbcType=$&#123;field.jdbcType&#125;&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save$&#123;tableClass.shortClassName&#125;&quot;</span>&lt;#<span class="attr">if</span> (<span class="attr">tableClass.pkFields</span>?<span class="attr">size</span>==<span class="string">1)</span>&gt;</span> keyColumn=&quot;$&#123;tableClass.pkFields[0].columnName&#125;&quot; keyProperty=&quot;$&#123;tableClass.pkFields[0].fieldName&#125;&quot; parameterType=&quot;$&#123;tableClass.fullClassName&#125;&quot; useGeneratedKeys=&quot;true&quot;&lt;/#if&gt;&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span>&gt;</span></span><br><span class="line">            SELECT LAST_INSERT_ID()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        INSERT INTO $&#123;tableClass.tableName&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            &lt;#list tableClass.allFields as field&gt;</span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;$&#123;field.fieldName&#125; != null&quot;</span>&gt;</span>$&#123;field.columnName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            &lt;/#list&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            &lt;#list tableClass.allFields as field&gt;</span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;$&#123;field.fieldName&#125; != null&quot;</span>&gt;</span>$&#123;&#x27;#&#x27;&#125;&#123;$&#123;field.fieldName&#125;,jdbcType=$&#123;field.jdbcType&#125;&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            &lt;/#list&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;get$&#123;tableClass.shortClassName&#125;ById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">        FROM $&#123;tableClass.tableName&#125;</span><br><span class="line">        WHERE &lt;#list tableClass.pkFields as field&gt;$&#123;field.columnName&#125; = $&#123;&#x27;#&#x27;&#125;&#123;$&#123;field.fieldName&#125;,jdbcType=$&#123;field.jdbcType&#125;&#125; &lt;#if field_has_next&gt;AND&lt;/#if&gt;&lt;/#list&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list$&#123;tableClass.shortClassName&#125;s&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;$&#123;tableClass.fullClassName&#125;&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">        FROM $&#123;tableClass.tableName&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete$&#123;tableClass.shortClassName&#125;s&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM $&#123;tableClass.tableName&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        &lt;#list tableClass.pkFields as field&gt; $&#123;field.columnName&#125; IN</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">                $&#123;&#x27;#&#x27;&#125;&#123;item&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        &lt;/#list&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update$&#123;tableClass.shortClassName&#125;&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;$&#123;tableClass.fullClassName&#125;&quot;</span>&gt;</span></span><br><span class="line">        UPDATE $&#123;tableClass.tableName&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        &lt;#list tableClass.baseBlobFields as field&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;$&#123;field.fieldName&#125; != null&quot;</span>&gt;</span>$&#123;field.columnName&#125; = $&#123;&#x27;#&#x27;&#125;&#123;$&#123;field.fieldName&#125;,jdbcType=$&#123;field.jdbcType&#125;&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        &lt;/#list&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        WHERE &lt;#list tableClass.pkFields as field&gt;$&#123;field.columnName&#125; = $&#123;&#x27;#&#x27;&#125;&#123;$&#123;field.fieldName&#125;,jdbcType=$&#123;field.jdbcType&#125;&#125; &lt;#if field_has_next&gt;AND&lt;/#if&gt;&lt;/#list&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;count$&#123;tableClass.shortClassName&#125;&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;$&#123;tableClass.fullClassName&#125;&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        SELECT COUNT(*) FROM $&#123;tableClass.tableName&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="serviceInterface-ftl"><a href="#serviceInterface-ftl" class="headerlink" title="serviceInterface.ftl"></a>serviceInterface.ftl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> $&#123;baseInfo.packageName&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $&#123;tableClass.fullClassName&#125;;</span><br><span class="line">&lt;#<span class="keyword">if</span> baseService??&amp;&amp;baseService!=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> $&#123;baseService&#125;;</span><br><span class="line">    &lt;#list baseService?split(<span class="string">&quot;.&quot;</span>) as simpleName&gt;</span><br><span class="line">        &lt;#<span class="keyword">if</span> !simpleName_has_next&gt;</span><br><span class="line">            &lt;#assign serviceSimpleName&gt;$&#123;simpleName&#125;&lt;/#assign&gt;</span><br><span class="line">        &lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* $&#123;baseInfo.fileName&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> YuanJW</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> $&#123;.now?string(&#x27;yyyy-MM-dd&#x27;)&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">$</span>&#123;baseInfo.fileName&#125; <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;$&#123;tableClass.shortClassName&#125;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 新增$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> $&#123;tableClass.shortClassName?uncap_first&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> insert$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> $&#123;tableClass.shortClassName?uncap_first&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    List&lt;$&#123;tableClass.shortClassName&#125;&gt; list$&#123;tableClass.shortClassName&#125;s($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据id获取$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    $&#123;tableClass.shortClassName&#125; get$&#123;tableClass.shortClassName&#125;ById(Long id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> $&#123;tableClass.shortClassName?uncap_first&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> update$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量删除$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> delete$&#123;tableClass.shortClassName&#125;ByIds(List&lt;Long&gt; ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 统计$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> $&#123;tableClass.shortClassName?uncap_first&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> count$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServiceImpl-ftl"><a href="#ServiceImpl-ftl" class="headerlink" title="ServiceImpl.ftl"></a>ServiceImpl.ftl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> $&#123;baseInfo.packageName&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> $&#123;tableClass.fullClassName&#125;;</span><br><span class="line"><span class="keyword">import</span> $&#123;serviceInterface.packageName&#125;.$&#123;serviceInterface.fileName&#125;;</span><br><span class="line"><span class="keyword">import</span> $&#123;mapperInterface.packageName&#125;.$&#123;mapperInterface.fileName&#125;;</span><br><span class="line">&lt;#<span class="keyword">if</span> baseService??&amp;&amp;baseService!=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> $&#123;baseService&#125;;</span><br><span class="line">    &lt;#list baseService?split(<span class="string">&quot;.&quot;</span>) as simpleName&gt;</span><br><span class="line">        &lt;#<span class="keyword">if</span> !simpleName_has_next&gt;</span><br><span class="line">            &lt;#assign serviceSimpleName&gt;$&#123;simpleName&#125;&lt;/#assign&gt;</span><br><span class="line">        &lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* $&#123;baseInfo.fileName&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> YuanJW</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> $&#123;.now?string(&#x27;yyyy-MM-dd&#x27;)&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>&#123;baseInfo.fileName&#125; <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;$&#123;mapperInterface.fileName&#125;, $&#123;tableClass.shortClassName&#125;&gt; <span class="keyword">implements</span> <span class="title class_">$</span>&#123;serviceInterface.fileName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> $&#123;mapperInterface.fileName&#125; $&#123;mapperInterface.fileName?uncap_first&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> insert$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> $&#123;mapperInterface.fileName?uncap_first&#125;.insert($&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> $&#123;tableClass.shortClassName&#125; get$&#123;tableClass.shortClassName&#125;ById(Long id) &#123;</span><br><span class="line">        <span class="keyword">return</span> $&#123;mapperInterface.fileName?uncap_first&#125;.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;$&#123;tableClass.shortClassName&#125;&gt; list$&#123;tableClass.shortClassName&#125;s($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> $&#123;mapperInterface.fileName?uncap_first&#125;.list$&#123;tableClass.shortClassName&#125;s($&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> update$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> $&#123;mapperInterface.fileName?uncap_first&#125;.update$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> delete$&#123;tableClass.shortClassName&#125;ByIds(List&lt;Long&gt; ids) &#123;</span><br><span class="line">        <span class="keyword">return</span> $&#123;mapperInterface.fileName?uncap_first&#125;.deleteBatchIds(ids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> count$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> $&#123;mapperInterface.fileName?uncap_first&#125;.count$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="controller-ftl"><a href="#controller-ftl" class="headerlink" title="controller.ftl"></a>controller.ftl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> $&#123;controller.packageName&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.common.CommonPage;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.common.CommonResult;</span><br><span class="line"><span class="keyword">import</span> $&#123;tableClass.fullClassName&#125;;</span><br><span class="line"><span class="keyword">import</span> $&#123;serviceInterface.packageName&#125;.$&#123;serviceInterface.fileName&#125;;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParams;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* $&#123;controller.fileName&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> YuanJW</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> $&#123;.now?string(&#x27;yyyy-MM-dd&#x27;)&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/$&#123;tableClass.shortClassName?uncap_first&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;$&#123;controller.fileName&#125;&quot;, value = &quot;$&#123;tableClass.remark!&#125;Controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>&#123;controller.fileName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> $&#123;serviceInterface.fileName&#125; $&#123;serviceInterface.fileName?uncap_first&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/insert&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> $&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> $&#123;serviceInterface.fileName?uncap_first&#125;.insert$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.success(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonResult.failed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;修改$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/update&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> $&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> $&#123;serviceInterface.fileName?uncap_first&#125;.update$&#123;tableClass.shortClassName&#125;($&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.success(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonResult.failed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;分页获取$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">        @ApiImplicitParam(name = &quot;pageNum&quot;, value = &quot;页码&quot;,</span></span><br><span class="line"><span class="meta">        defaultValue = &quot;1&quot;, paramType = &quot;query&quot;, dataType = &quot;integer&quot;),</span></span><br><span class="line"><span class="meta">        @ApiImplicitParam(name = &quot;pageSize&quot;, value = &quot;每页显示数量&quot;,</span></span><br><span class="line"><span class="meta">        defaultValue = &quot;5&quot;, allowableValues = &quot;0,5,10,15,20&quot;, paramType = &quot;query&quot;, dataType = &quot;integer&quot;),</span></span><br><span class="line"><span class="meta">        @ApiImplicitParam(name = &quot;orderBy&quot;, value = &quot;排序字段&quot;, paramType = &quot;query&quot;, dataType = &quot;string&quot;)&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/list&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;CommonPage&lt;$&#123;tableClass.shortClassName&#125;&gt;&gt; list($&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName?uncap_first&#125;,</span><br><span class="line">                                                <span class="meta">@RequestParam(required = false, defaultValue = &quot;1&quot;)</span> Integer pageNum,</span><br><span class="line">                                                <span class="meta">@RequestParam(required = false, defaultValue = &quot;5&quot;)</span> Integer pageSize,</span><br><span class="line">                                                <span class="meta">@RequestParam(required = false)</span> String orderBy) &#123;</span><br><span class="line">        PageHelper.startPage(pageNum, pageSize, orderBy + <span class="string">&quot; desc&quot;</span>);</span><br><span class="line">        List&lt;$&#123;tableClass.shortClassName&#125;&gt; list = $&#123;serviceInterface.fileName?uncap_first&#125;.list$&#123;tableClass.shortClassName&#125;s($&#123;tableClass.shortClassName?uncap_first&#125;);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(CommonPage.restPage(list));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id查询$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/&#123;id&#125;&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;$&#123;tableClass.shortClassName&#125;&gt; detail(<span class="meta">@PathVariable</span> Long id) &#123;</span><br><span class="line">        $&#123;tableClass.shortClassName&#125; $&#123;tableClass.shortClassName&#125; = $&#123;serviceInterface.fileName?uncap_first&#125;.get$&#123;tableClass.shortClassName&#125;ById(id);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success($&#123;tableClass.shortClassName&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;批量删除$&#123;tableClass.remark!?substring(0, tableClass.remark?length-1)&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/remove&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">remove</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> $&#123;serviceInterface.fileName?uncap_first&#125;.delete$&#123;tableClass.shortClassName&#125;ByIds(ids);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.success(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonResult.failed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MybatisX-自定义-FreeMarker-模块&quot;&gt;&lt;a href=&quot;#MybatisX-自定义-FreeMarker-模块&quot; class=&quot;headerlink&quot; title=&quot;MybatisX 自定义 FreeMarker 模块&quot;&gt;&lt;/a&gt;MybatisX</summary>
      
    
    
    
    
    <category term="tool" scheme="http://example.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://example.com/2023/06/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2023/06/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2023-06-10T02:31:22.000Z</published>
    <updated>2023-06-15T05:46:27.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="系统服务管理"><a href="#系统服务管理" class="headerlink" title="系统服务管理"></a>系统服务管理</h2><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><blockquote><p><code>Systemctl</code>命令是<code>Service</code>和<code>chkconfig</code>命令的组合体，可用于<strong>管理系统</strong></p></blockquote><h4 id="输出系统各个服务的状态"><a href="#输出系统各个服务的状态" class="headerlink" title="输出系统各个服务的状态"></a>输出系统各个服务的状态</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/d2BxClOjs897YZV.png" alt="image-20230611145509598"></p><h4 id="查看服务的运行状态"><a href="#查看服务的运行状态" class="headerlink" title="查看服务的运行状态"></a>查看服务的运行状态</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/kRXjOzF5wx8ch7y.png" alt="image-20230611145212350"></p><h4 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><h4 id="重新启动服务"><a href="#重新启动服务" class="headerlink" title="重新启动服务"></a>重新启动服务</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload firewalld</span><br></pre></td></tr></table></figure><h4 id="禁止服务开机自启动"><a href="#禁止服务开机自启动" class="headerlink" title="禁止服务开机自启动"></a>禁止服务开机自启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><h4 id="开启服务开机自启动"><a href="#开启服务开机自启动" class="headerlink" title="开启服务开机自启动"></a>开启服务开机自启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> firewalld</span><br></pre></td></tr></table></figure><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><blockquote><p>列出指定目录下的所有文件</p></blockquote><p>列出<code>/</code>目录下的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/k3uFzoLSnwgNf2I.png" alt="image-20230611150319289"></p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><blockquote><p>获取目前所在工作目录的绝对路径</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/vPpo2TK3kmB5iln.png" alt="image-20230611150328686"></p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><blockquote><p> 改变当前工作目录</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br></pre></td></tr></table></figure><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><blockquote><p>显示或修改系统时间与日期</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><blockquote><p>用于设置用户密码</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><blockquote><p>改变用户身份（切换到超级用户）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su ~</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><blockquote><p>用于清除屏幕信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><blockquote><p>显示指定命令的帮助信息 （输入 q 退出）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><blockquote><p>查询系统处于的运行级别</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -r</span><br></pre></td></tr></table></figure><blockquote><p>显示目前登录到系统的用户</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -buT</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/tRrdahcoUp168sl.png" alt="image-20230611151342802"></p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><blockquote><p>显示系统内存状态（单位MB）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/rCbZKlL7c1HMajk.png" alt="image-20230611151317775"></p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><blockquote><p>显示系统的进程运行的状态</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/btjrY1yfdCkuK7a.png" alt="image-20230611151302013"></p><blockquote><p>查看 <code>sshd</code> 进程的运行状态</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><blockquote><p>查看即时活跃的进程，类似Windows的任务管理器</p></blockquote><p><img src="https://s2.loli.net/2023/06/11/TSZYku3ihAMPy9B.png" alt="image-20230611151608498"></p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><blockquote><p>创建目录</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span></span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><blockquote><p>分页查看文件 （例如每页10行查看文件）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -c -10 /var/log/boot.log</span><br></pre></td></tr></table></figure><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><blockquote><p>查看文件并标名行号</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -Ab /var/log/boot.log</span><br></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><blockquote><p>创建文件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> text.txt</span><br></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><blockquote><p>删除文件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> text.txt</span><br></pre></td></tr></table></figure><blockquote><p>强制删除某个目录以及其子目录</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf testdir/</span><br></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><blockquote><p>用于拷贝文件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /mydata/test1 /mydata/test2</span><br></pre></td></tr></table></figure><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><blockquote><p>移动或者覆盖文件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> text1.txt text2.txt</span><br></pre></td></tr></table></figure><h2 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><h4 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h4><blockquote><p>将<code>/etc</code>文件夹中的文件归档到文件<code>etc.tar</code>（并不会进行压缩）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mydata/etc/</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf /mydata/etc/etc.tar /etc</span><br></pre></td></tr></table></figure><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><blockquote><p>使用 <code>gzip</code> 压缩文件夹<code>/etc</code>中的文件到文件<code>etc.tar.gz</code></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf /mydata/etc/etc.tar.gz /etc</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>bzip2</code> 压缩文件夹<code>/etc</code>中的文件到文件<code>etc.tar.gz</code></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf /mydata/etc/etc.tar.bz2 /etc</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/BcXjDznLE9o8GHl.png" alt="image-20230611170308568"></p><h4 id="分页查看压缩包中内容"><a href="#分页查看压缩包中内容" class="headerlink" title="分页查看压缩包中内容"></a>分页查看压缩包中内容</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf /mydata/etc/etc.tar.gz | more -c -10</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/26IqJQrGdovEuYH.png" alt="image-20230611170505806"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><blockquote><p>解压文件到当前目录</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /mydata/etc/etc.tar.gz </span><br></pre></td></tr></table></figure><blockquote><p>解压文件到指定目录</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /mydata/etc/etc.tar.gz -C /mydata/etc</span><br></pre></td></tr></table></figure><h2 id="磁盘和网络管理"><a href="#磁盘和网络管理" class="headerlink" title="磁盘和网络管理"></a>磁盘和网络管理</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><blockquote><p>查看磁盘空间占用情况</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/rADUipJcPOSCmk2.png" alt="image-20230611170916334"></p><h3 id="dh"><a href="#dh" class="headerlink" title="dh"></a>dh</h3><blockquote><p>查看当前目录下的文件及文件夹所占大小</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h --max-depth=1 ./*</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/DHF4zuR7M3x6brP.png" alt="image-20230611171431823"></p><h3 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h3><blockquote><p>显示当前网络接口状态</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/qh7ijmeoQvPdFb9.png" alt="image-20230611171610564"></p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><h4 id="查看当前路由信息"><a href="#查看当前路由信息" class="headerlink" title="查看当前路由信息"></a>查看当前路由信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -rn</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/k3u7en4TcVjygXd.png" alt="image-20230611171910730"></p><h4 id="查看所有有效的TCP连接"><a href="#查看所有有效的TCP连接" class="headerlink" title="查看所有有效的TCP连接"></a>查看所有有效的TCP连接</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/eNFBicpmI5UDKjQ.png" alt="image-20230611171943883"></p><h4 id="查看系统中启动的监听服务"><a href="#查看系统中启动的监听服务" class="headerlink" title="查看系统中启动的监听服务"></a>查看系统中启动的监听服务</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/GiRr7QDFc5B6vY8.png" alt="image-20230611172137234"></p><h4 id="查看处于连接状态的系统资源信息"><a href="#查看处于连接状态的系统资源信息" class="headerlink" title="查看处于连接状态的系统资源信息"></a>查看处于连接状态的系统资源信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -atunp</span><br></pre></td></tr></table></figure><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><blockquote><p>从网络上下载文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://....</span><br></pre></td></tr></table></figure><h2 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h2><h3 id="安装上传下载工具-lrzsz"><a href="#安装上传下载工具-lrzsz" class="headerlink" title="安装上传下载工具 lrzsz"></a>安装上传下载工具 <code>lrzsz</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y lrzsz</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz fileName</span><br></pre></td></tr></table></figure><h2 id="软件安装与管理"><a href="#软件安装与管理" class="headerlink" title="软件安装与管理"></a>软件安装与管理</h2><h3 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h3><blockquote><p>RPM是<code>Red-Hat Package Manager</code>的缩写，一种Linux下通用的软件包管理方式，可用于安装和管理<code>.rpm</code>结尾的软件包</p></blockquote><h4 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh nginx-1.14.0-1.el7_4.ngx.x86_64.rpm</span><br></pre></td></tr></table></figure><h4 id="模糊搜索软件包"><a href="#模糊搜索软件包" class="headerlink" title="模糊搜索软件包"></a>模糊搜索软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep nginx</span><br></pre></td></tr></table></figure><h4 id="精确查找软件包"><a href="#精确查找软件包" class="headerlink" title="精确查找软件包"></a>精确查找软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa nginx</span><br></pre></td></tr></table></figure><h4 id="查询软件包的安装路径"><a href="#查询软件包的安装路径" class="headerlink" title="查询软件包的安装路径"></a>查询软件包的安装路径</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><h4 id="查看软件包的概要信息"><a href="#查看软件包的概要信息" class="headerlink" title="查看软件包的概要信息"></a>查看软件包的概要信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><h4 id="验证软件包内容和安装文件是否一致"><a href="#验证软件包内容和安装文件是否一致" class="headerlink" title="验证软件包内容和安装文件是否一致"></a>验证软件包内容和安装文件是否一致</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -V nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><h4 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><h4 id="删除软件包"><a href="#删除软件包" class="headerlink" title="删除软件包"></a>删除软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><blockquote><p>Yum是<code>Yellow dog Updater, Modified</code>的缩写，能够在线自动下载RPM包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</p></blockquote><h4 id="安装软件包-1"><a href="#安装软件包-1" class="headerlink" title="安装软件包"></a>安装软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><h4 id="检查更新软件包"><a href="#检查更新软件包" class="headerlink" title="检查更新软件包"></a>检查更新软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum check-update</span><br></pre></td></tr></table></figure><h4 id="更新指定的软件包"><a href="#更新指定的软件包" class="headerlink" title="更新指定的软件包"></a>更新指定的软件包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update nginx</span><br></pre></td></tr></table></figure><h4 id="在资源库中查找软件包信息"><a href="#在资源库中查找软件包信息" class="headerlink" title="在资源库中查找软件包信息"></a>在资源库中查找软件包信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info nginx*</span><br></pre></td></tr></table></figure><h4 id="列出已经安装的所有软件包"><a href="#列出已经安装的所有软件包" class="headerlink" title="列出已经安装的所有软件包"></a>列出已经安装的所有软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info installed</span><br></pre></td></tr></table></figure><h4 id="列出软件包名称"><a href="#列出软件包名称" class="headerlink" title="列出软件包名称"></a>列出软件包名称</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list nginx*</span><br></pre></td></tr></table></figure><h4 id="模糊搜索软件包-1"><a href="#模糊搜索软件包-1" class="headerlink" title="模糊搜索软件包"></a>模糊搜索软件包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search nginx</span><br></pre></td></tr></table></figure><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="用户信息查看"><a href="#用户信息查看" class="headerlink" title="用户信息查看"></a>用户信息查看</h3><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br></pre></td></tr></table></figure><p><img src="/Users/yuanjianwei/Library/Application%20Support/typora-user-images/image-20230611175136841.png" alt="image-20230611175136841"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户信息格式（用户名：密码：用户标识号：组标识号：组注释性描述：主目录：默认shell）</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><h4 id="查看用户组信息"><a href="#查看用户组信息" class="headerlink" title="查看用户组信息"></a>查看用户组信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/group</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/8QKhGDPAwLEktWi.png" alt="image-20230611175340673"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 组名:密码:组标识号:组内用户列表</span></span><br><span class="line">root:x:0</span><br></pre></td></tr></table></figure><h3 id="passwd-1"><a href="#passwd-1" class="headerlink" title="passwd"></a>passwd</h3><blockquote><p>用于设置用户密码</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure><h3 id="su-1"><a href="#su-1" class="headerlink" title="su"></a>su</h3><blockquote><p>改变用户身份</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到root用户</span></span><br><span class="line">su ~</span><br></pre></td></tr></table></figure><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><blockquote><p>添加用户组，使用<code>-g</code>可以设置用户组的标志号</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 1024 testgroup</span><br></pre></td></tr></table></figure><h3 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h3><blockquote><p>删除用户组</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel testgroup</span><br></pre></td></tr></table></figure><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><blockquote><p>添加用户，<code>-u</code> 设置标志号，<code>-g</code> 设置主用户组</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -u 1024 -g testgroup testuser</span><br></pre></td></tr></table></figure><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><blockquote><p>修改用户所属用户组</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g docker testuser</span><br></pre></td></tr></table></figure><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><blockquote><p>删除用户，使用 <code>-r</code> 删除用户主目录</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel testuser -r</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/EyOYweaqHTL29QJ.png" alt="image-20230611180332753"></p><h2 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h2><blockquote><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p></blockquote><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><blockquote><p>修改所属用户与组</p></blockquote><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><blockquote><p>修改用户的权限</p></blockquote><p>使用 <strong>ll</strong> 或者 <strong>ls –l</strong> 命令来显示一个文件的属性以及文件所属的用户和组：</p><p><img src="https://s2.loli.net/2023/06/11/yMbT5ZEdKvo36AF.png" alt="image-20230611183141796"></p><p><img src="https://s2.loli.net/2023/06/11/Yovs4a5plLeMJ3E.png" alt="image-20230611183240381"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h1&gt;&lt;h2 id=&quot;系统服务管理&quot;&gt;&lt;a href=&quot;#系统服务管理&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Spring Retry</title>
    <link href="http://example.com/2023/06/06/Spring%20Retry/"/>
    <id>http://example.com/2023/06/06/Spring%20Retry/</id>
    <published>2023-06-06T00:31:22.000Z</published>
    <updated>2023-09-07T02:59:48.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Retry"><a href="#Spring-Retry" class="headerlink" title="Spring Retry"></a>Spring Retry</h1><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><blockquote><p>重试是指当一个程序运行过程中，遇到网络延迟、中断等情况时，为了保证程序<strong>容错性</strong>、<strong>可用性</strong>、<strong>一致性</strong>等一个措施。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Spring Retry 是一套 Spring 实现的一套重试机制，主要功能点在于<strong>重试</strong>和<strong>熔断</strong>。它被广泛用于<code>Spring Batch</code>,<code>Spring Integration</code>, <code>Spring for Apache Hadoop</code> 等项目。它主要是针对可能抛异常的一些调用操作，进行有策略的重试</p><p>Spring Retry 提供了 <strong>注解</strong> 和 <strong>编程</strong> 的两种支持，提供了 <code>RetryTemplate</code> 的支持</p></blockquote><p><img src="https://s2.loli.net/2023/06/17/1UoJ3jAHawYdshS.webp" alt="图一"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Spring-Retry-编程式"><a href="#Spring-Retry-编程式" class="headerlink" title="Spring Retry 编程式"></a>Spring Retry 编程式</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteAccessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteAccessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteAccessException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteAccessException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任务方法"><a href="#任务方法" class="headerlink" title="任务方法"></a>任务方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span></span><br><span class="line">            LoggerFactory.getLogger(RetryTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">task</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;开启重试任务&quot;</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">switch</span> (random.nextInt(<span class="number">4</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                logger.info(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数异常&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                logger.info(<span class="string">&quot;正确返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                logger.info(<span class="string">&quot;错误返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.info(<span class="string">&quot;抛出自定义异常&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteAccessException</span>(<span class="string">&quot;远程访问异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>SpringRetryTemplate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoRetryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringDemoRetryTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试间隔时间（单位：ms）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">retryInterval</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRetryTimes</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建重试模版实例</span></span><br><span class="line">        <span class="type">RetryTemplate</span> <span class="variable">retryTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryTemplate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可重试的异常映射 表示哪些异常需要重试 key表示异常的字节码 value为true表示需要重试</span></span><br><span class="line">        Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;, Boolean&gt; retryableExceptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        retryableExceptions.put(RemoteAccessException.class, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置重试策略 设置最大重试次数和可重试的异常映射</span></span><br><span class="line">        <span class="type">SimpleRetryPolicy</span> <span class="variable">simpleRetryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRetryPolicy</span>(maxRetryTimes, retryableExceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置重试回退策略</span></span><br><span class="line">        <span class="type">FixedBackOffPolicy</span> <span class="variable">fixedBackOffPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOffPolicy</span>();</span><br><span class="line">        fixedBackOffPolicy.setBackOffPeriod(retryInterval);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定重试策略和重试回退策略</span></span><br><span class="line">        retryTemplate.setRetryPolicy(simpleRetryPolicy);</span><br><span class="line">        retryTemplate.setBackOffPolicy(fixedBackOffPolicy);</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> retryTemplate.execute(</span><br><span class="line">                <span class="comment">// RetryCallback</span></span><br><span class="line">                context -&gt; &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">task</span> <span class="operator">=</span> RetryTask.task();</span><br><span class="line">                    logger.info(<span class="string">&quot;调用的结果：&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    <span class="keyword">return</span> task;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// RecoveryCallback</span></span><br><span class="line">                context -&gt; &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;已经达到最大重试次数或者抛出不重试的异常&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        logger.info(<span class="string">&quot;执行结果：&#123;&#125;&quot;</span>, execute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RetryTemplate</code> 承担了重试执行者的角色，它可以设置<code>RetryPolicy</code>(重试策略)，<code>BackOffPolicy</code>（固定的回退策略）</p><p><code>RetryTemplate</code>通过<code>execute</code>提交执行操作，需要准备<code>RetryCallback</code> 和<code>BackOffPolicy</code> 两个类实例</p><p><code>RetryCallback</code> 是<strong>重试回调逻辑实例</strong>，包装正常的功能操作，<code>RecoveryCallback</code>实现的是整个执行<strong>操作结束的恢复操作实例</strong></p><p>只有在调用的时候抛出了异常，并且<strong>异常是在<code>exceptionMap</code>中配置的异常</strong>，才会执行<strong>重试</strong>操作，否则就调用到<code>excute</code>方法的第二个执行方法<code>RecoveryCallback</code>中</p><h4 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h4><p><img src="https://s2.loli.net/2023/06/18/N5e39yB1WoZLVCY.png" alt="image-20230618002750195"></p><p><img src="https://s2.loli.net/2023/06/18/c4IgQfw2q7EYyeO.png" alt="image-20230618002940390"></p><h4 id="重试回退策略"><a href="#重试回退策略" class="headerlink" title="重试回退策略"></a>重试回退策略</h4><p><img src="https://s2.loli.net/2023/06/18/89SthiVP6dUb2Z7.png" alt="image-20230618003033222"></p><p><img src="https://s2.loli.net/2023/06/18/Y5ATu31GEF78Z9m.png" alt="image-20230618003203978"></p><h3 id="Spring-Retry-声明式"><a href="#Spring-Retry-声明式" class="headerlink" title="Spring Retry 声明式"></a>Spring Retry 声明式</h3><h4 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoRetry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringDemoRetry.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h4><blockquote><p>我们只要在需要重试的方法上加<code>@Retryable</code>，在重试失败的回调方法上加<code>@Recover</code></p></blockquote><p><img src="https://s2.loli.net/2023/06/18/4ywbxnKJIpFQoGf.png" alt="图片"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SpringRetryService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试回退方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recover</span><span class="params">(Exception e)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRetryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SpringRetryService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringRetryServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Retryable(value = &#123;RemoteAccessException.class&#125;, maxAttempts = 3, backoff = @Backoff(delay = 2000L, multiplier = 2))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RetryTask.task();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Recover</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">recover</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;达到最大重试次数,或抛出了一个没有指定进行重试的异常:&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@Retryable</code> 表示 <code>RemoteAccessException</code> 的异常才进行重试，<code>@Backoff(delay = 2000L, multiplier = 2))</code> 表示第一次间隔2秒，以后都是次数的2倍，也就是第二次4秒，第三次6秒</p></blockquote><h4 id="调用测试类"><a href="#调用测试类" class="headerlink" title="调用测试类"></a>调用测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">call</span> <span class="operator">=</span> springRetryService.call();</span><br><span class="line">    logger.info(<span class="string">&quot;--结果：&#123;&#125;--&quot;</span>, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247556669&amp;idx=2&amp;sn=a41ac98ab32cb482588b9059773b54fb&amp;chksm=fa4a618ccd3de89a63cb99c44077302da698ec6c9ac0870783cd12df62002416d522a5267e42&amp;mpshare=1&amp;scene=24&amp;srcid=0617EnhGZStTL20lp7GJvG2x&amp;sharer_sharetime=1687010876772&amp;sharer_shareid=470e895f697284625270102fdb3d1bae#rd]">https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247556669&amp;idx=2&amp;sn=a41ac98ab32cb482588b9059773b54fb&amp;chksm=fa4a618ccd3de89a63cb99c44077302da698ec6c9ac0870783cd12df62002416d522a5267e42&amp;mpshare=1&amp;scene=24&amp;srcid=0617EnhGZStTL20lp7GJvG2x&amp;sharer_sharetime=1687010876772&amp;sharer_shareid=470e895f697284625270102fdb3d1bae#rd]</a>:     “重试框架 Spring-Retry 和 Guava-Retry，你知道该怎么选吗？”<br>[<a href="https://juejin.cn/post/7234107489390116925]">https://juejin.cn/post/7234107489390116925]</a>:     “spring-retry详解”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Retry&quot;&gt;&lt;a href=&quot;#Spring-Retry&quot; class=&quot;headerlink&quot; title=&quot;Spring Retry&quot;&gt;&lt;/a&gt;Spring Retry&lt;/h1&gt;&lt;h2 id=&quot;重试&quot;&gt;&lt;a href=&quot;#重试&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Others" scheme="http://example.com/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 函数</title>
    <link href="http://example.com/2023/06/01/SQL/"/>
    <id>http://example.com/2023/06/01/SQL/</id>
    <published>2023-06-01T00:31:22.000Z</published>
    <updated>2023-06-15T05:48:30.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-函数"><a href="#MySQL-函数" class="headerlink" title="MySQL 函数"></a>MySQL 函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT"></a>CONCAT</h3><blockquote><p>字符串 s1,s2 等多个字符串合并为一个字符串</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> CONCAT(str:<span class="type">varchar</span><span class="operator">*</span>)</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/Pzu6nCUoYOKclk7.png" alt="image-20230531234947036"></p><h3 id="CONCAT-WS"><a href="#CONCAT-WS" class="headerlink" title="CONCAT_WS"></a>CONCAT_WS</h3><blockquote><p>同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> CONCAT(sepatator:<span class="type">varchar</span>, str:<span class="type">varchar</span><span class="operator">*</span>)</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT_WS(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/e4lVcyAWtb8FGMv.png" alt="image-20230531235230173"></p><h3 id="FIND-IN-SET"><a href="#FIND-IN-SET" class="headerlink" title="FIND_IN_SET"></a>FIND_IN_SET</h3><blockquote><p>返回在字符串s2中与s1匹配的字符串的位置</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> FIND_IN_SET(str:<span class="type">varchar</span>, strlist.varchar);</span><br><span class="line"><span class="keyword">SELECT</span> FIND_IN_SET(&quot;c&quot;, &quot;a,b,c,d,e&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/ushUE2rwpAqCkTo.png" alt="image-20230531235407139"></p><h3 id="FIELD"><a href="#FIELD" class="headerlink" title="FIELD"></a>FIELD</h3><blockquote><p>返回第一个字符串 s 在字符串列表(s1,s2…)中的位置</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># FIELD(s,s1,s2...)</span><br><span class="line"><span class="keyword">SELECT</span> FIELD(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/h6eOuFz2I8AWndR.png" alt="image-20230531235818595"></p><h3 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h3><blockquote><p>函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入，同ROUND</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># FORMAT(x,n)</span><br><span class="line"><span class="keyword">SELECT</span> FORMAT(<span class="number">314.5634</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/01/WSHYU8Dgcsruz26.png" alt="image-20230601000108736"></p><h3 id="LOCATE"><a href="#LOCATE" class="headerlink" title="LOCATE"></a>LOCATE</h3><blockquote><p> 从字符串 s 中获取 s1 的开始位置</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> LOCATE(substr:<span class="type">varchar</span>, str:<span class="type">varchar</span>)</span><br><span class="line"><span class="keyword">SELECT</span> LOCATE(<span class="string">&#x27;st&#x27;</span>, <span class="string">&#x27;mystring&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/01/GayPtmz3s8BukpF.png" alt="image-20230601000407197"></p><h3 id="POSITION"><a href="#POSITION" class="headerlink" title="POSITION"></a>POSITION</h3><blockquote><p>从字符串 s 中获取 s1 的开始位置</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> <span class="built_in">POSITION</span>(substr:<span class="type">varchar</span> <span class="keyword">IN</span> str:<span class="type">varchar</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">POSITION</span>(<span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/01/JgPVledvbWscOHI.png" alt="image-20230601001603513"></p><h3 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE"></a>REPLACE</h3><blockquote><p> 将字符串 s2 替代字符串 s 中的字符串 s1</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> REPLACE(str:<span class="type">varchar</span>, from_str:<span class="type">varchar</span>, to_str:<span class="type">varchar</span>)</span><br><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/01/4DxGyVkYiBL5SdR.png" alt="image-20230601001740053"></p><h3 id="STRCMP"><a href="#STRCMP" class="headerlink" title="STRCMP"></a>STRCMP</h3><blockquote><p> 比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> STRCMP(expr1:<span class="type">varchar</span>, expr2:<span class="type">varchar</span>)</span><br><span class="line"><span class="keyword">SELECT</span> STRCMP(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/01/aVo8JwnU9e62C4v.png" alt="image-20230601002020123"></p><h3 id="SUBSTR"><a href="#SUBSTR" class="headerlink" title="SUBSTR"></a>SUBSTR</h3><blockquote><p>从字符串 s 的 start 位置截取长度为 length 的子字符串</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># SUBSTR(s, <span class="keyword">start</span>, length)</span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/01/edBv6O97TqjZhMz.png" alt="image-20230601002158153"></p><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><h3 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT"></a>DATE_FORMAT</h3><blockquote><p>日期格式化-&gt;VARCHAR()</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> DATE_FORMAT(<span class="type">date</span>:<span class="type">date</span> format:<span class="type">varchar</span>)</span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(NOW(), <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/Pbw3iqFnze6kasY.png" alt="image-20230531214904588"></p><h3 id="DATE-ADD-DATE-SUB"><a href="#DATE-ADD-DATE-SUB" class="headerlink" title="DATE_ADD/DATE_SUB"></a>DATE_ADD/DATE_SUB</h3><blockquote><p>增加/减少时间段-&gt;DATE</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># DATE_ADD(<span class="type">date</span>:<span class="type">date</span>, <span class="type">INTERVAL</span> expr:<span class="type">int</span> type)</span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(NOW(), <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">DAY</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/fu8rBoZcXYRqy6T.png" alt="image-20230531220249299"></p><h3 id="DATE-DIFF"><a href="#DATE-DIFF" class="headerlink" title="DATE_DIFF"></a>DATE_DIFF</h3><blockquote><p>计算日期天数间隔</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> DATEDIFF(expr1:datetime, expr2:datetime)</span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(NOW(), <span class="string">&#x27;2000-08-13&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/i78Cp4fwmV3odYl.png" alt="image-20230531221245979"></p><h3 id="TIMESTAMPDIFF"><a href="#TIMESTAMPDIFF" class="headerlink" title="TIMESTAMPDIFF"></a>TIMESTAMPDIFF</h3><blockquote><p>计算时间差：expr2:datetime − expr1:datetime-&gt;int</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> TIMESTAMPDIFF(type, expr1:datetime, expr2:datetime)</span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, <span class="string">&#x27;2000-08-13 12:00:00&#x27;</span>, NOW())</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/Gu5SOWMzkQonVUs.png" alt="image-20230531224506799"></p><h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><blockquote><p>CASE WHEN THEN ELSE END</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> <span class="keyword">CASE</span> expr</span><br><span class="line">#     <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">#     <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">#     ...</span><br><span class="line">#     <span class="keyword">WHEN</span> conditionN <span class="keyword">THEN</span> resultN</span><br><span class="line">#     <span class="keyword">ELSE</span> <span class="keyword">result</span></span><br><span class="line"># <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span></span><br><span class="line">           <span class="keyword">WHEN</span> <span class="number">1</span> <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">           <span class="keyword">WHEN</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="number">2</span></span><br><span class="line">           <span class="keyword">ELSE</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/xbgzUKJvRSQC9LZ.png" alt="image-20230531223411741"></p><h3 id="CAST"><a href="#CAST" class="headerlink" title="CAST"></a>CAST</h3><blockquote><p>转换数据类型</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="keyword">ANY</span>:<span class="keyword">any</span> <span class="keyword">AS</span> datatype, cast_datatype)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(NOW() <span class="keyword">AS</span> <span class="type">char</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/yk8PdARFeTiU7oh.png" alt="image-20230531224347587"></p><h3 id="COALESCE"><a href="#COALESCE" class="headerlink" title="COALESCE"></a>COALESCE</h3><blockquote><p>返回参数中的第一个非空表达式（从左往右）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">value</span>:<span class="keyword">any</span><span class="operator">*</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/4vuhKOU3odrtbic.png" alt="image-20230531224400093"></p><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><blockquote><p>如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> IF(expr:<span class="keyword">any</span>, v1, v2)</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">1</span> <span class="operator">&gt;</span> <span class="number">0</span>,<span class="string">&#x27;正确&#x27;</span>,<span class="string">&#x27;错误&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/d5iTeSRJc3uXHyD.png" alt="image-20230531225123746"></p><h3 id="IFNULL"><a href="#IFNULL" class="headerlink" title="IFNULL"></a>IFNULL</h3><blockquote><p>如果 v1 的值不为 NULL，则返回 v1，否则返回 v2</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> IFNULL(expr1:<span class="keyword">any</span>, expr2:<span class="keyword">any</span>)</span><br><span class="line"><span class="keyword">SELECT</span> IFNULL(<span class="keyword">NULL</span>, <span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/LBCegAKszb76SOQ.png" alt="image-20230531232335769"></p><h3 id="ISNULL"><a href="#ISNULL" class="headerlink" title="ISNULL"></a>ISNULL</h3><blockquote><p>判断表达式是否为 NULL</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> ISNULL(expr:<span class="keyword">any</span>)</span><br><span class="line"><span class="keyword">SELECT</span> ISNULL(expression)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/31/ZyIuPT7DnRSiV9h.png" alt="image-20230531232646826"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL-函数&quot;&gt;&lt;a href=&quot;#MySQL-函数&quot; class=&quot;headerlink&quot; title=&quot;MySQL 函数&quot;&gt;&lt;/a&gt;MySQL 函数&lt;/h1&gt;&lt;h2 id=&quot;字符串函数&quot;&gt;&lt;a href=&quot;#字符串函数&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring 原理 - Bean和容器</title>
    <link href="http://example.com/2023/05/24/Spring%E5%8E%9F%E7%90%86-Bean%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2023/05/24/Spring%E5%8E%9F%E7%90%86-Bean%E5%92%8C%E5%AE%B9%E5%99%A8/</id>
    <published>2023-05-24T12:35:22.000Z</published>
    <updated>2023-07-28T10:20:44.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoTestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Class&lt;?&gt; primarySource-SpringDemoTestApplication：引导类</span></span><br><span class="line"><span class="comment">         * String... args-agrs[] 应用程序参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringDemoTestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/LPHE14v6imlrhOY.png" alt="image-20230609213239599"></p><p>打开类图 我们可以发现：</p><p><code>BeanFactory</code>是<code>ApplicationContext</code>的父接口，是<code>Spring</code>的<strong>核心容器</strong>，主要的<code>ApplicationContext</code><strong>继承实现</strong>并<strong>组合</strong>了它的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据bean的名称检索bean的一个实例</span></span><br><span class="line">context.getContext(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/RHIwdv1g2rV3ym7.png" alt="image-20230609214201934"></p><p><img src="https://s2.loli.net/2023/07/28/6PtXO4QJkdH7pGi.png" alt="image-20230609214619874"></p><p>通过调试可以发现<code>ApplicationContext</code>里面包含<code>BeanFactory</code>对象</p><p><img src="https://s2.loli.net/2023/07/28/BwISmxudEnJp5Xq.png" alt="image-20230609215608098"></p><h4 id="BeanFactory功能"><a href="#BeanFactory功能" class="headerlink" title="BeanFactory功能"></a>BeanFactory功能</h4><blockquote><p>BeanFactory看似只有声明了这些接口，但是它的实现类提供了控制反转，依赖注入、Bean的声明周期的各种功能</p></blockquote><p><img src="https://s2.loli.net/2023/07/28/vMnB46Sy85bZTjp.png" alt="image-20230609220127577"></p><p>查看<code>BeanFactory</code>的一个实现类<code>DefaultSingletonBeanRegistry</code>，可以发现只是它组合了其他的父类</p><p><img src="https://s2.loli.net/2023/07/28/NArlXwq7BEvpHDc.png" alt="image-20230609221210849"></p><p>查看其中的一个父类 <code>DefaultSingletonBeanRegistry</code>，它管理类所有的单例对象</p><p><img src="https://s2.loli.net/2023/07/28/PsMXK7nHuYEpoa2.png" alt="image-20230609225158661"></p><p> 通过 反射 获取 <code>DefaultSingletonBeanRegistry</code> 类中成员属性 <code>singletonObjects</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 通过 反射 获取 DefaultSingletonBeanRegistry 类中成员属性 singletonObjects</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">singletonObjects</span> <span class="operator">=</span> DefaultSingletonBeanRegistry.class.getDeclaredField(<span class="string">&quot;singletonObjects&quot;</span>);</span><br><span class="line">   singletonObjects.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">   Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) singletonObjects.get(beanFactory);</span><br><span class="line">   map.entrySet().stream().forEach(stringObjectEntry -&gt; System.out.println(stringObjectEntry.getKey() + <span class="string">&quot;=&gt;&quot;</span> + stringObjectEntry.getValue()));</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/UnZPOsujAxX4Chm.png" alt="image-20230609231049336"></p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p><code>ApplicationContext</code>的扩展功能主要继承于<code>MessageSource</code>,<code>ResourcePatternResolver</code>,<code>ApplicationEventPublisher</code>,<code>EnvironmentCapable</code>这些父接口</p><p><img src="https://s2.loli.net/2023/07/28/VhGaAsj2YXEnocq.png" alt="image-20230609231352094"></p><h4 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getMessage(<span class="string">&quot;hi&quot;</span>,<span class="literal">null</span>, Locale.CHINA)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/09/wtU5jgqivXJs81E.png" alt="image-20230609232803980"></p><p><img src="https://s2.loli.net/2023/06/09/ERv8idXtnzIKrS2.png" alt="image-20230609232913040"></p><h4 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> context.getResource(<span class="string">&quot;classpath:application.properties&quot;</span>);</span><br><span class="line">Resource[] resources = context.getResources(<span class="string">&quot;classpath*:META-INF/spring.factories&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/QYyl3ahuf6tZjNr.png" alt="image-20230609234203639"></p><h5 id="EnvironmentCapable"><a href="#EnvironmentCapable" class="headerlink" title="EnvironmentCapable"></a>EnvironmentCapable</h5><p><img src="https://s2.loli.net/2023/07/28/VgCuyJ7AckpObqs.png" alt="image-20230609234733197"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PropertyResolver</span></span><br><span class="line"><span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> context.getEnvironment().getProperty(<span class="string">&quot;server.port&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h4><h5 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 事件源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subscribe</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Subscribe.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> demoEvent 事件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(DemoEvent demoEvent)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;demoEvent：&quot;</span> + demoEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Publish</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Publish.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">()</span> &#123;</span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">DemoEvent</span>(applicationEventPublisher));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行发送"><a href="#执行发送" class="headerlink" title="执行发送"></a>执行发送</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ApplicationEventPublisher</span></span><br><span class="line"><span class="comment">//        context.publishEvent(new DemoEvent(context));</span></span><br><span class="line">        context.getBean(Publish.class).publish();</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/O8WBrk6aATJjFgt.png" alt="image-20230610002025539"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p><code>BeanFactory</code>与 <code>ApplicationContext</code>不仅仅是简单接口的继承关系，<code>ApplicationContext</code>组合并通过继承其他父类扩展了<code>BeanFactory</code>的功能</p></blockquote><h2 id="BeanFactory-1"><a href="#BeanFactory-1" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><h3 id="BeanFactory的实现"><a href="#BeanFactory的实现" class="headerlink" title="BeanFactory的实现"></a>BeanFactory的实现</h3><p>首先，我们手动注册<strong>配置类定义信息</strong>和常见的<strong>后处理器</strong>，手动生成<code>BeanFactory</code>，添加后处理器并执行它们</p><p>我们查看<code>BeanFactory</code>一个默认的常见实现<code>DefaultListableBeanFactory</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// beanFactory 根据 bean 的 定义(class\scope\初始化\销毁等) 创建对象</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br></pre></td></tr></table></figure><p>创建Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean1.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean1</span> <span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;构造 Bean1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean2.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span> <span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;构造 Bean2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>BeanDefinition</code> 定义Bean并注册到<code>BeanFactory</code>里 </p><blockquote><p>BeanDefinition描述一个bean实例，该实例具有属性值、构造函数参数值以及由具体实现提供的进一步信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 BeanDefinition 定义Bean对象</span></span><br><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(Config.class)</span><br><span class="line">        <span class="comment">// 设置 单例 模式</span></span><br><span class="line">        .setScope(ConfigurableBeanFactory.SCOPE_SINGLETON).getBeanDefinition();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册到容器</span></span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/10/qzeN2LIDQZ9HAdE.png" alt="image-20230610105106417"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 BeanDefinition Bean的定义 将 Bean 注入到 beanFactory</span></span><br><span class="line"><span class="comment"> * 参数一：Bean 名称</span></span><br><span class="line"><span class="comment"> * 参数二：BeanDefinition 定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br></pre></td></tr></table></figure><p>注册后置处理器到 <code>BeanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 添加 注释处理器</span></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br></pre></td></tr></table></figure><p>执行<code>BeanFactory</code>指定后处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 类的类型 获取 Bean集合</span></span><br><span class="line">Map&lt;String, BeanFactoryPostProcessor&gt; beansOfType = beanFactory.getBeansOfType(BeanFactoryPostProcessor.class);</span><br><span class="line"><span class="comment">// 执行 后处理器 补充Bean的定义</span></span><br><span class="line">beansOfType.values().stream().forEach(beanFactoryPostProcessor -&gt; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory));</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/Kl7rm9TOEHVD43J.png" alt="image-20230610131622294"></p><p>获取依赖注入的<code>Bean</code>：查看 <code>Bean1</code> 中注入的<code> Bean2</code> 对象，发现依赖注入并没有成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看 Bean1 中注入的 Bean2 对象</span></span><br><span class="line">logger.info(<span class="string">&quot;Bean1 中注入的 Bean2 对象：&#123;&#125;&quot;</span>, beanFactory.getBean(Bean1.class).getBean2());   </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/iKMkrVfIsX6HjqB.png" alt="image-20230610155552714"></p><p>开启Bean后处理器，发现成功获取依赖注入的对象，但是对象是 懒汉式 的方式创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bean 后处理器 - 针对 Bean 生命周期的各个阶段提供扩展功能（例如：依赖注入）</span></span><br><span class="line">     beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 查看 Bean1 中注入的 Bean2 对象</span></span><br><span class="line">     logger.info(<span class="string">&quot;Bean1 中注入的 Bean2 对象：&#123;&#125;&quot;</span>, beanFactory.getBean(Bean1.class).getBean2());</span><br></pre></td></tr></table></figure><p>打开 <code>AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory)</code>方法，可以发现 <code>后处理器</code> 注册了 <code>@Autowired</code> 和 <code>@Resource</code> 的处理器</p><p><img src="https://s2.loli.net/2023/07/28/FQLdNRK9pBgzxOe.png" alt="image-20230610232839781"></p><p><img src="https://s2.loli.net/2023/07/28/yinhHjrBeqCZ47m.png" alt="image-20230610155938299"></p><p>可以通过BeanFactory的方法提前初始化所有的单例<code>Bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前初始化所有的单例Bean</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure><blockquote><p>BeanFactory不会主动调用<code>BeanFactory</code>后处理器，不会添加<code>Bean</code>后处理器，不会主动初始化单例Bean，而是由<code>ApplicationContext</code>调用</p></blockquote><p>定义接口 创建两个类实现同一接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean3.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean3</span> <span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;构造 Bean3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean4.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean4</span> <span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;构造 Bean4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Bean</code>中使用 <code>@Autowired</code>依赖注入<code>Inter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean1.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean1</span> <span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;构造 Bean1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Inter inter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inter <span class="title function_">getinter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/10/8CsyXqBQELdWYaj.png" alt="image-20230610224249148"></p><p><img src="https://s2.loli.net/2023/07/28/Dg8IeHjPyUL3mZx.png" alt="image-20230610224311078"></p><p><code>@Autowire</code>注解默认通过 <code>ByType</code> 方式注入，<code>ByType</code>方式没有找到再去根据 <code>ByName</code>方式寻找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Inter bean3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Inter <span class="title function_">getBean3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bean3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/sz4oZ72rveStaJ8.png" alt="image-20230610231418064"></p><p><img src="https://s2.loli.net/2023/07/28/5YCUblwLNt9HXoc.png" alt="image-20230610231550064"></p><p><code>@Resource</code>优先根据<code>ByName</code>方式注入，默认情况下要求被注入的Bean必须存在，注解里name属性的优先级高于成员变量Name</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;bean4&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Inter bean3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Inter <span class="title function_">getBean3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bean3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/28/5q8wJAm9PetFKjV.png" alt="image-20230610232305961"></p><p>如果 <code>@Resource</code> 和 <code>@Autowired</code> 的同时存在，优先注入 <code>@Autowired</code></p><p>如果使用 <code>依赖比较器</code> 进行 排序 会发现 <code>@Autowired</code> 先生效，这是因为 两个后置处理器 的 <code>order</code> 值不一样，值越小的优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bean 后处理器 - 针对 Bean 生命周期的各个阶段提供扩展功能（例如：依赖注入）</span></span><br><span class="line">beanFactory.getBeansOfType(BeanPostProcessor.class).values()</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted(beanFactory.getDependencyComparator())</span><br><span class="line">        .forEach(beanFactory::addBeanPostProcessor);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/10/amhtFuOjqiPd7Rp.png" alt="image-20230610235515076"></p><p><img src="https://s2.loli.net/2023/06/10/o5K2Gtp1lDBr3qJ.png" alt="image-20230610235610031"></p><p><img src="https://s2.loli.net/2023/06/10/Z5bDTuhvMG6pRPz.png" alt="image-20230610235622367"></p><h3 id="ApplicationContext常见实现和用法"><a href="#ApplicationContext常见实现和用法" class="headerlink" title="ApplicationContext常见实现和用法"></a>ApplicationContext常见实现和用法</h3><h4 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h4><h5 id="ClassPathXmlApplication"><a href="#ClassPathXmlApplication" class="headerlink" title="ClassPathXmlApplication"></a>ClassPathXmlApplication</h5><blockquote><p>基于 <code>classpath</code> 下 <code>xml</code> 格式配置文件来创建</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean5.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bean6 bean6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean5</span> <span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;构造 Bean5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean6</span><span class="params">(Bean6 bean6)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean6 = bean6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean6 <span class="title function_">getBean6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean6.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean6</span> <span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;构造 Bean6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean5&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.demo.bean.Bean5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bean6&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean6&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.demo.bean.Bean6&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testClass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">classPathXmlApplicationContext</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;test.xml&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;查看 classPathXmlApplicationContext 中所有的容器&quot;</span>);</span><br><span class="line">    Arrays.stream(classPathXmlApplicationContext.getBeanDefinitionNames())</span><br><span class="line">            .forEach(s -&gt; logger.info(s));</span><br><span class="line">    logger.info(<span class="string">&quot;查看是否依赖注入是否成功：&#123;&#125;&quot;</span>, classPathXmlApplicationContext.getBean(Bean5.class).getBean6());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/13/rQZK7z8owWnvAJN.png" alt="image-20230613171023399"></p><p>它的底层原理就是通过 <code>XmlBeanDefinitionReader</code> 加载配置文件 读取 <code>bean</code> 的定义至 <code>beanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层原理</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">reader.loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;test.xml&quot;</span>));</span><br><span class="line">logger.info(<span class="string">&quot;查看 classPathXmlApplicationContext 中所有的容器&quot;</span>);</span><br><span class="line">Arrays.stream(beanFactory.getBeanDefinitionNames())</span><br><span class="line">        .forEach(s -&gt; logger.info(s));</span><br><span class="line">logger.info(<span class="string">&quot;查看是否依赖注入是否成功：&#123;&#125;&quot;</span>, beanFactory.getBean(Bean5.class).getBean6());</span><br></pre></td></tr></table></figure><h5 id="FileSystemXmlApplicationContext"><a href="#FileSystemXmlApplicationContext" class="headerlink" title="FileSystemXmlApplicationContext"></a>FileSystemXmlApplicationContext</h5><blockquote><p>基于 <code>磁盘</code> 路径下的 xml 格式的配置文件来创建</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileSystemXmlApplicationContext</span> <span class="variable">fileSystemXmlApplicationContext</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;src/main/resources/test.xml&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;查看 classPathXmlApplicationContext 中所有的容器&quot;</span>);</span><br><span class="line">    Arrays.stream(fileSystemXmlApplicationContext.getBeanDefinitionNames())</span><br><span class="line">            .forEach(s -&gt; logger.info(s));</span><br><span class="line">    logger.info(<span class="string">&quot;查看是否依赖注入是否成功：&#123;&#125;&quot;</span>, fileSystemXmlApplicationContext.getBean(Bean5.class).getBean6());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AnnotationConfigServletWebApplicationContext"><a href="#AnnotationConfigServletWebApplicationContext" class="headerlink" title="AnnotationConfigServletWebApplicationContext"></a>AnnotationConfigServletWebApplicationContext</h5><blockquote><p>基于 <code>注解配置类</code> 来创建</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean5 <span class="title function_">bean5</span><span class="params">(Bean6 bean6)</span> &#123;</span><br><span class="line">        <span class="type">Bean5</span> <span class="variable">bean5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean5</span>();</span><br><span class="line">        bean5.setBean6(bean6);</span><br><span class="line">        <span class="keyword">return</span> bean5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean6 <span class="title function_">bean6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean6</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">annotationConfigApplicationContext</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(BeanConfig.class);</span><br><span class="line">    logger.info(<span class="string">&quot;查看 classPathXmlApplicationContext 中所有的容器&quot;</span>);</span><br><span class="line">    Arrays.stream(annotationConfigApplicationContext.getBeanDefinitionNames())</span><br><span class="line">            .forEach(s -&gt; logger.info(s));</span><br><span class="line">    logger.info(<span class="string">&quot;查看是否依赖注入是否成功：&#123;&#125;&quot;</span>, annotationConfigApplicationContext.getBean(Bean5.class).getBean6());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/13/ZTx2AChNiFlRdkb.png" alt="image-20230613173653358"></p><h5 id="AnnotationConfigServletWebApplicationContext-1"><a href="#AnnotationConfigServletWebApplicationContext-1" class="headerlink" title="AnnotationConfigServletWebApplicationContext"></a>AnnotationConfigServletWebApplicationContext</h5><blockquote><p>基于 <code>注解配置类</code> 来创建，用于web环境</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 Tomcat 服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 servlet 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 dispatcherServlet 到 tomcat 服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dispatcherServlet 通过 参数 注入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="comment">// path：&quot;/&quot; 所有请求经过 DispatcherServlet 进行请求分发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 控制器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Controller <span class="title function_">controller</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigServletWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigServletWebApplicationContext</span> <span class="variable">annotationConfigServletWebApplicationContext</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebApplicationContext</span>(WebConfig.class);</span><br><span class="line">        logger.info(<span class="string">&quot;查看 classPathXmlApplicationContext 中所有的容器&quot;</span>);</span><br><span class="line">        Arrays.stream(annotationConfigServletWebApplicationContext.getBeanDefinitionNames())</span><br><span class="line">                .forEach(s -&gt; logger.info(s));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/13/jDIerLN54t1qwzi.png" alt="image-20230613193651853"></p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><h3 id="SpringBean的生命周期的各个阶段"><a href="#SpringBean的生命周期的各个阶段" class="headerlink" title="SpringBean的生命周期的各个阶段"></a>SpringBean的生命周期的各个阶段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(LifeCycleBean.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleBean</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;构造：LifeCycleBean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autowired</span><span class="params">(<span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span> String port)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;LifeCycleBean依赖注入：&#123;&#125;&quot;</span>, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;初始化：LifeCycleBean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;销毁：LifeCycleBean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringDemoTestApplication.class, args);</span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/13/CGux4zk9pdmS5c7.png" alt="image-20230613195350693"></p><blockquote><p>Bean 的生命周期：构造-&gt;依赖注入-&gt;初始化-&gt;销毁</p></blockquote><p>添加一些 <code>自定义 Bean 的后处理器</code>，对于Bean的生命周期进行增强，完成生命周期的扩展</p><p>需要实现 <code>InstantiationAwareBeanPostProcessor</code> 和 <code>DestructionAwareBeanPostProcessor</code>接口，这两个接口都继承于<code>BeanPostProcessor</code></p><p><img src="https://s2.loli.net/2023/06/13/4F5vbwMgjzxSaQY.png" alt="image-20230613200055801"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span>, DestructionAwareBeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CustomBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 实例化之前执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass the class of the bean to be instantiated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName  the name of the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;实例化之前执行&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里如果返回结果不能null 则会替代我们之前的bean</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 实例化之后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     the bean instance created, with properties not having been set yet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;实例化之后执行&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果返回false 则不会进行属性的依赖注入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 依赖注入阶段执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pvs      the property values that the factory is about to apply (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     the bean instance created, but whose properties have not yet been set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// @Resource等注释的解析</span></span><br><span class="line">            logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;依赖注入阶段执行&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 初始化执行之前执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     the new bean instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// @PostConstruct，@ConfigurationProperties等注释的解析</span></span><br><span class="line">            logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;初始化之前执行 &lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 初始化之后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     the new bean instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 代理增强</span></span><br><span class="line">            logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;初始化之后执行 &lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 销毁之前执行方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     the bean instance to be destroyed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;销毁之前执行方法&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/13/fbGJ6rlFH7yYm9o.png" alt="image-20230613202154385"></p><h3 id="模版设计模式"><a href="#模版设计模式" class="headerlink" title="模版设计模式"></a>模版设计模式</h3><p><img src="https://s2.loli.net/2023/06/13/mczKD4GdnZthwfl.png" alt="image-20230613211346813"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DemoBeanFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        logger.info(<span class="string">&quot;构造 Bean&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;依赖注入 Bean&quot;</span>);</span><br><span class="line">         <span class="comment">// 添加 后处理器</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">            postProcessor.inject(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;初始化 Bean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; postProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span> &#123;</span><br><span class="line">        postProcessors.add(beanPostProcessor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DemoBeanFactory</span> <span class="variable">demoBeanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoBeanFactory</span>();</span><br><span class="line">    demoBeanFactory.addBeanPostProcessor(bean -&gt; logger.info(<span class="string">&quot;后处理器1&quot;</span>));</span><br><span class="line">    demoBeanFactory.addBeanPostProcessor(bean -&gt; logger.info(<span class="string">&quot;后处理器2&quot;</span>));</span><br><span class="line">    demoBeanFactory.createBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean后处理器"><a href="#Bean后处理器" class="headerlink" title="Bean后处理器"></a>Bean后处理器</h2><h3 id="Bean后处理器作用"><a href="#Bean后处理器作用" class="headerlink" title="Bean后处理器作用"></a>Bean后处理器作用</h3><blockquote><p><code>Bean后处理器</code>是 为<code>Bean生命周期</code>各个<code>阶段</code>提供<code>扩展功能</code></p></blockquote><p>用 <code>GenericApplicationContext</code> 探究一下 一些注解 分别由哪些处理器来解析的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanReplica1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(BeanReplica1.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanReplica2 beanReplica2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanReplica3 beanReplica3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanReplica2</span><span class="params">(BeanReplica2 beanReplica2)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;@Autowired生效：&#123;&#125;&quot;</span>, beanReplica2);</span><br><span class="line">        <span class="built_in">this</span>.beanReplica2 = beanReplica2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanReplica3</span><span class="params">(BeanReplica3 beanReplica3)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;@Resource生效：&#123;&#125;&quot;</span>, beanReplica3);</span><br><span class="line">        <span class="built_in">this</span>.beanReplica3 = beanReplica3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPort</span><span class="params">(<span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span> String port)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;@Resource生效：&#123;&#125;&quot;</span>, beanReplica3);</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;@PostConstruct生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;@PreDestroy生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanReplica2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanReplica3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// GenericApplicationContext 一个【干净】的容器 - 没有添加Bean工厂后处理器、Bean后处理器</span></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  注册Bean</span></span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;beanReplica1&quot;</span>, BeanReplica1.class);</span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;beanReplica2&quot;</span>, BeanReplica2.class);</span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;beanReplica3&quot;</span>, BeanReplica3.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容器 - 执行beanFactory后处理器 添加bean后处理器 初始化所有单例</span></span><br><span class="line">    genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(genericApplicationContext.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁容器</span></span><br><span class="line">    genericApplicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在未添加后处理器的容器里 ，只注册了三个Bean实例</p><p><img src="https://s2.loli.net/2023/06/14/wqlI9nTN2k1oMGO.png" alt="image-20230614000632415"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prop</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// GenericApplicationContext 一个【干净】的容器 - 没有添加Bean工厂后处理器、Bean后处理器</span></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  注册Bean</span></span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;beanReplica1&quot;</span>, BeanReplica1.class);</span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;beanReplica2&quot;</span>, BeanReplica2.class);</span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;beanReplica3&quot;</span>, BeanReplica3.class);</span><br><span class="line">    <span class="comment">// 属性注入</span></span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;prop&quot;</span>, Prop.class);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置 @Value 解析器</span></span><br><span class="line">    genericApplicationContext.getDefaultListableBeanFactory()</span><br><span class="line">            .setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">    <span class="comment">// @Autowired @Value 注释 后处理器</span></span><br><span class="line">    genericApplicationContext.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">    <span class="comment">// @Resource @PostConstruct @PreDestroy 后处理器</span></span><br><span class="line">    genericApplicationContext.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">    <span class="comment">//  @ConfigurationProperties 后处理器</span></span><br><span class="line">    ConfigurationPropertiesBindingPostProcessor.register(genericApplicationContext.getDefaultListableBeanFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容器 - 执行beanFactory后处理器 添加bean后处理器 初始化所有单例</span></span><br><span class="line">    genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(genericApplicationContext.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(genericApplicationContext.getBean(Prop.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁容器</span></span><br><span class="line">    genericApplicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/14/vxSkhJzXVHA5KaG.png" alt="image-20230614005108458"></p><h3 id="常见的后处理器"><a href="#常见的后处理器" class="headerlink" title="常见的后处理器"></a>常见的后处理器</h3><h4 id="AutowiredAnnotationBeanPostProcessor-运行分析"><a href="#AutowiredAnnotationBeanPostProcessor-运行分析" class="headerlink" title="AutowiredAnnotationBeanPostProcessor 运行分析"></a>AutowiredAnnotationBeanPostProcessor 运行分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AutowiredAnnotationBeanPostProcessor 运行分析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// 注册 Bean (参数一：bean 名称 参数二：实例化对象【不会进行创建过程，依赖注入】)</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;beanReplica2&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanReplica2</span>());</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;beanReplica3&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanReplica3</span>());</span><br><span class="line">    <span class="comment">// 添加解析器</span></span><br><span class="line">    beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">    <span class="comment">// 添加 $&#123;&#125; 解析器</span></span><br><span class="line">    beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>()::resolvePlaceholders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建后处理器对象</span></span><br><span class="line">    <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">autowiredAnnotationBeanPostProcessor</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">    <span class="comment">// 向 Bean 实例提供所属工厂的回调</span></span><br><span class="line">        autowiredAnnotationBeanPostProcessor.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanReplica1</span> <span class="variable">beanReplica1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanReplica1</span>();</span><br><span class="line">    logger.info(<span class="string">&quot;beanReplica1:&#123;&#125;&quot;</span>, beanReplica1.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在工厂将给定的属性值应用于给定的 Bean 之前对其进行后处理，而无需任何属性描述符 - 执行 依赖注入，@Autowired</span></span><br><span class="line">    autowiredAnnotationBeanPostProcessor.postProcessProperties(<span class="literal">null</span>, beanReplica1, <span class="string">&quot;beanReplica1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;bean1:&#123;&#125;&quot;</span>, beanReplica1.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/14/fhdQ2HxY5Gy4wU7.png" alt="image-20230614102549941"></p><h5 id="autowiredAnnotationBeanPostProcessor-postProcessProperties的执行过程"><a href="#autowiredAnnotationBeanPostProcessor-postProcessProperties的执行过程" class="headerlink" title="autowiredAnnotationBeanPostProcessor.postProcessProperties的执行过程"></a>autowiredAnnotationBeanPostProcessor.postProcessProperties的执行过程</h5><p>点击 进入 <code>autowiredAnnotationBeanPostProcessor.postProcessProperties</code>方法，发现里面第一步获取 @Autowired 和 @Value 注解的 成员变量 和 方法参数信息 的 <code>InjectionMetadata</code> 对象信息。我们可以通过 <code>反射</code> 获取 其中的信息</p><p><img src="https://s2.loli.net/2023/06/14/6CpJOKSaVqbmw7k.png" alt="image-20230614112731102"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 反射 获取方法 参数一：方法名-getDeclaredMethod 方法二-方法参数类-Class&lt;?&gt;... parameterTypes</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">findAutowiringMetadata</span> <span class="operator">=</span> autowiredAnnotationBeanPostProcessor.getClass()</span><br><span class="line">        .getDeclaredMethod(<span class="string">&quot;findAutowiringMetadata&quot;</span>, String.class, Class.class, PropertyValues.class);</span><br><span class="line"><span class="comment">// 由于 findAutowiringMetadata 方法 是由 private 修饰， 所以 设置可用</span></span><br><span class="line">findAutowiringMetadata.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 调用方法 参数一：调用者-autowiredAnnotationBeanPostProcessor 参数二：方法参数-args</span></span><br><span class="line"><span class="comment">// 获取 Bean1 上 @Autowired 和 @Value 注解的 成员变量 和 方法参数信息</span></span><br><span class="line"><span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span></span><br><span class="line">        (InjectionMetadata) findAutowiringMetadata.invoke(autowiredAnnotationBeanPostProcessor, <span class="string">&quot;beanReplica1&quot;</span>, BeanReplica1.class, <span class="literal">null</span>);</span><br><span class="line">logger.info(<span class="string">&quot;metadata: &#123;&#125;&quot;</span>, metadata);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/14/lRYIZAv3fmda8we.png" alt="image-20230614113038993"></p><p>调用 <code>InjectionMetadata.inject</code> 进行 依赖 注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 inject 进行 依赖注入 注入时 按照 类型 查找</span></span><br><span class="line">metadata.inject(beanReplica1, <span class="string">&quot;beanReplica1&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/14/D8CgR7I6LET3ZiX.png" alt="image-20230614114100959"></p><h4 id="MetaData"><a href="#MetaData" class="headerlink" title="MetaData"></a>MetaData</h4><p><img src="https://s2.loli.net/2023/06/14/qJVL79SzoEgxRTB.png" alt="image-20230614132136913"></p><p><img src="https://s2.loli.net/2023/06/14/mFLxfjR6AZTc9Xi.png" alt="image-20230614131738276"></p><h5 id="Metadata-inject分析"><a href="#Metadata-inject分析" class="headerlink" title="Metadata.inject分析"></a><code>Metadata.inject</code>分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDoResolveDependency</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// 注册 Bean (参数一：bean 名称 参数二：实例化对象【不会进行创建过程，依赖注入】)</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;beanReplica2&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanReplica2</span>());</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;beanReplica3&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanReplica3</span>());</span><br><span class="line">    <span class="comment">// 添加解析器</span></span><br><span class="line">    beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">    <span class="comment">// 添加 $&#123;&#125; 解析器</span></span><br><span class="line">    beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>()::resolvePlaceholders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建后处理器对象</span></span><br><span class="line">    <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">autowiredAnnotationBeanPostProcessor</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">    <span class="comment">// 向 Bean 实例提供所属工厂的回调</span></span><br><span class="line">    autowiredAnnotationBeanPostProcessor.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanReplica1</span> <span class="variable">beanReplica1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanReplica1</span>();</span><br><span class="line">    logger.info(<span class="string">&quot;beanReplica1:&#123;&#125;&quot;</span>, beanReplica1.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Autowired 属性 注入 分析：metadata.inject 给 beanReplica1 注入 beanReplica3 的 过程</span></span><br><span class="line">    <span class="comment">// 通过 Field 属性名 找到 属性成员变量类型 根据类型从容器中找到相应的Bean容器</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">fieldBeanReplica3</span> <span class="operator">=</span> BeanReplica1.class.getDeclaredField(<span class="string">&quot;beanReplica3&quot;</span>);</span><br><span class="line">    <span class="comment">// 将成员信息封装成 DependencyDescriptor 对象</span></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">descriptorForBean3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(fieldBeanReplica3, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 从 beanFactory 容器中根据 类型 找到相应的容器</span></span><br><span class="line">    <span class="type">BeanReplica3</span> <span class="variable">beanReplica3</span> <span class="operator">=</span> (BeanReplica3) beanFactory.doResolveDependency(descriptorForBean3, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;beanReplica3---&gt;&#123;&#125;&quot;</span>, beanReplica3);</span><br><span class="line">    <span class="comment">// set 方法 注入</span></span><br><span class="line">    <span class="comment">// 通过 Mothed 方法中的参数 找到参数类型 根据 参数类型从容器中找到相应的Bean容器</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setBeanReplica2</span> <span class="operator">=</span> BeanReplica1.class.getDeclaredMethod(<span class="string">&quot;setBeanReplica2&quot;</span>, BeanReplica2.class);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">descriptorForBean2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBeanReplica2, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="type">BeanReplica2</span> <span class="variable">beanReplica2</span> <span class="operator">=</span> (BeanReplica2) beanFactory.doResolveDependency(descriptorForBean2, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;beanReplica2----&gt;&#123;&#125;&quot;</span>, beanReplica2);</span><br><span class="line">    <span class="comment">// @Value set 属性注入</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setPort</span> <span class="operator">=</span> beanReplica1.getClass().getDeclaredMethod(<span class="string">&quot;setPort&quot;</span>, String.class);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">descriptorForString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setPort, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">port</span> <span class="operator">=</span> (String) beanFactory.doResolveDependency(descriptorForString, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;port----&gt;&#123;&#125;&quot;</span>, port);</span><br><span class="line">    <span class="comment">// 属性注入</span></span><br><span class="line">    beanReplica1.setBeanReplica2(beanReplica2);</span><br><span class="line">    beanReplica1.setBeanReplica3(beanReplica3);</span><br><span class="line">    beanReplica1.setPort(port);</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;bean1:&#123;&#125;&quot;</span>, beanReplica1.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/14/dM7JrGRap8OL12Z.png" alt="image-20230614140728363"></p><h2 id="BeanFactory后处理器"><a href="#BeanFactory后处理器" class="headerlink" title="BeanFactory后处理器"></a>BeanFactory后处理器</h2><h3 id="BeanFactory后处理器的作用"><a href="#BeanFactory后处理器的作用" class="headerlink" title="BeanFactory后处理器的作用"></a>BeanFactory后处理器的作用</h3><blockquote><p><code>BeanFactory后处理器</code>的作用：为 <code>BeanFatory</code>提供扩展，补充 <code>Bean的定义</code></p></blockquote><h3 id="常见的BeanFactory后处理器"><a href="#常见的BeanFactory后处理器" class="headerlink" title="常见的BeanFactory后处理器"></a>常见的BeanFactory后处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanFactoryPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;config1&quot;</span>, Config1.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 Bean 工厂 后处理器</span></span><br><span class="line">    <span class="comment">// @Configuration @Bean @Import @ImportResource</span></span><br><span class="line">    genericApplicationContext.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @MapperSanner</span></span><br><span class="line">    genericApplicationContext.registerBean(</span><br><span class="line">            MapperScannerConfigurer.class,</span><br><span class="line">            db -&gt; &#123;</span><br><span class="line">                <span class="comment">// 指定扫描 @Mapper 的包</span></span><br><span class="line">                db.getPropertyValues().add(<span class="string">&quot;basePackage&quot;</span>, <span class="string">&quot;com.example.demo.mapper&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">    genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(genericApplicationContext.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    genericApplicationContext.destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanFactory后置处理器实现"><a href="#BeanFactory后置处理器实现" class="headerlink" title="BeanFactory后置处理器实现"></a>BeanFactory后置处理器实现</h3><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><h5 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h5><p>将 类上有 <code>@Component</code> 注解的注入到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanFactoryPostProcessorDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;config1&quot;</span>, Config1.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找 Config1 类中 ComponentScan 注解</span></span><br><span class="line">    <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(Config1.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 ComponentScan 注解中的 basePackages 属性</span></span><br><span class="line">        <span class="keyword">for</span> (String s : componentScan.basePackages()) &#123;</span><br><span class="line">            <span class="comment">// 将 basePackage 属性值转换为 路径： com.example.demo.component -&gt; classpath*:com/example/demo/component/**/*.class</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + s.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">            <span class="comment">// 根据 路径 获取 Resource 二进制资源</span></span><br><span class="line">            Resource[] resources = genericApplicationContext.getResources(path);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 工厂 获取类的元信息</span></span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="comment">// Bean 名称generator</span></span><br><span class="line">            <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">annotationBeanNameGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line"></span><br><span class="line">                logger.info(</span><br><span class="line">                        <span class="string">&quot;类名：&#123;&#125;, 类上是否存在 @Component 注解：&#123;&#125;, 类上是否存在 @Component派生 注解：&#123;&#125; &quot;</span>,</span><br><span class="line">                        metadataReader.getClassMetadata().getClassName(),</span><br><span class="line">                        metadataReader.getAnnotationMetadata().hasAnnotation(Component.class.getName()),</span><br><span class="line">                        metadataReader.getAnnotationMetadata().hasMetaAnnotation(Component.class.getName())</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 类上存在@Component 注解或者@Component派生 注解 则将其注入 容器 中</span></span><br><span class="line">                <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName()) ||</span><br><span class="line">                        annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                    <span class="comment">// 构建 Bean 的定义</span></span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span></span><br><span class="line">                            BeanDefinitionBuilder.genericBeanDefinition(metadataReader.getClassMetadata().getClassName()).getBeanDefinition();</span><br><span class="line">                    <span class="comment">// 获取 Bean 名称</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> annotationBeanNameGenerator.generateBeanName(beanDefinition, genericApplicationContext.getDefaultListableBeanFactory());</span><br><span class="line">                    <span class="comment">// 根据 Bean定义 注入到 Bean容器 中</span></span><br><span class="line">                    genericApplicationContext.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器</span></span><br><span class="line">        genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        Arrays.stream(genericApplicationContext.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁容器</span></span><br><span class="line">        genericApplicationContext.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h5><p>通过 实现<code>BeanFactory</code>后置处理器接口，将 类上有 <code>@Component</code> 注解的注入到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ComponentScanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找 Config1 类中 ComponentScan 注解</span></span><br><span class="line">        <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(Config1.class, ComponentScan.class);</span><br><span class="line">        <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取 ComponentScan 注解中的 basePackages 属性</span></span><br><span class="line">            <span class="keyword">for</span> (String s : componentScan.basePackages()) &#123;</span><br><span class="line">                <span class="comment">// 将 basePackage 属性值转换为 路径： com.example.demo.component -&gt; classpath*:com/example/demo/component/**/*.class</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + s.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">                <span class="comment">// 根据 路径 获取 Resource 二进制资源</span></span><br><span class="line">                Resource[] resources = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(path);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 工厂 获取类的元信息</span></span><br><span class="line">                <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">                <span class="comment">// Bean 名称generator</span></span><br><span class="line">                <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">annotationBeanNameGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                    <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line"></span><br><span class="line">                    logger.info(</span><br><span class="line">                            <span class="string">&quot;类名：&#123;&#125;, 类上是否存在 @Component 注解：&#123;&#125;, 类上是否存在 @Component派生 注解：&#123;&#125; &quot;</span>,</span><br><span class="line">                            metadataReader.getClassMetadata().getClassName(),</span><br><span class="line">                            metadataReader.getAnnotationMetadata().hasAnnotation(Component.class.getName()),</span><br><span class="line">                            metadataReader.getAnnotationMetadata().hasMetaAnnotation(Component.class.getName())</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果 类上存在@Component 注解或者@Component派生 注解 则将其注入 容器 中</span></span><br><span class="line">                    <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName()) ||</span><br><span class="line">                            annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                        <span class="comment">// 构建 Bean 的定义</span></span><br><span class="line">                        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span></span><br><span class="line">                                BeanDefinitionBuilder.genericBeanDefinition(metadataReader.getClassMetadata().getClassName())</span><br><span class="line">                                        .getBeanDefinition();</span><br><span class="line">                        <span class="comment">// 获取 Bean 名称</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> annotationBeanNameGenerator.generateBeanName(beanDefinition, beanFactory);</span><br><span class="line">                        <span class="comment">// 根据 Bean定义 注入到 Bean容器 中</span></span><br><span class="line">                        beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanFactoryComponentPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">       genericApplicationContext.registerBean(<span class="string">&quot;config1&quot;</span>, Config1.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 添加 Bean 工厂 后处理器</span></span><br><span class="line">       <span class="comment">// @Configuration @Bean @Import @ImportResource</span></span><br><span class="line">       genericApplicationContext.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// @MapperSanner</span></span><br><span class="line">       genericApplicationContext.registerBean(</span><br><span class="line">               MapperScannerConfigurer.class,</span><br><span class="line">               db -&gt; &#123;</span><br><span class="line">                   <span class="comment">// 指定扫描 @Mapper 的包</span></span><br><span class="line">                   db.getPropertyValues().add(<span class="string">&quot;basePackage&quot;</span>, <span class="string">&quot;com.example.demo.mapper&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 初始化容器</span></span><br><span class="line">       genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">       Arrays.stream(genericApplicationContext.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">       genericApplicationContext.destroy();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(BeanPostProcessor.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取 指定类的元信息</span></span><br><span class="line">        <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">        <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span></span><br><span class="line">                factory.getMetadataReader(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;com/example/demo/config/config1.class&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取类中 被@Bean注解修饰 的方法</span></span><br><span class="line">        Set&lt;MethodMetadata&gt; annotatedMethods =</span><br><span class="line">                metadataReader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());</span><br><span class="line"></span><br><span class="line">        annotatedMethods.forEach(method -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取 @Bean 注解上的属性值 initMethod 即 初始化执行的方法</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">initMethod</span> <span class="operator">=</span></span><br><span class="line">                    (String) method.getAnnotationAttributes(Bean.class.getName()).get(<span class="string">&quot;initMethod&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition()</span><br><span class="line">                    .setFactoryMethodOnBean(method.getMethodName(), <span class="string">&quot;config1&quot;</span>)</span><br><span class="line">                    <span class="comment">// 指定自动装配模式 ： AUTOWIRE_CONSTRUCTOR -&gt; 根据 构造方法的参数 或者 工厂方法的参数 完成自动装配</span></span><br><span class="line">                    .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR)</span><br><span class="line">                    .setInitMethodName(initMethod.length() &gt; <span class="number">0</span> ? initMethod : <span class="literal">null</span>)</span><br><span class="line">                    .getBeanDefinition();</span><br><span class="line">            <span class="comment">// 根据 Bean定义 注入到 Bean容器 中</span></span><br><span class="line">            beanFactory.registerBeanDefinition(method.getMethodName(), beanDefinition);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanFactoryBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;config1&quot;</span>, Config1.class);</span><br><span class="line"></span><br><span class="line">    genericApplicationContext.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">ComponentScanPostProcessor</span>());</span><br><span class="line">    genericApplicationContext.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">    genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(genericApplicationContext.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁容器</span></span><br><span class="line">    genericApplicationContext.destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        Resource[] resources = resolver.getResources(<span class="string">&quot;classpath:com/example/demo/mapper/**/*.class&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">annotationBeanNameGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">            <span class="comment">// 判断指定类是否是 接口</span></span><br><span class="line">            <span class="keyword">if</span> (metadataReader.getClassMetadata().isInterface()) &#123;</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span></span><br><span class="line">                        BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)</span><br><span class="line">                                .addConstructorArgValue(metadataReader.getClassMetadata().getClassName())</span><br><span class="line">                                .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</span><br><span class="line">                                .getBeanDefinition();</span><br><span class="line">                <span class="comment">// 从 元信息 中获取 beanName</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> annotationBeanNameGenerator.generateBeanName(</span><br><span class="line">                        BeanDefinitionBuilder.genericBeanDefinition(metadataReader.getClassMetadata().getClassName()).getBeanDefinition(),</span><br><span class="line">                        beanFactory</span><br><span class="line">                );</span><br><span class="line">                beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMapperFactoryBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    genericApplicationContext.registerBean(<span class="string">&quot;config1&quot;</span>, Config1.class);</span><br><span class="line"></span><br><span class="line">    genericApplicationContext.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">ComponentScanPostProcessor</span>());</span><br><span class="line">    genericApplicationContext.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessor</span>());</span><br><span class="line">    genericApplicationContext.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">MapperPostProcessor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">    genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(genericApplicationContext.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁容器</span></span><br><span class="line">    genericApplicationContext.destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Aware和InitalizingBean"><a href="#Aware和InitalizingBean" class="headerlink" title="Aware和InitalizingBean"></a>Aware和InitalizingBean</h2><blockquote><p>Aware 接口用于 注入 一些与容器相关信息：提供了一种内置的注入手段，可以注入<code>BeanFactory</code>、<code>ApplicationContext</code> 等，Aware接口属于内置功能，不加任何的扩展即可使用，不存在失效的情况</p><p>InitalizingBean接口提供一种内置的初始化方法</p><p>内置的注入和初始化不受扩展功能的影响，总会被执行，因此Spring框架内部常用它们</p></blockquote><ul><li><code>BeanNameAware</code>：注入 <code>Bean名称</code> </li><li><code>BeanFactoryAware</code>：注入 <code>BeanFactory</code> 容器</li><li><code>ApplicationContextAware</code>：注入 <code>ApplicationContext</code> 容器</li><li><code>EmbeddedValueResolverAware</code>：注入 <code>单个属性值 $&#123;&#125;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyBean.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;beanName：&#123;&#125;&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;applicationContext：&#123;&#125;&quot;</span>, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;initializingBean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/09/fcqlN2LkIwmt8OT.png" alt="image-20230709124800000"></p><h2 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h2><p>Spring提供了多种初始化和销毁的手段，它们有固定的执行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CustomBean.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot; @PostConstruct 初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot; InitializingBean接口 初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot; initMethod 初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot; @PreDestroy 销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disposeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot; disposeMethod 销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot; DisposableBean接口 销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoTestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringDemoTestApplication.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringDemoTestApplication.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;initMethod&quot;, destroyMethod = &quot;disposeMethod&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CustomBean <span class="title function_">customBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomBean</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化：@PostConstruct -&gt; InitializingBean 接口方法 -&gt; @Bean属性值initMethod</p><p>销毁：@PreDestory -&gt; DisposableBean 接口方法 -&gt; @Bean属性值 disposeMethod </p></blockquote><p><img src="https://s2.loli.net/2023/07/09/KRAumstETPi5wWZ.png" alt="image-20230709174601195"></p><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><h3 id="Scope-类型"><a href="#Scope-类型" class="headerlink" title="Scope 类型"></a>Scope 类型</h3><p><img src="https://s2.loli.net/2023/07/09/PWsfHwqrIvMxtGD.png" alt="image-20230709130657301"></p><p><img src="https://s2.loli.net/2023/07/09/uV9Dk6ivCqTmWx1.png" alt="image-20230709130805082"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForRequest</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(BeanForRequest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;销毁 BeanForRequest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;初始化 BeanForRequest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(value = WebApplicationContext.SCOPE_APPLICATION, proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForApplication</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(BeanForApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;销毁 BeanForApplication&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;初始化 BeanForApplication&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForSession</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(BeanForSession.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;销毁 BeanForSession&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;初始化 BeanForSession&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController(value = &quot;/scope&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BeanForApplication beanForApplication;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BeanForRequest beanForRequest;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BeanForSession beanForSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="string">&quot;beanForRequest:&quot;</span> + beanForRequest).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;beanForSession:&quot;</span> + beanForSession).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;beanForApplication:&quot;</span> + beanForApplication).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>每次 HTTP 请求会产生一个新的 Bean，并在请求结束后销毁</p></li><li><p>使用不同的浏览器维护着不同的 Session，因此使用不同的浏览器会产生不同的 BeanForSession 对象，该 Bean 在当前 HTTP Session 内有效，Session 过期后被销毁</p></li><li><p>每个 Web 应用启动时创建一个 Bean 对象，该 Bean 在当前Serlvet Tomcat应用启动时间内有效</p></li></ul><p><img src="https://s2.loli.net/2023/07/09/GfrqJyOmTEAQViS.png" alt="image-20230709171343040"></p><h3 id="Scope-失效分析"><a href="#Scope-失效分析" class="headerlink" title="Scope 失效分析"></a>Scope 失效分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F1</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> F1 f1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> F1 <span class="title function_">getF1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoTestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringDemoTestApplication.class);</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringDemoTestApplication.class, args);</span><br><span class="line">          <span class="type">E</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line">          logger.info(<span class="string">&quot;&#123;&#125;&quot;</span>, bean.getF1());</span><br><span class="line">          logger.info(<span class="string">&quot;&#123;&#125;&quot;</span>, bean.getF1());</span><br><span class="line">          logger.info(<span class="string">&quot;&#123;&#125;&quot;</span>, bean.getF1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/09/Vc18r5zj2IxkHCs.png" alt="image-20230709203305784"></p><p>单例注入多例，Scoep 失效情况</p><p>对于 单列对象，依赖注入仅仅发生了一次，没有用到多例的F，因此 E 用的始终是第一次依赖注入的 F</p><p><img src="https://s2.loli.net/2023/07/09/owGasvpmq8yPYDN.png" alt="image-20230709202948795"></p><p>解决方式：</p><ul><li><p>使用 @Lazy 注解生成代理</p></li><li><p>@Scope注解中的proxyMode = ScopedProxyMode.TARGET_CLASS，生成代理</p></li></ul><blockquote><p>代理对象是同一个，但是每次使用代理对象任意方法时，有代理创建新的对象</p></blockquote><ul><li>注入 ObjectFactory 工厂，从中获取多例对象</li><li>注入 ApplicationContext 工厂，从中获取多例对象</li></ul><p><img src="https://s2.loli.net/2023/07/09/ptuEGb7JvjNcCx8.png" alt="image-20230709205729574"></p><p>解决方法不同，但是原理一致，都是通过<code>代理对象</code>或者<code>工厂</code>推迟其他scope bean的获取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;BeanFactory和ApplicationContext&quot;&gt;&lt;a href=&quot;#BeanFac</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 原理 - AOP</title>
    <link href="http://example.com/2023/05/24/Spring%E5%8E%9F%E7%90%86-AOP/"/>
    <id>http://example.com/2023/05/24/Spring%E5%8E%9F%E7%90%86-AOP/</id>
    <published>2023-05-24T12:35:22.000Z</published>
    <updated>2023-07-28T10:21:45.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="Aop实现之AJC编译器"><a href="#Aop实现之AJC编译器" class="headerlink" title="Aop实现之AJC编译器"></a>Aop实现之AJC编译器</h3><p><code>AJC</code>即<code>aspectj-maven-plugin</code>插件，它可以实现静态编译代理，编译阶段 compile 对文件进行增强，可以从 生成的.class 文件可以看出</p><p>导入AJC依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">complianceLevel</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">complianceLevel</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">showWeaveInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWeaveInfo</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Xlint</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">Xlint</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 注意：IDEA下这个值要设置为false，否则运行程序时IDEA会再次编译，导致aspectj-maven-plugin编译的结果被覆盖 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">skip</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">skip</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.demo.service.MyService.execute())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAopApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringAopApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringAopApplication.class, args);</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;service class：&#123;&#125;&quot;</span>, bean.getClass());</span><br><span class="line"></span><br><span class="line">        bean.execute();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/10/r4hSuigkEmJZ3XP.png" alt="image-20230710174653369"></p><p><img src="https://s2.loli.net/2023/07/10/gZ34KhyXVxaiNEJ.png" alt="image-20230710174742615"></p><h3 id="Aop实现之agent类加载"><a href="#Aop实现之agent类加载" class="headerlink" title="Aop实现之agent类加载"></a>Aop实现之agent类加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">        submit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.demo.service.MyService.*())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAopApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringAopApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringAopApplication.class, args);</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;service class：&#123;&#125;&quot;</span>, bean.getClass());</span><br><span class="line"></span><br><span class="line">        bean.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        context.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/10/wSFYCxWXlgGskPq.png" alt="image-20230710225746667"></p><p>我们发现间接调用的方法没有被增强，这是因为该方法的调用没有被容器代理，属于类中的this调用</p><h4 id="使用agent类加载增强"><a href="#使用agent类加载增强" class="headerlink" title="使用agent类加载增强"></a>使用agent类加载增强</h4><p><img src="https://s2.loli.net/2023/07/10/CweFN8rLGv3mlbf.png" alt="image-20230710181639846"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:/Users/yuanjianwei/.m2/repository/org/aspectj/aspectjweaver/1.9.7/aspectjweaver-1.9.7.jar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/10/3hP4A9jNxRcWJUf.png" alt="image-20230710230024351"></p><p> 使用 <code>Arthas</code> 类加载时增强后的反编译该字节码文件，发现agrent在类加载时对非贬义字节码文件进行了织入增强</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad com.example.demo.service.MyService</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/10/t3BO6TJlpVeMPSG.png" alt="image-20230710230248216"></p><h3 id="Aop实现之proxy"><a href="#Aop实现之proxy" class="headerlink" title="Aop实现之proxy"></a>Aop实现之proxy</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><h5 id="JDK代理实现"><a href="#JDK代理实现" class="headerlink" title="JDK代理实现"></a>JDK代理实现</h5><p>JDK 只能代理 <strong>实现接口</strong>的类</p><h6 id="代理目标"><a href="#代理目标" class="headerlink" title="代理目标"></a>代理目标</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SmsServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;send message：&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SmsServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;before mothed：&quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;after mothed：&quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理工厂"><a href="#代理工厂" class="headerlink" title="代理工厂"></a>代理工厂</h6><blockquote><p>使用 <code>Proxy.newProxyInstance</code> 创建新的代理实例对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">    smsService.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/11/t8esvWH4jYMm3lh.png" alt="image-20230711174446761"></p><h6 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h6><p><img src="https://s2.loli.net/2023/07/11/uCy6oqcNBhsPR37.png" alt="image-20230711175232131"></p><h5 id="JDK代理原理"><a href="#JDK代理原理" class="headerlink" title="JDK代理原理"></a>JDK代理原理</h5><h6 id="模拟代理类实现"><a href="#模拟代理类实现" class="headerlink" title="模拟代理类实现"></a>模拟代理类实现</h6><p>将 增强的内容 进行抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 增强的抽象方法 和 目标对象 作为成员变量注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyInvocationHandler myInvocationHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy(MyInvocationHandler myInvocationHandler, Object target) &#123;</span><br><span class="line">        <span class="built_in">this</span>.myInvocationHandler = myInvocationHandler;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) myInvocationHandler.invoke(</span><br><span class="line">                    <span class="built_in">this</span>,</span><br><span class="line">                    target.getClass().getMethod(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;&#125;.getClass().getEnclosingMethod().getName(),</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;&#125;.getClass().getEnclosingMethod().getParameterTypes()</span><br><span class="line">                    ),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;message&#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 捕获运行时异常 直接抛出</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">            <span class="comment">// 捕获检查异常 将 检查异常 转换为 运行异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 构造方法 获取对象，调用方法实现 功能增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> test$Proxy() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">SmsServiceImpl</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">$Proxy</span> <span class="variable">$Proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy</span>(</span><br><span class="line">              (proxy, method, args) -&gt; &#123;</span><br><span class="line">                  log.info(<span class="string">&quot;before mothed：&quot;</span> + method.getName());</span><br><span class="line">                  <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(smsService, args);</span><br><span class="line">                  log.info(<span class="string">&quot;after mothed：&quot;</span> + method.getName());</span><br><span class="line">                  <span class="keyword">return</span> result;</span><br><span class="line">              &#125;,</span><br><span class="line">              smsService</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      $Proxy.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/15/AC7IiKezvypt9sS.png" alt="image-20230715155151821"></p><h5 id="JDK代理源码"><a href="#JDK代理源码" class="headerlink" title="JDK代理源码"></a>JDK代理源码</h5><blockquote><p>对于 字节码 进行 反编译</p></blockquote><p><img src="https://s2.loli.net/2023/07/15/eKf2IZUx1MoNhRy.png" alt="image-20230715213522700"></p><p><img src="https://s2.loli.net/2023/07/15/sHWPJAjpvhrB2db.png" alt="image-20230715213537939"></p><h5 id="JDK代理字节码生成"><a href="#JDK代理字节码生成" class="headerlink" title="JDK代理字节码生成"></a>JDK代理字节码生成</h5><p>JDK 代理类的生成直接是通过ASM生成字节码，没有通过对于Java源码（.class文件）的编译。通过对于字节码的反编译可以看到 Java源码。</p><p>ASM的作用是运行时动态生成字节码，没有对 源码的编译阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAsm</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 类字节码</span></span><br><span class="line">    <span class="type">byte</span>[] dump = $ProxyASMDump.dump();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造类加载起</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(name, dump, <span class="number">0</span>, dump.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 指定类加载器的二进制名称 加载类</span></span><br><span class="line">    Class&lt;?&gt; proxy = classLoader.loadClass(<span class="string">&quot;com.example.demo.$ProxyASM&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 指定参数的构造方法</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = proxy.getConstructor(InvocationHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 构造方法 构造 代理实例</span></span><br><span class="line">    <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) constructor.newInstance(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            log.info(<span class="string">&quot;before mothed：&quot;</span> + method.getName());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>(), args);</span><br><span class="line">            log.info(<span class="string">&quot;after mothed：&quot;</span> + method.getName());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用代理对象进行方法增强</span></span><br><span class="line">    smsService.send(<span class="string">&quot;Hello Wolrd!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h4><h5 id="Cglib代理实现"><a href="#Cglib代理实现" class="headerlink" title="Cglib代理实现"></a>Cglib代理实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SmsService.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;send message：&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>Enhancer.create</code> 创建代理类，两个参数：第一个是 <code>Class type</code> 即目标代理类，第二个是 <code>Callback callback</code>，第二个参数我们自定义 <code>Callback</code> 的子类 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) Enhancer.create(</span><br><span class="line">            SmsService.class,</span><br><span class="line">            (MethodInterceptor) (o, method, objects, methodProxy) -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;before mothed：&quot;</span> + method.getName());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(<span class="keyword">new</span> <span class="title class_">SmsService</span>(), objects);</span><br><span class="line">                log.info(<span class="string">&quot;after mothed：&quot;</span> + method.getName());</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line">    smsService.send(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/14/ujRQ1TJkzFatCWx.png" alt="image-20230714145641123"></p><p>Gglib 代理的本质是 <code>方法的重写</code> ，目标代理类是父类型，代理类是子类型，所以父类型的目标方法不能被 final 修饰</p><h6 id="代理优化"><a href="#代理优化" class="headerlink" title="代理优化"></a>代理优化</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DebugMethodInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj       被代理的对象即需要增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method    被拦截的方法即需要增强的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args      方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy     用于调用原始的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;before mothed：&quot;</span> + method.getName());</span><br><span class="line">        <span class="comment">// MethodProxy 内部避免通过 反射 调用</span></span><br><span class="line">        <span class="comment">// invokeSuper 第一个参数：代理对象，第二个：代理方法执行参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        logger.info(<span class="string">&quot;after mothed：&quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SmsService</span> <span class="variable">proxy</span> <span class="operator">=</span> (SmsService) CglibProxyFactory.getProxy(SmsService.class);</span><br><span class="line"></span><br><span class="line">    proxy.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Cglib代理原理"><a href="#Cglib代理原理" class="headerlink" title="Cglib代理原理"></a>Cglib代理原理</h5><blockquote><p>Cglib 代理类 的本质是继承 代理目标类，并 重写代理方法 对 代理方法进行增强。</p></blockquote><p>通过 实现 <code>MethodInterceptor</code> 接口方法，</p><p><img src="https://s2.loli.net/2023/07/16/O5QFDCSo2xB8Y1W.png" alt="image-20230716041405655"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyService</span> <span class="keyword">extends</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = SmsService.class.getDeclaredMethod(<span class="string">&quot;send&quot;</span>, String.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyService</span><span class="params">(MethodInterceptor methodInterceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) methodInterceptor.intercept(</span><br><span class="line">                    <span class="built_in">this</span>,</span><br><span class="line">                    method,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;message&#125;,</span><br><span class="line">                    <span class="literal">null</span></span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test$Proxy() &#123;</span><br><span class="line">    <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">ProxyService</span> <span class="variable">proxyService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyService</span>(</span><br><span class="line">            (obj, method, args, proxy) -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;before mothed：&quot;</span> + method.getName());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(smsService, args);</span><br><span class="line">                log.info(<span class="string">&quot;after mothed：&quot;</span> + method.getName());</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    proxyService.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/16/NgcJkfa1HSurFWl.png" alt="image-20230716035340730"></p><h5 id="Cglib-MethodProxy"><a href="#Cglib-MethodProxy" class="headerlink" title="Cglib MethodProxy"></a>Cglib MethodProxy</h5><p><code>MethodInterceptor</code> 接口中的回调的方法有一个 <code>MethodProxy</code>，可以避免通过反射调用被代理的方法而是直接调用</p><p>新增一个方法调用父类的原始方法 super.send()作为本来的原始功能方法，使用 MethodProxy.create() 进行创建 MethodProxy 方法代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyService</span> <span class="keyword">extends</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法代理对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy methodProxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = SmsService.class.getDeclaredMethod(<span class="string">&quot;send&quot;</span>, String.class);</span><br><span class="line">            <span class="comment">// 使用 MethodProxy.create() 进行创建</span></span><br><span class="line">            methodProxy = MethodProxy.create(</span><br><span class="line">                    SmsService.class,</span><br><span class="line">                    ProxyService.class,</span><br><span class="line">                    <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;send&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;superSend&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyService</span><span class="params">(MethodInterceptor methodInterceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原始功能方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">superSend</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增强功能方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) methodInterceptor.intercept(</span><br><span class="line">                    <span class="built_in">this</span>,</span><br><span class="line">                    method,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;message&#125;,</span><br><span class="line">                    methodProxy</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用目标方法时，不是通过 反射调用，而是通过 方法代理对象 调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test$Proxy() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsService</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ProxyService</span> <span class="variable">proxyService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyService</span>(</span><br><span class="line">                (obj, method, args, proxy) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">&quot;before mothed：&quot;</span> + method.getName());</span><br><span class="line">                    <span class="comment">// 通过反射调用</span></span><br><span class="line"><span class="comment">//                    Object result = method.invoke(smsService, args);</span></span><br><span class="line">                    <span class="comment">// 避免通过 反射 调用</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                    log.info(<span class="string">&quot;after mothed：&quot;</span> + method.getName());</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        proxyService.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="MethodProxy原理"><a href="#MethodProxy原理" class="headerlink" title="MethodProxy原理"></a>MethodProxy原理</h5><blockquote><p><code>MethodProxy</code> 在调用 <code>invoke</code> 和 <code>invokeSuper</code> 会避免反射调用，它通过 <code>FastClass</code> 来避免反射，Cglib 在调用这两个方法时，会分别生成两个代理类（两个FastClass的子类），通过调用代理类中的方法避免反射</p></blockquote><p><img src="https://s2.loli.net/2023/07/17/8vplGY5OL4BRfM6.png" alt="image-20230717002454447"></p><h6 id="methodProxy-invoke-代理目标对象，args"><a href="#methodProxy-invoke-代理目标对象，args" class="headerlink" title="methodProxy.invoke(代理目标对象，args)"></a>methodProxy.invoke(代理目标对象，args)</h6><p>当我们调用 <code>Method.create()</code> 静态方法时，底层会创建一个FastClass的子类（目的是避免方法的反射调用）</p><ul><li>当创建MethodProxy对象时，会构建<code>Signature</code>方法签名信息（包括方法名称和参数返回值）</li></ul><p><img src="https://s2.loli.net/2023/07/17/H4FAQnw5kVL3DmG.png" alt="image-20230717005336098"></p><ul><li>代理类会根据传人的<code>Signature</code>定义目标方法的编号</li><li>代理类中根据获取方法的定义的编号调用指定的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFastClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目标的方法的序号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signature 方法签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> index 序号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据方法编号调用目标对象的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> index, Object target, Object[] args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetFastClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractFastClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建方法签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s0.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> index, Object target, Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) ((SmsService) target).send((String) args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTargetFastClass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TargetFastClass</span> <span class="variable">targetFastClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetFastClass</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> targetFastClass.getIndex(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;send&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    targetFastClass.invoke(index, <span class="keyword">new</span> <span class="title class_">SmsService</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;Hello World!&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/17/awAViP5v7CNWHlq.png" alt="image-20230717015128779"></p><h6 id="methodProxy-invokeSuper-代理对象，args"><a href="#methodProxy-invokeSuper-代理对象，args" class="headerlink" title="methodProxy.invokeSuper(代理对象，args)"></a>methodProxy.invokeSuper(代理对象，args)</h6><p>调用 methodProxy.invokeSuper 的原理和调用 methodProxy.invoke 基本一致，唯一不同的是 获取的是 代理类中 的带原始方法的方法签名和定义编号，而 methodProxy.invoke 获取的是 代理目标类中的原始方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFastClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractFastClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;superSend&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s0.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> index, Object target, Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) ((ProxyService) target).superSend((String) args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/17/LDGM6k1ZBtKqY5i.png" alt="image-20230717020119732"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxyFastClass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProxyFastClass</span> <span class="variable">proxyFastClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFastClass</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> proxyFastClass.getIndex(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;superSend&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">   <span class="comment">// new ProxyService(new DebugMethodInterceptor()) 为代理对象</span></span><br><span class="line">    proxyFastClass.invoke(index, <span class="keyword">new</span> <span class="title class_">ProxyService</span>(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>()), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;Hello World!&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring代理选择"><a href="#Spring代理选择" class="headerlink" title="Spring代理选择"></a>Spring代理选择</h4><h5 id="Spring代理选择规则"><a href="#Spring代理选择规则" class="headerlink" title="Spring代理选择规则"></a>Spring代理选择规则</h5><blockquote><p>切点：增强匹配的规则</p><p>通知：具体增强的逻辑</p><p>切面：切点和通知的组合</p></blockquote><p>两个切面：<code>aspect</code> 和 <code>asvisor</code></p><p><code>aspect</code> 是 通知和切点的组合集合</p><p><code>advisor</code> 是 更细粒度的切面，只包含一个切点和通知</p><p><code>aspect</code> 在生效之前会拆解成多个 <code>advisor</code></p><h5 id="切面实现"><a href="#切面实现" class="headerlink" title="切面实现"></a>切面实现</h5><p>切点 在 <code>org.springframework.aop</code> 包下的 <code>PointCut</code> 接口实现</p><p><img src="https://s2.loli.net/2023/07/17/628sKjzxuBfg5rC.png" alt="image-20230717151143591"></p><p>可以使用 <code>AspectJExpressionPointcut</code> 根据 JExpression 表达式来进行模式匹配</p><p><img src="https://s2.loli.net/2023/07/17/wJSIa7TvQUqGFRn.png" alt="image-20230717152358433"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置切点</span></span><br><span class="line"><span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line"><span class="comment">// 设置切点表达式 execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])</span></span><br><span class="line">pointcut.setExpression(<span class="string">&quot;execution(* submit())&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用 MethodInterceptor 设置通知即功能增强</p><p><img src="https://s2.loli.net/2023/07/17/akKhz1T2UsbAX8g.png"></p><p><img src="https://s2.loli.net/2023/07/17/AaSxtIpvPbWfKnF.png" alt="image-20230717162045054"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置切点</span></span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    <span class="comment">// execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])</span></span><br><span class="line">    pointcut.setExpression(<span class="string">&quot;execution(* submit())&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置通知</span></span><br><span class="line">    <span class="type">MethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;before submit&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用目标</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">            logger.info(<span class="string">&quot;after submit&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 组合切面（切点 + 通知）</span></span><br><span class="line">    <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, methodInterceptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProxyFactory 创建代理</span></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    <span class="comment">// 设置代理对象</span></span><br><span class="line">    proxyFactory.setTarget(<span class="keyword">new</span> <span class="title class_">TargetService1</span>());</span><br><span class="line">    <span class="comment">// 设置切面</span></span><br><span class="line">    proxyFactory.addAdvisor(advisor);</span><br><span class="line"></span><br><span class="line">    <span class="type">TargetService1</span> <span class="variable">targetService1</span> <span class="operator">=</span> (TargetService1) proxyFactory.getProxy();</span><br><span class="line">    targetService1.execute();</span><br><span class="line">    targetService1.submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/17/Zgbew7darYAu1v3.png" alt="image-20230717161712244"></p><p>通过 调试 发现，上述 实例 Spring 使用 Cglib 生成的代理对象</p><p><img src="https://s2.loli.net/2023/07/17/tDKhQbP62f5Fmcl.png" alt="image-20230717161908379"></p><h5 id="代理选择"><a href="#代理选择" class="headerlink" title="代理选择"></a>代理选择</h5><blockquote><p>当 <code>ProxyFactory</code>间接继承<code>ProxyConfig</code>，<code>ProxyConfig</code> 内部存在一个成员变量 <code>proxyTargetClass</code>（默认为 <code>false</code>） 决定了 Spring 的代理方式</p></blockquote><ul><li>当 <code>proxyTargetClass = false</code> 时，代理目标实现接口，使用**<code>JdkDynamicAopProxy</code>**即 <code>JDK</code> 实现代理；代理没有实现接口，使用 **<code>ObjenesisCglibAopProxy</code>**即 <code>Cglib</code> 实现代理</li><li>当 <code>proxyTargetClass = false</code> 时，总使用**<code>ObjenesisCglibAopProxy</code>**即 <code>Cglib</code> 实现代理</li></ul><p><img src="https://s2.loli.net/2023/07/18/f3ZrnQ8oWObLqmY.png" alt="image-20230718192414308"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置切点</span></span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    <span class="comment">// execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])</span></span><br><span class="line">    pointcut.setExpression(<span class="string">&quot;execution(* submit())&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置通知</span></span><br><span class="line">    <span class="type">MethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;before submit&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用目标</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">            logger.info(<span class="string">&quot;after submit&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 组合切面（切点 + 通知）</span></span><br><span class="line">    <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, methodInterceptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理目标对象</span></span><br><span class="line">    <span class="type">TargetService1</span> <span class="variable">targetService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetService1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProxyFactory 创建代理</span></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    <span class="comment">// 设置代理对象</span></span><br><span class="line">    proxyFactory.setTarget(targetService);</span><br><span class="line">    <span class="comment">// 设置代理对象实现的接口 （如果不设置，默认认为 代理目标对象 没有实现接口）</span></span><br><span class="line">    proxyFactory.setInterfaces(targetService.getClass().getInterfaces());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置切面</span></span><br><span class="line">    proxyFactory.addAdvisor(advisor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Target</span> <span class="variable">targetService1</span> <span class="operator">=</span> (Target) proxyFactory.getProxy();</span><br><span class="line">    targetService1.execute();</span><br><span class="line">    targetService1.submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/19/6o8l3dLMRvJX9jw.png" alt="image-20230719000226624"></p><p><img src="https://s2.loli.net/2023/07/19/dqONe3RtQBHiDWE.png" alt="image-20230719000404857"></p><h3 id="切点匹配"><a href="#切点匹配" class="headerlink" title="切点匹配"></a>切点匹配</h3><h4 id="常见切点匹配实现"><a href="#常见切点匹配实现" class="headerlink" title="常见切点匹配实现"></a>常见切点匹配实现</h4><p><code>Spring</code> 用 <code>切点PointCut</code> 判断将来的目标方法 是否要进行功能增强。<code>AspectJExpressionPointcut</code> 是 <code>PointCut</code> 的一种具体实现，它根据切点表达式进行方法的模式匹配。</p><p>创建 <code>AspectJExpressionPointcut</code> 对象，调用 <code>setExpression</code> 设置切点表达式，可以通过 <code>matches</code> 方法判断是否与切点表达式匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(TransactionalService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTarget</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    <span class="comment">// 设置 切点表达式：判断方法是否与切点表达式匹配</span></span><br><span class="line">    aspectJExpressionPointcut1.setExpression(<span class="string">&quot;execution(* submit())&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断 类中的方法是否匹配 AspectJExpressionPointcut.matches(Method method, Class&lt;?&gt; targetClass)</span></span><br><span class="line">    logger.info(<span class="string">&quot;execute:&#123;&#125;&quot;</span>, aspectJExpressionPointcut1.matches(TargetService.class.getMethod(<span class="string">&quot;execute&quot;</span>), TargetService.class));</span><br><span class="line">    logger.info(<span class="string">&quot;submit:&#123;&#125;&quot;</span>, aspectJExpressionPointcut1.matches(TargetService.class.getMethod(<span class="string">&quot;submit&quot;</span>), TargetService.class));</span><br><span class="line"></span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    <span class="comment">// 设置 切点表达式：判断方法上的注解类型是否与切点表达式匹配</span></span><br><span class="line">    aspectJExpressionPointcut2.setExpression(<span class="string">&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;execute:&#123;&#125;&quot;</span>, aspectJExpressionPointcut2.matches(TargetService.class.getMethod(<span class="string">&quot;execute&quot;</span>), TargetService.class));</span><br><span class="line">    logger.info(<span class="string">&quot;submit:&#123;&#125;&quot;</span>, aspectJExpressionPointcut2.matches(TargetService.class.getMethod(<span class="string">&quot;submit&quot;</span>), TargetService.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/19/Uogu9ISmaRA8FVz.png" alt="image-20230719010400001"></p><h4 id="Transaction实现"><a href="#Transaction实现" class="headerlink" title="@Transaction实现"></a>@Transaction实现</h4><p><code>AspectJExpressionPointcut</code> 只能对于方法进行模式匹配，不能匹配类上的和接口上</p><p> <code>StaticMethodMatcherPointcut</code> 是一个实现 PointCut 的抽象类，可以规定 具体的匹配规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransactionalAnnotation</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StaticMethodMatcherPointcut 是一个实现 PointCut 的抽象类，可以规定 具体的匹配规则</span></span><br><span class="line">    <span class="type">StaticMethodMatcherPointcut</span> <span class="variable">staticMethodMatcherPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticMethodMatcherPointcut</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过 MergedAnnotations 工具类获取 方法 上的注解</span></span><br><span class="line">            <span class="comment">// MergedAnnotations.SearchStrategy.TYPE_HIERARCHY : 对整个类型层次结构（包括超类和实现的接口）执行完整搜索 即 实现的接口 上的注解也可以获取到</span></span><br><span class="line">            <span class="type">MergedAnnotations</span> <span class="variable">mergedAnnotations</span> <span class="operator">=</span> MergedAnnotations.from(method, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);</span><br><span class="line">            <span class="comment">// 判断 方法上是否添加了 Transactional 注解</span></span><br><span class="line">            <span class="keyword">if</span> (mergedAnnotations.isPresent(Transactional.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过 MergedAnnotations 工具类获取 类 上的注解</span></span><br><span class="line">            mergedAnnotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);</span><br><span class="line">            <span class="comment">// 判断 类上是否添加了 Transactional 注解</span></span><br><span class="line">            <span class="keyword">if</span> (mergedAnnotations.isPresent(Transactional.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    logger.info(<span class="string">&quot;execute:&#123;&#125;&quot;</span>, staticMethodMatcherPointcut.matches(TransactionalService.class.getMethod(<span class="string">&quot;execute&quot;</span>), TransactionalService.class));</span><br><span class="line">    logger.info(<span class="string">&quot;submit:&#123;&#125;&quot;</span>, staticMethodMatcherPointcut.matches(TransactionalService.class.getMethod(<span class="string">&quot;submit&quot;</span>), TransactionalService.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/19/P7ZkGEwWmIfndt9.png" alt="image-20230719014817487"></p><h3 id="从-Aspect到Advisor"><a href="#从-Aspect到Advisor" class="headerlink" title="从@Aspect到Advisor"></a>从@Aspect到Advisor</h3><blockquote><p><code>Spring</code> 切面分为 <code>@Aspect</code>切面 和 <code>Advisor</code> 切面</p><p><code>@Aspect</code> 可以有多个切点和切面，<code>Advisor</code> 只能有一个切点和切面</p><p>Spring 处理 高级的 <code>@Aspect</code> 切面，会将 高级的 <code>@Aspect</code> 切面 转换 低级 <code>Advisor</code> 切面</p></blockquote><h4 id="高级-Aspect-切面"><a href="#高级-Aspect-切面" class="headerlink" title="高级 @Aspect 切面"></a>高级 @Aspect 切面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(TestAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* submit())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;aspect before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* submit())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;aspect after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="低级-Advisor-切面"><a href="#低级-Advisor-切面" class="headerlink" title="低级 Advisor 切面"></a>低级 Advisor 切面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvisorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(AdvisorConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Advisor <span class="title function_">testAdvisor</span><span class="params">(MethodInterceptor testMethodInterceptor)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">        aspectJExpressionPointcut.setExpression(<span class="string">&quot;execution(* submit())&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, testMethodInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor <span class="title function_">testMethodInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;advisor before&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">            logger.info(<span class="string">&quot;advisor after&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AnnotationAwareAspectJAutoProxyCreator-后置处理器"><a href="#AnnotationAwareAspectJAutoProxyCreator-后置处理器" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator 后置处理器"></a><code>AnnotationAwareAspectJAutoProxyCreator</code> 后置处理器</h4><ul><li><p>找到所有的切面，将所有的 高级 <code>Aspect</code> 切面转换为 <code>Advisor</code> 切面</p></li><li><p>调用 <code>ProxyFactory</code> 创建代理对象</p></li></ul><h5 id="AnnotationAwareAspectJAutoProxyCreator-后置处理器的核心方法"><a href="#AnnotationAwareAspectJAutoProxyCreator-后置处理器的核心方法" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator 后置处理器的核心方法"></a>AnnotationAwareAspectJAutoProxyCreator 后置处理器的核心方法</h5><ul><li>查找所有符合条件的 切面 并 将高级的 <code>Aspect</code> 切面转换为 <code>Advisor</code> 切面 </li></ul><p><img src="https://s2.loli.net/2023/07/19/d2ItfO8eSVaqL5Y.png" alt="image-20230719212839646"></p><ul><li>为 有必要的 Bean 即有资格（模式匹配上的）来创建代理对象，内部调用了 <code>findEligibleAdvisors</code> ，当 <code>Advisor</code> 集合不为空则 创建代理对象</li></ul><p><img src="https://s2.loli.net/2023/07/19/xUVs1DB6S7384Xh.png" alt="image-20230719212940517"></p><p>由于 <code>AnnotationAwareAspectJAutoProxyCreator</code> 后处理器，方法由 protect 修饰，所以 只能同一个包下/子类/反射 可以调用。这里 测试类包名修改成与 <code>AnnotationAwareAspectJAutoProxyCreator</code> 位置一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.autoproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.advisor.AdvisorConfig;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.aspect.TestAspect;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Advisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConfigurationClassPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.GenericApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoAopTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPointCut</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 添加 Bean</span></span><br><span class="line">        genericApplicationContext.registerBean(<span class="string">&quot;testAspect&quot;</span>, TestAspect.class);</span><br><span class="line">        genericApplicationContext.registerBean(<span class="string">&quot;advisorConfig&quot;</span>, AdvisorConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置处理器</span></span><br><span class="line">        genericApplicationContext.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        genericApplicationContext.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line"></span><br><span class="line">        genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span> genericApplicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 TargetService1 与 容器中 PointCut 进行匹配，如果匹配则添加到 Advisor 集合中</span></span><br><span class="line">        List&lt;Advisor&gt; advisor1 = creator.findEligibleAdvisors(Target.class, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">        advisor1.forEach(advisor -&gt; log.info(<span class="string">&quot;advisor:&#123;&#125;&quot;</span>, advisor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有资格被代理并返回代理对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> creator.wrapIfNecessary(<span class="keyword">new</span> <span class="title class_">Target</span>(), <span class="string">&quot;target&quot;</span>, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;class:&#123;&#125;&quot;</span>, o.getClass());</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> (Target) o;</span><br><span class="line">        target.submit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/19/LgvAdVfEcOle7Ur.png" alt="image-20230719214930468"></p><p><img src="https://s2.loli.net/2023/07/20/fmhoC84OKvuz2y9.png" alt="image-20230720022254338"></p><h4 id="高级转换低级时机和代理生成时机"><a href="#高级转换低级时机和代理生成时机" class="headerlink" title="高级转换低级时机和代理生成时机"></a>高级转换低级时机和代理生成时机</h4><p>代理对象的创建时机一般是在 初始化之后 ，另外 当发生循环依赖时， 会发生在 创建实例 和 依赖注入之间，因为在 依赖注入的对象 并非 原始对象，而是代理对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建实例 -&gt; (*) 依赖注入 -&gt; 初始化（*）</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析切面并生成代理</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AnnotationAwareAspectJAutoProxyCreator <span class="title function_">annotationAwareAspectJAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAwareAspectJAutoProxyCreator</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 Autowired</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AutowiredAnnotationBeanPostProcessor <span class="title function_">autowiredAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@PostConstruct</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> CommonAnnotationBeanPostProcessor <span class="title function_">commonAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonAnnotationBeanPostProcessor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 切面</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodInterceptor</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Advisor <span class="title function_">advisor</span><span class="params">(MethodInterceptor methodInterceptor)</span> &#123;</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(<span class="string">&quot;execution(* submit())&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, methodInterceptor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通知</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> MethodInterceptor <span class="title function_">methodInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">                log.info(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;依赖注入:&#123;&#125;&quot;</span>, bean2.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean1</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;依赖注入:&#123;&#125;&quot;</span>, bean1.getClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        genericApplicationContext.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        genericApplicationContext.registerBean(Config.class);</span><br><span class="line">        genericApplicationContext.refresh();</span><br><span class="line">        genericApplicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们分析一下 依赖注入的情况：当注入Bean1时，首先调用 Bean1 的构造，然后进行依赖注入 Bean2 ，此时 Bean2 并没有，此时去 Bean2 的生成流程，先构造，再进行依赖注入，在依赖注入时，需要一个 被代理的 Bean1，此时发生 Bean1 的代理在 Bean1 依赖注入之前被创建，创建代理的对象被创建并存放到二级缓存中</p><p>但是 依赖注入与初始化 不应该被增强，仍然使用的是原始对象</p><p><img src="https://s2.loli.net/2023/07/20/BiYrG69hsNSyzot.png" alt="image-20230720170350065"></p><h3 id="Order-切面优先级"><a href="#Order-切面优先级" class="headerlink" title="Order 切面优先级"></a>Order 切面优先级</h3><p>切面执行的优先级 可以被控制</p><ul><li><p>高级切面上，可以添加 <code>@Order</code> 注解</p></li><li><p>低级切面上，可以通过 <code>DefaultPointcutAdvisor.setOrder()</code> 方法设置 优先级</p><p>Order 的值越小 切面的优先级越高</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvisorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(AdvisorConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Advisor <span class="title function_">testAdvisor</span><span class="params">(MethodInterceptor testMethodInterceptor)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">        aspectJExpressionPointcut.setExpression(<span class="string">&quot;execution(* submit())&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, testMethodInterceptor);</span><br><span class="line">        advisor.setOrder(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor <span class="title function_">testMethodInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;advisor before&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">            logger.info(<span class="string">&quot;advisor after&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/20/J9a6eEhTULi2j5S.png" alt="image-20230720175241497"></p><h4 id="高级切面转换为低级切面"><a href="#高级切面转换为低级切面" class="headerlink" title="高级切面转换为低级切面"></a>高级切面转换为低级切面</h4><p>调用 <code>AnnotationAwareAspectJAutoProxyCreator.wrapIfNecessary()</code> 判断是否有资格被代理并返回代理对象，该方法内部会调用 <code>findEligibleAdvisors()</code> 方法进行匹配 符合条件的<code>PointCut</code> 添加到 <code>Advisor</code> 集合中，并将 高级切面 转换为 低级切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindEligibleAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将 Aspect 高级切面 转换为 低级 Advisor 切面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切面实例工厂</span></span><br><span class="line">    <span class="type">AspectInstanceFactory</span> <span class="variable">aspectInstanceFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">TestAspect</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换后的 advisors 集合</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 类上所有的方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : TestAspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="comment">// 判断方法上是否有注解</span></span><br><span class="line">        <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">            <span class="type">Before</span> <span class="variable">annotation</span> <span class="operator">=</span> declaredMethod.getAnnotation(Before.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            aspectJExpressionPointcut.setExpression(annotation.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 前置通知 底层通知类</span></span><br><span class="line">            <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">aspectJMethodBeforeAdvice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(</span><br><span class="line">                    declaredMethod,</span><br><span class="line">                    aspectJExpressionPointcut,</span><br><span class="line">                    aspectInstanceFactory</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="type">DefaultPointcutAdvisor</span> <span class="variable">defaultPointcutAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, aspectJMethodBeforeAdvice);</span><br><span class="line"></span><br><span class="line">            advisors.add(defaultPointcutAdvisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    advisors.forEach(advisor -&gt; log.info(<span class="string">&quot;advisor:&#123;&#125;&quot;</span>, advisor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/20/z3FJeVj61tg4bOA.png" alt="image-20230720214359985"></p><p>输出 一个 Advisor 切面</p><p><img src="https://s2.loli.net/2023/07/20/bjvWksDx5NfAazG.png" alt="image-20230720214343041"></p><h5 id="底层通知实现类"><a href="#底层通知实现类" class="headerlink" title="底层通知实现类"></a>底层通知实现类</h5><ul><li>前置通知底层通知实现类：<code>AspectJMethodBeforeAdvice</code></li><li>环绕通知底层通知实现类：<code>AspectJAroundAdvice</code></li><li>返回通知底层通知实现类：<code>AspectJAfterReturningAdvice</code></li><li>异常通知底层通知实现类：<code>AspectJAfterThrowingAdvice</code></li><li>后置通知底层通知实现类：<code>AspectJAfterAdvice</code></li></ul><h3 id="静态通知调用"><a href="#静态通知调用" class="headerlink" title="静态通知调用"></a>静态通知调用</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>不同通知都会统一转换为环绕通知 <code>MethodInterceptor</code> </p><p>无论 ProxyFactory 基于什么方式创建代理对象，都会被统一转换为一个 <code>MethodInterceptor</code> 对象执行，这体现了适配器模式。做到 对于外部区分 <code>Before</code>，<code>Around</code>，<code>AfterReturning</code>，(<code>After</code>，<code>AfterThrowing</code> 本身已经实现了 <code>MethodInterceptor</code> 无需转换) ，内部统一使用 环绕通知，同意转换为  <code>MethodInterceptor</code> 对象执行</p><p>由于 Advisor 可能存在多个，一个接着一个的调用，因此需要一个调用链对象 <code>MethodInterceptor</code></p><p><img src="https://s2.loli.net/2023/07/20/T92cd3XOxB1jwDf.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/21/lBO1gsE6NPU7htf.png" alt="image-20230721175837511"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindEligibleAdvisors</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    <span class="comment">// 将 Aspect 高级切面 转换为 低级 Advisor 切面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切面实例工厂</span></span><br><span class="line">    <span class="type">AspectInstanceFactory</span> <span class="variable">aspectInstanceFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">TestAspect</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换后的 advisors 集合</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 类上所有的方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : TestAspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="comment">// 判断方法上是否有注解</span></span><br><span class="line">        <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">            <span class="type">Before</span> <span class="variable">annotation</span> <span class="operator">=</span> declaredMethod.getAnnotation(Before.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            aspectJExpressionPointcut.setExpression(annotation.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 前置通知底层通知类</span></span><br><span class="line">            <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">aspectJMethodBeforeAdvice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(</span><br><span class="line">                    declaredMethod,</span><br><span class="line">                    aspectJExpressionPointcut,</span><br><span class="line">                    aspectInstanceFactory</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="type">DefaultPointcutAdvisor</span> <span class="variable">defaultPointcutAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, aspectJMethodBeforeAdvice);</span><br><span class="line"></span><br><span class="line">            advisors.add(defaultPointcutAdvisor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(AfterReturning.class)) &#123;</span><br><span class="line">            <span class="type">AfterReturning</span> <span class="variable">annotation</span> <span class="operator">=</span> declaredMethod.getAnnotation(AfterReturning.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            aspectJExpressionPointcut.setExpression(annotation.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 前置通知底层通知类</span></span><br><span class="line">            <span class="type">AspectJAfterReturningAdvice</span> <span class="variable">aspectJAfterReturningAdvice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAfterReturningAdvice</span>(</span><br><span class="line">                    declaredMethod,</span><br><span class="line">                    aspectJExpressionPointcut,</span><br><span class="line">                    aspectInstanceFactory</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="type">DefaultPointcutAdvisor</span> <span class="variable">defaultPointcutAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, aspectJAfterReturningAdvice);</span><br><span class="line"></span><br><span class="line">            advisors.add(defaultPointcutAdvisor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(Around.class)) &#123;</span><br><span class="line">            <span class="type">Around</span> <span class="variable">annotation</span> <span class="operator">=</span> declaredMethod.getAnnotation(Around.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            aspectJExpressionPointcut.setExpression(annotation.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 前置通知底层通知类</span></span><br><span class="line">            <span class="type">AspectJAroundAdvice</span> <span class="variable">aspectJAroundAdvice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAroundAdvice</span>(</span><br><span class="line">                    declaredMethod,</span><br><span class="line">                    aspectJExpressionPointcut,</span><br><span class="line">                    aspectInstanceFactory</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="type">DefaultPointcutAdvisor</span> <span class="variable">defaultPointcutAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, aspectJAroundAdvice);</span><br><span class="line"></span><br><span class="line">            advisors.add(defaultPointcutAdvisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    advisors.forEach(advisor -&gt; log.info(<span class="string">&quot;advisor:&#123;&#125;&quot;</span>, advisor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 代理工厂 创建 代理对象</span></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.setTarget(<span class="keyword">new</span> <span class="title class_">Target</span>());</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 代理对象即执行对象 通知的集合</span></span><br><span class="line">    List&lt;Object&gt; interceptorsAndDynamicInterceptionAdvices = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(<span class="string">&quot;submit&quot;</span>), Target.class);</span><br><span class="line">    interceptorsAndDynamicInterceptionAdvices.forEach(interceptorsAndDynamicInterceptionAdvice -&gt;</span><br><span class="line">            log.info(<span class="string">&quot;interceptorsAndDynamicInterceptionAdvice:&#123;&#125;&quot;</span>, interceptorsAndDynamicInterceptionAdvice));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/21/Rs4ze5xbha3H2qc.png" alt="image-20230721175935396"></p><h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p><code>MethodBeforeAdviceAdapter</code> 将 <code>AspectJMethodBeforeAdvice</code>  转换为 <code>MethodInterceptor</code></p><p>在创建代理对象时，通过适配器将 通知 统一转换为 <code>环绕通知MethodInterceptor</code></p><p><img src="https://s2.loli.net/2023/07/21/vm59JRUeMqZpkcz.png" alt="image-20230721181536799"></p><p><img src="https://s2.loli.net/2023/07/21/cqJwCYSRyHl6vgU.png" alt="image-20230721181052056"></p><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>代理对象 内部通过 调用链接口 <code>MethodInvocation</code> 调用 目标对象 和 环绕通知集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">ReflectiveMethodInvocation</span><span class="params">(</span></span><br><span class="line"><span class="params">Object proxy, <span class="meta">@Nullable</span> Object target, Method method, <span class="meta">@Nullable</span> Object[] arguments,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers)</span> </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/21/h1crHmqVYtw7x3P.png" alt="image-20230721220341020"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoAdvisorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindEligibleAdvisors</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 将 Aspect 高级切面 转换为 低级 Advisor 切面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切面实例工厂</span></span><br><span class="line">        <span class="type">AspectInstanceFactory</span> <span class="variable">aspectInstanceFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">TestAspect</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换后的 advisors 集合</span></span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 类上所有的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : TestAspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="comment">// 判断方法上是否有注解</span></span><br><span class="line">            <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">                <span class="type">Before</span> <span class="variable">annotation</span> <span class="operator">=</span> declaredMethod.getAnnotation(Before.class);</span><br><span class="line"></span><br><span class="line">                <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">                aspectJExpressionPointcut.setExpression(annotation.value());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建 前置通知底层通知类</span></span><br><span class="line">                <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">aspectJMethodBeforeAdvice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(</span><br><span class="line">                        declaredMethod,</span><br><span class="line">                        aspectJExpressionPointcut,</span><br><span class="line">                        aspectInstanceFactory</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="type">DefaultPointcutAdvisor</span> <span class="variable">defaultPointcutAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, aspectJMethodBeforeAdvice);</span><br><span class="line"></span><br><span class="line">                advisors.add(defaultPointcutAdvisor);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(AfterReturning.class)) &#123;</span><br><span class="line">                <span class="type">AfterReturning</span> <span class="variable">annotation</span> <span class="operator">=</span> declaredMethod.getAnnotation(AfterReturning.class);</span><br><span class="line"></span><br><span class="line">                <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">                aspectJExpressionPointcut.setExpression(annotation.value());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建 前置通知底层通知类</span></span><br><span class="line">                <span class="type">AspectJAfterReturningAdvice</span> <span class="variable">aspectJAfterReturningAdvice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAfterReturningAdvice</span>(</span><br><span class="line">                        declaredMethod,</span><br><span class="line">                        aspectJExpressionPointcut,</span><br><span class="line">                        aspectInstanceFactory</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="type">DefaultPointcutAdvisor</span> <span class="variable">defaultPointcutAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, aspectJAfterReturningAdvice);</span><br><span class="line"></span><br><span class="line">                advisors.add(defaultPointcutAdvisor);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(Around.class)) &#123;</span><br><span class="line">                <span class="type">Around</span> <span class="variable">annotation</span> <span class="operator">=</span> declaredMethod.getAnnotation(Around.class);</span><br><span class="line"></span><br><span class="line">                <span class="type">AspectJExpressionPointcut</span> <span class="variable">aspectJExpressionPointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">                aspectJExpressionPointcut.setExpression(annotation.value());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建 前置通知底层通知类</span></span><br><span class="line">                <span class="type">AspectJAroundAdvice</span> <span class="variable">aspectJAroundAdvice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAroundAdvice</span>(</span><br><span class="line">                        declaredMethod,</span><br><span class="line">                        aspectJExpressionPointcut,</span><br><span class="line">                        aspectInstanceFactory</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="type">DefaultPointcutAdvisor</span> <span class="variable">defaultPointcutAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(aspectJExpressionPointcut, aspectJAroundAdvice);</span><br><span class="line"></span><br><span class="line">                advisors.add(defaultPointcutAdvisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        advisors.forEach(advisor -&gt; log.info(<span class="string">&quot;advisor:&#123;&#125;&quot;</span>, advisor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 代理工厂 创建 代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        proxyFactory.setTarget(target);</span><br><span class="line">        <span class="comment">// 将 MethodInvocation 放入当前线程</span></span><br><span class="line">        proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE);</span><br><span class="line">        proxyFactory.addAdvisors(advisors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 代理对象即执行对象 通知的集合</span></span><br><span class="line">        List&lt;Object&gt; interceptorsAndDynamicInterceptionAdvices =</span><br><span class="line">                proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">                        Target.class.getMethod(<span class="string">&quot;submit&quot;</span>),</span><br><span class="line">                        Target.class</span><br><span class="line">                );</span><br><span class="line">        interceptorsAndDynamicInterceptionAdvices.forEach(interceptorsAndDynamicInterceptionAdvice -&gt;</span><br><span class="line">                log.info(<span class="string">&quot;interceptorsAndDynamicInterceptionAdvice:&#123;&#125;&quot;</span>, interceptorsAndDynamicInterceptionAdvice));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建调用链对象</span></span><br><span class="line">        <span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line">                        <span class="literal">null</span>,</span><br><span class="line">                        target,</span><br><span class="line">                        Target.class.getMethod(<span class="string">&quot;submit&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>],</span><br><span class="line">                        Target.class,</span><br><span class="line">                        interceptorsAndDynamicInterceptionAdvices</span><br><span class="line">                );</span><br><span class="line">        methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用链执行 <code>Advisor通知</code> 时，某些通知内部可能用到 <code>MethodInvocation</code> 调用链对象，注意要添加  <code>proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE)</code> ，将 <code>MethodInvocation</code> 放入当前线程（即外部一个公共的位置），让所有的通知可以获取到 <code>MethodInvocation</code> 调用链对象</p><p><img src="https://s2.loli.net/2023/07/22/GcdZjaxXtSDkCH5.png" alt="image-20230722034351217"></p><h4 id="调用链实现"><a href="#调用链实现" class="headerlink" title="调用链实现"></a>调用链实现</h4><p>间接递归 实现 调用每一个环绕通知以及目标方法 - 责任链模式</p><p><img src="https://s2.loli.net/2023/07/26/aWU4oCnMT6stciD.png" alt="image-20230726162514322"></p><h3 id="动态通知调用"><a href="#动态通知调用" class="headerlink" title="动态通知调用"></a>动态通知调用</h3><blockquote><p>动态通知：有参数绑定的通知，执行时需要获取切点对象来进行参数匹配和绑定吗</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAopDynamicTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Aspect</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态通知调用</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Before(&quot;execution(* submit(..)) &amp;&amp; args(x)&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;before:&#123;&#125;&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;submit:&#123;&#125;&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AnnotationAwareAspectJAutoProxyCreator <span class="title function_">annotationAwareAspectJAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAwareAspectJAutoProxyCreator</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> MyAspect <span class="title function_">myAspect</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAspect</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        genericApplicationContext.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        genericApplicationContext.registerBean(MyConfig.class);</span><br><span class="line">        genericApplicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span></span><br><span class="line">                genericApplicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">        List&lt;Advisor&gt; advisors = creator.findEligibleAdvisors(Target.class, <span class="string">&quot;target&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        proxyFactory.setTarget(target);</span><br><span class="line">        proxyFactory.addAdvisors(advisors);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> proxyFactory.getProxy();</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; interceptorsAndDynamicInterceptionAdvices =</span><br><span class="line">                proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(<span class="string">&quot;submit&quot;</span>, <span class="type">int</span>.class), Target.class);</span><br><span class="line">        interceptorsAndDynamicInterceptionAdvices.forEach(o -&gt; log.info(<span class="string">&quot;interceptorsAndDynamicInterceptionAdvice:&#123;&#125;&quot;</span>, o));</span><br><span class="line"></span><br><span class="line">        interceptorsAndDynamicInterceptionAdvices.forEach(o -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (aClass.isInstance(o)) &#123;</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">interceptor</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">                    interceptor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">methodMatcher</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;methodMatcher&quot;</span>);</span><br><span class="line">                    methodMatcher.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;InterceptorAndDynamicMethodMatcher对象:&#123;&#125;&quot;</span>, o);</span><br><span class="line">                    log.info(<span class="string">&quot;interceptor对象:&#123;&#125;&quot;</span>, interceptor.get(o));</span><br><span class="line">                    log.info(<span class="string">&quot;methodMatcher对象:&#123;&#125;&quot;</span>, methodMatcher.get(o));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// new ReflectiveMethodInvocation() 属于私有方法 通过 创建子类 调用</span></span><br><span class="line">        <span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line">                        proxy,</span><br><span class="line">                        target,</span><br><span class="line">                        Target.class.getMethod(<span class="string">&quot;submit&quot;</span>, <span class="type">int</span>.class),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">100</span>&#125;,</span><br><span class="line">                        Target.class,</span><br><span class="line">                        interceptorsAndDynamicInterceptionAdvices</span><br><span class="line">                ) &#123;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/27/CJdn2hy9Y6WwOZr.png" alt="image-20230727020301364"></p><blockquote><p><code>InterceptorAndDynamicMethodMatcher</code> 属性中包含 环绕通知 和 匹配切点（为了支持动态方法调用）</p></blockquote><p><img src="https://s2.loli.net/2023/07/27/hxQ8kEHiFDIB497.png" alt="image-20230727020429481"></p><p><img src="https://s2.loli.net/2023/07/27/cdfsUjBb2vXJW6V.png" alt="image-20230727022427047"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>阅读源码-@Transaction</title>
    <link href="http://example.com/2023/05/10/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2023/05/10/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/</id>
    <published>2023-05-10T09:30:00.000Z</published>
    <updated>2023-06-15T05:49:09.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读源码-Transaction"><a href="#阅读源码-Transaction" class="headerlink" title="阅读源码-@Transaction"></a>阅读源码-@Transaction</h1><blockquote><p>@Transaction事务注解中rollBackFor和noRollbackFor底层执行逻辑</p></blockquote><h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2><h3 id="方法论-关注调用栈"><a href="#方法论-关注调用栈" class="headerlink" title="方法论-关注调用栈"></a>方法论-关注调用栈</h3><blockquote><p>栈底调用栈顶</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/zJY2pugd41cM6m5.png" alt="image-20230510144221088"></p><p>通过调用栈找到了事务相关的方法</p><blockquote><p>org.springframework.transaction.interceptor.TransactionInterceptor#invoke(MethodInvocation)</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/oXVWLZjzQ5ktM6G.png" alt="image-20230510145927339"></p><p>重新打上断点，恢复程序后，重新发送请求。从这里开始<strong>正向调试</strong>，从框架代码一步一步往业务代码执行。</p><p>步入方法，继续调试</p><blockquote><p>org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/dP4qJ9wp15gyQbt.png" alt="image-20230510150428427"></p><h3 id="方法论-开启Debug日志"><a href="#方法论-开启Debug日志" class="headerlink" title="方法论-开启Debug日志"></a>方法论-开启Debug日志</h3><blockquote><p>通过观察日志的输出，寻找阅读源码突破口</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">trace</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/10/47n9UoglftuvCcO.png" alt="image-20230510155500459"></p><p>寻找日志输出的地方，重新打上断点后，重新调试程序。</p><h3 id="方法论-查看被调用的地方"><a href="#方法论-查看被调用的地方" class="headerlink" title="方法论-查看被调用的地方"></a>方法论-查看被调用的地方</h3><blockquote><p>直接查看注解在框架哪些地方被调用</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/25up3TqmonNwDiZ.png" alt="image-20230510152743919"></p><p>当调用的地方比较少时，直接在调用的地方打上断点就可以</p><p>排除项目类、测试类、注释等后，继续找，找到SpringTransactionAnnotationParser类，但是该类仅仅是项目启动时解析Spring事务注解而已。</p><p><img src="https://s2.loli.net/2023/05/10/3rDlAngP9kOBKQm.png" alt="image-20230510152856977"></p><p><img src="https://s2.loli.net/2023/05/10/JBsAUq6djfrptaE.png" alt="image-20230510152948857"></p><p>当以上几个地方打上断点时，仅仅在项目启动过程中断点起了作用，发起调用的时候并没有在断点处停留，说明发起调用时并不会触发这部分逻辑。</p><p>换个思路，@Transaction注解在项目启动时加载，但是注解中的值rollbackFor和noRollbackfor应该在程序调用的时被调用。</p><p><img src="https://s2.loli.net/2023/05/10/hr5jJ19CzUTwEbq.png" alt="image-20230510154125286"></p><p>发现这些值只有在业务代码和注释上出现，但是我们发现注释上提到</p><blockquote><p>org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/vwmpCWdXnYKfI2t.png" alt="image-20230510154333706"></p><p><img src="https://s2.loli.net/2023/05/10/OFTneosz8mrCKck.png" alt="image-20230510154432569"></p><p>遇到一个接口好多实现类的情况下，可以直接在接口上打上断点，重新调试后，断点会自动停留在具体执行的实现类上</p><p><img src="https://s2.loli.net/2023/05/10/DKsj3POtHFB6bza.png" alt="image-20230510155753565"></p><p>在接口上打上方法断点，会走到这个实现类上中</p><blockquote><p>org.springframework.transaction.interceptor.DelegatingTransactionAttribute#rollbackOn</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/9aC642jwMGbZXUi.png" alt="image-20230510155638744"></p><p>观察此时的程序调用栈，寻找到了突破口</p><p><img src="https://s2.loli.net/2023/05/10/J9S7BiCKTf3AoqR.png" alt="image-20230510160546088"></p><p>一些知名框架的JavaDoc注释中，有很多关键的@see和@link信息，并且是最权威的正确信息，比官方文档或者技术博客清晰稳妥。</p><h2 id="搜索答案"><a href="#搜索答案" class="headerlink" title="搜索答案"></a>搜索答案</h2><blockquote><p>寻找到了突破口即最开始的地方，接下来就是反复的调试，一步一步的往下调试。</p></blockquote><p>从程序调用栈起点开始</p><blockquote><p>org.springframework.transaction.interceptor.TransactionInterceptor#invoke</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/mADzh9aZ8FypC6c.png" alt="image-20230510162607981"></p><p>选择步入方法</p><blockquote><p>org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/q8pCd3lAZguQFk6.png" alt="image-20230510162541553"></p><p>重点逻辑如下：执行业务逻辑代码，然后基于业务逻辑处理结果，然后去走不同的逻辑。</p><p>抛出异常，执行方法：completeTransactionAfterThrowing()</p><p>正常执行完毕，执行方法：commitTransactionAfterReturning()</p><p><img src="https://s2.loli.net/2023/05/10/2muWa4yodvJsSbX.png" alt="image-20230510162858976"></p><p>步入completeTransactionAfterThrowing后，继续调试，可以看到当前事务和当前异常的相关的信息</p><p><img src="https://s2.loli.net/2023/05/10/9a4rLxfygY7oVZ8.png" alt="image-20230510163501679"></p><p>在方法里，大体逻辑如下</p><p><img src="https://s2.loli.net/2023/05/10/yNOWCAcuXZbUsLq.png" alt="image-20230510164236120"></p><p>其中判断当前抛出异常是否要回滚，就是这里的重中之重。</p><p>调试过程中，遇到if-else语句要注意去构建不同的案例，以覆盖尽量多的代码逻辑。</p><p>步入判断逻辑方法中</p><blockquote><p>org.springframework.transaction.interceptor.DelegatingTransactionAttribute#targetAttribute</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/aC1f4IpvePxRJ5M.png" alt="image-20230510164805752"></p><p>继续步入方法</p><blockquote><p>org.springframework.transaction.interceptor.RuleBasedTransactionAttribute#rollbackOn</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/7AIZLXNRlwfBnag.png" alt="image-20230510165650941"></p><p>这里就是就是判断该异常是否回滚的具体逻辑：</p><blockquote><p>核心逻辑：rollbackRules中配置了注解中的回滚规则，通过循环，拿到我们程序中抛出的异常ex，去匹配规则，最好选择一个winner</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/fSmwkrtpox7HAMU.png" alt="image-20230510165908804"></p><p>如果winner为空，则走默认逻辑，如果是RuntimeException 或者是 Error 的子类，就要进行回滚。即当没有配置rollbackFor与noRollbackFor的情况下，如果抛出的异常属于RuntimeException 或者 Error 的子类，则进行回滚操作</p><p><img src="https://s2.loli.net/2023/05/10/oyYIjdA14KP5miH.png" alt="image-20230510170720869"></p><p>如果winner不为空，则查看winner是否属于NoRollbackRuleAttribute即不用回滚的配置，如果是则返回false，表示不用执行回滚操作</p><p><img src="https://s2.loli.net/2023/05/10/uTIoNVKg9m4pvDd.png" alt="image-20230510171624911"></p><p>如今的核心的问题是winner怎么来的，答案就就在如下递归调用中</p><p><img src="https://s2.loli.net/2023/05/10/74qePzTj9fdGvt6.png" alt="image-20230510172110046"></p><blockquote><p>核心理论就是：如果配置的规则不为空，则判断当前抛出的异常和配置的规则中的 rollbackFor 和 noRollbackFor 谁距离更近。这里的距离是指父类与子类之间的关系。将更近的作为winner放到return !(winner instanceof NoRollbackRuleAttribute);中进行判断</p></blockquote><p>抛出的是 RuntimeException，它距离 noRollbackFor=RuntimeException.class 为 0。RuntimeException 是 Exception 的子类，所以距离 rollbackFor = Exception.class 为 1。winner</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读源码-Transaction&quot;&gt;&lt;a href=&quot;#阅读源码-Transaction&quot; class=&quot;headerlink&quot; title=&quot;阅读源码-@Transaction&quot;&gt;&lt;/a&gt;阅读源码-@Transaction&lt;/h1&gt;&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="阅读源码" scheme="http://example.com/tags/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ELK</title>
    <link href="http://example.com/2023/05/04/ELK/"/>
    <id>http://example.com/2023/05/04/ELK/</id>
    <published>2023-05-04T07:31:22.000Z</published>
    <updated>2023-05-03T20:42:31.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><blockquote><p>ELK即Elasticsearch、Logstash、Kibana组合起来搭建的线上日志系统</p></blockquote><h2 id="ELK各个服务的作用"><a href="#ELK各个服务的作用" class="headerlink" title="ELK各个服务的作用"></a>ELK各个服务的作用</h2><ul><li>ElasticSearch：用于存储收集到的日志信息</li><li>Logstach：用于收集日志，应用整合Logstach会将日志发送给Logstach，Logstach再将日志转发到ElasticSearch</li><li>Kibana：通过Web端的可视化界面来查看日志</li></ul><h2 id="使用Docker-Compose搭建ELK环境"><a href="#使用Docker-Compose搭建ELK环境" class="headerlink" title="使用Docker Compose搭建ELK环境"></a>使用Docker Compose搭建ELK环境</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:6.4.0</span><br><span class="line">docker pull logstash:6.4.0</span><br><span class="line">docker pull kibana:6.4.0</span><br></pre></td></tr></table></figure><h3 id="使用docker-compose-yml脚本启动ELK服务"><a href="#使用docker-compose-yml脚本启动ELK服务" class="headerlink" title="使用docker-compose.yml脚本启动ELK服务"></a>使用docker-compose.yml脚本启动ELK服务</h3><h4 id="创建配置文件存放目录"><a href="#创建配置文件存放目录" class="headerlink" title="创建配置文件存放目录"></a>创建配置文件存放目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mydata/logstash</span><br></pre></td></tr></table></figure><h4 id="上传logstash-springboot-conf文件"><a href="#上传logstash-springboot-conf文件" class="headerlink" title="上传logstash-springboot.conf文件"></a>上传logstash-springboot.conf文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode =&gt; &quot;server&quot;</span><br><span class="line">    host =&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port =&gt; 4560</span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; &quot;es:9200&quot;</span><br><span class="line">    index =&gt; &quot;springboot-logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="docker-compose-yml内容"><a href="#docker-compose-yml内容" class="headerlink" title="docker-compose.yml内容"></a>docker-compose.yml内容</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:6.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;cluster.name=elasticsearch&quot;</span> <span class="comment"># 设置集群名称为elasticsearch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;discovery.type=single-node&quot;</span> <span class="comment"># 以单一节点模式启动</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> <span class="comment"># 设置使用jvm内存大小</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins</span> <span class="comment"># 插件文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/elasticsearch/data:/usr/share/elasticsearch/data</span> <span class="comment"># 数据文件挂载</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kibana:6.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch:es</span> <span class="comment"># 可以用es这个域名访问elasticsearch服务</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span> <span class="comment"># kibana在elasticsearch启动之后再启动</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;elasticsearch.hosts=http://es:9200&quot;</span> <span class="comment"># 设置访问elasticsearch的地址</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line">  <span class="attr">logstash:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">logstash:6.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">logstash</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/logstash/logstash-springboot.conf:/usr/share/logstash/pipeline/logstash.conf</span> <span class="comment"># 挂载logstash的配置文件</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span> <span class="comment"># kibana在elasticsearch启动之后再启动</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch:es</span> <span class="comment"># 可以用es这个域名访问elasticsearch服务</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4560</span><span class="string">:4560</span></span><br></pre></td></tr></table></figure><h4 id="上传到linux服务器并运行"><a href="#上传到linux服务器并运行" class="headerlink" title="上传到linux服务器并运行"></a>上传到linux服务器并运行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="ElasticSearch安装中文分词器"><a href="#ElasticSearch安装中文分词器" class="headerlink" title="ElasticSearch安装中文分词器"></a>ElasticSearch安装中文分词器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 进入es容器</span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"># 安装中文分词器插件</span><br><span class="line">elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.0/elasticsearch-analysis-ik-6.4.0.zip</span><br><span class="line"># 退出容器</span><br><span class="line">exit</span><br><span class="line"># 重启es服务</span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><h4 id="logstash中安装json-lines插件"><a href="#logstash中安装json-lines插件" class="headerlink" title="logstash中安装json_lines插件"></a>logstash中安装json_lines插件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 进入logstash容器</span><br><span class="line">docker exec -it logstash /bin/bash</span><br><span class="line"># 进入bin目录</span><br><span class="line">cd /bin/</span><br><span class="line"># 安装插件</span><br><span class="line">logstash-plugin install logstash-codec-json_lines</span><br><span class="line"># 退出容器</span><br><span class="line">exit</span><br><span class="line"># 重启logstash服务</span><br><span class="line">docker restart logstash</span><br></pre></td></tr></table></figure><p>访问地址：<a href="http://localhost:5601/">http://localhost:5601/</a></p><p><img src="https://s2.loli.net/2023/05/04/rce6qwXBdU4bs9p.png" alt="image-20230504041139207"></p><h2 id="应用集成Logstach"><a href="#应用集成Logstach" class="headerlink" title="应用集成Logstach"></a>应用集成Logstach</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--集成logstash--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加配置文件logback-spring-xml"><a href="#添加配置文件logback-spring-xml" class="headerlink" title="添加配置文件logback-spring.xml"></a>添加配置文件logback-spring.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用默认日志配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用默认的控制台日志输出实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 应用名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;APP_NAME&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">source</span>=<span class="string">&quot;spring.application.name&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;springBoot&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- LogStash访问host --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">name</span>=<span class="string">&quot;LOG_STASH_HOST&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">source</span>=<span class="string">&quot;logstash.host&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志文件保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE_PATH&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/logs&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;APP_NAME&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DEBUG日志输出到控制台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输出DEBUG以上级别日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为默认的文件日志格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DEBUG日志输出到文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_DEBUG&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输出DEBUG以上级别日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为默认的文件日志格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置日志字符集 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志名称，如果没有 File 属性，那么只会使用FileNamePattern的文件路径规则；如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;File&gt;logs/info.demo-logback.log&lt;/File&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 滚动策略，基于文件大小和时间滚动 SizeAndTimeBasedRollingPolicy --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置文件命名格式以及文件路径，定义日志切片方式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_FILE_PATH&#125;/debug/$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置日志文件大小，超过就重新生成文件，默认10M --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>$&#123;LOG_FILE_MAX_SIZE:-10MB&#125;<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件保留天数，默认30天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;LOG_FILE_MAX_HISTORY:-30&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置日志文件的上限大小 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>30GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ERROR日志输出到文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ERROR&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 只输出ERROR级别的日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 匹配到ACCEPT允许 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 没有匹配就禁止 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为默认的文件日志格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置文件命名格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_FILE_PATH&#125;/error/$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置日志文件大小，超过就重新生成文件，默认10M --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>$&#123;LOG_FILE_MAX_SIZE:-10MB&#125;<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件保留天数，默认30天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;LOG_FILE_MAX_HISTORY:-30&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DEBUG日志输出到LogStash --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOG_STASH_DEBUG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 只输出DEBUG级别的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>$&#123;LOG_STASH_HOST&#125;:4560<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">timeZone</span>&gt;</span>Asia/Shanghai<span class="tag">&lt;/<span class="name">timeZone</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 自定义日志输出格式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        &#123;</span><br><span class="line">                        &quot;project&quot;: &quot;demo&quot;,</span><br><span class="line">                        &quot;level&quot;: &quot;%level&quot;,</span><br><span class="line">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class="line">                        &quot;pid&quot;: &quot;$&#123;PID:-&#125;&quot;,</span><br><span class="line">                        &quot;thread&quot;: &quot;%thread&quot;,</span><br><span class="line">                        &quot;class&quot;: &quot;%logger&quot;,</span><br><span class="line">                        &quot;message&quot;: &quot;%message&quot;,</span><br><span class="line">                        &quot;stack_trace&quot;: &quot;%exception&#123;20&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当有多个LogStash服务时，设置访问策略为轮询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">connectionTTL</span>&gt;</span>5 minutes<span class="tag">&lt;/<span class="name">connectionTTL</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ERROR日志输出到LogStash --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOG_STASH_ERROR&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>$&#123;LOG_STASH_HOST&#125;:4561<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">timeZone</span>&gt;</span>Asia/Shanghai<span class="tag">&lt;/<span class="name">timeZone</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--自定义日志输出格式--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        &#123;</span><br><span class="line">                        &quot;project&quot;: &quot;demo&quot;,</span><br><span class="line">                        &quot;level&quot;: &quot;%level&quot;,</span><br><span class="line">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class="line">                        &quot;pid&quot;: &quot;$&#123;PID:-&#125;&quot;,</span><br><span class="line">                        &quot;thread&quot;: &quot;%thread&quot;,</span><br><span class="line">                        &quot;class&quot;: &quot;%logger&quot;,</span><br><span class="line">                        &quot;message&quot;: &quot;%message&quot;,</span><br><span class="line">                        &quot;stack_trace&quot;: &quot;%exception&#123;20&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当有多个LogStash服务时，设置访问策略为轮询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">connectionTTL</span>&gt;</span>5 minutes<span class="tag">&lt;/<span class="name">connectionTTL</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 业务日志输出到LogStash --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOG_STASH_BUSINESS&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>$&#123;LOG_STASH_HOST&#125;:4562<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">timeZone</span>&gt;</span>Asia/Shanghai<span class="tag">&lt;/<span class="name">timeZone</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 自定义日志输出格式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        &#123;</span><br><span class="line">                        &quot;project&quot;: &quot;demo&quot;,</span><br><span class="line">                        &quot;level&quot;: &quot;%level&quot;,</span><br><span class="line">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class="line">                        &quot;pid&quot;: &quot;$&#123;PID:-&#125;&quot;,</span><br><span class="line">                        &quot;thread&quot;: &quot;%thread&quot;,</span><br><span class="line">                        &quot;class&quot;: &quot;%logger&quot;,</span><br><span class="line">                        &quot;message&quot;: &quot;%message&quot;,</span><br><span class="line">                        &quot;stack_trace&quot;: &quot;%exception&#123;20&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当有多个LogStash服务时，设置访问策略为轮询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">connectionTTL</span>&gt;</span>5 minutes<span class="tag">&lt;/<span class="name">connectionTTL</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 接口访问记录日志输出到LogStash --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOG_STASH_RECORD&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>$&#123;LOG_STASH_HOST&#125;:4563<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">timeZone</span>&gt;</span>Asia/Shanghai<span class="tag">&lt;/<span class="name">timeZone</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 自定义日志输出格式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        &#123;</span><br><span class="line">                        &quot;project&quot;: &quot;demo&quot;,</span><br><span class="line">                        &quot;level&quot;: &quot;%level&quot;,</span><br><span class="line">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class="line">                        &quot;class&quot;: &quot;%logger&quot;,</span><br><span class="line">                        &quot;message&quot;: &quot;%message&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当有多个LogStash服务时，设置访问策略为轮询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">connectionTTL</span>&gt;</span>5 minutes<span class="tag">&lt;/<span class="name">connectionTTL</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制框架输出日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.slf4j&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;springfox&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.swagger&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.hibernate.validator&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.demo.component.WebLogAspect&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOG_STASH_RECORD&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.demo&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOG_STASH_BUSINESS&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE_DEBUG&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE_ERROR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOG_STASH_DEBUG&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOG_STASH_ERROR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">logstash:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">1.117</span><span class="number">.34</span><span class="number">.49</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><h2 id="在kibana中查看日志信息"><a href="#在kibana中查看日志信息" class="headerlink" title="在kibana中查看日志信息"></a>在kibana中查看日志信息</h2><h3 id="创建index-pattern"><a href="#创建index-pattern" class="headerlink" title="创建index pattern"></a>创建index pattern</h3><p><img src="https://s2.loli.net/2023/05/04/TFlIBCdyu5chQnN.png" alt="img"></p><p><img src="https://s2.loli.net/2023/05/04/LlhMDsBWTK9A8Su.png" alt="img"></p><p><img src="https://s2.loli.net/2023/05/04/SmIiVHbDsKPAR7k.png" alt="img"></p><h3 id="查看收集的日志"><a href="#查看收集的日志" class="headerlink" title="查看收集的日志"></a>查看收集的日志</h3><p><img src="https://s2.loli.net/2023/05/04/WjMInAy9oNzq7xG.png" alt="image-20230504043825348"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ELK&quot;&gt;&lt;a href=&quot;#ELK&quot; class=&quot;headerlink&quot; title=&quot;ELK&quot;&gt;&lt;/a&gt;ELK&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ELK即Elasticsearch、Logstash、Kibana组合起来搭建的线上日志系统&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="分布式日志" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>XXL-JOB</title>
    <link href="http://example.com/2023/04/27/XXL-JOB/"/>
    <id>http://example.com/2023/04/27/XXL-JOB/</id>
    <published>2023-04-27T07:31:22.000Z</published>
    <updated>2023-05-02T21:06:18.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXL-JOB"><a href="#XXL-JOB" class="headerlink" title="XXL-JOB"></a>XXL-JOB</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>XXL-JOB 是一个<strong>分布式任务调度平台</strong>，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。</p><p>中文文档：<a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p></blockquote><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p><strong>设计思想</strong>是将调度行为抽象形成<strong>调度中心公共平台</strong>，平台本身不承担业务逻辑，而是负责<strong>发起调度请求</strong>后，由<strong>执行器</strong>接收调度请求并<strong>执行任务</strong>，这里的任务抽象为<strong>分散的 JobHandler</strong>，交由执行器统一管理。通过这种方式即可实现<strong>调度</strong>与<strong>任务</strong>相互解藕，从而提高系统整体的稳定性和拓展性。</p><h3 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h3><ul><li><strong>调度模块（调度中心）</strong>：<br>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；<br>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li><li><strong>执行模块（执行器）</strong>：<br>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；<br>接收“调度中心”的执行请求、终止请求和日志请求等。</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://s2.loli.net/2023/05/03/dut1C8f7FlkeNwD.png" alt="image-20230503005646974"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><img src="https://s2.loli.net/2023/05/03/xREeT5SLyKiOpAW.png" alt="image-20230503005136536"></p><h2 id="分布式任务调度平台"><a href="#分布式任务调度平台" class="headerlink" title="分布式任务调度平台"></a>分布式任务调度平台</h2><blockquote><p>分布式下，每个服务都可以搭建为集群，这样的好处是可以将任务切片分给每一个服务从而实现并行执行，提高任务调度的处理效率。</p></blockquote><p>在集群环境下，使用单体系统的任务调度会出现很多问题：</p><ul><li>无法做到对任务的控制，避免任务的重复执行</li><li>单体应用宕机会存在任务丢失</li><li>无法做到弹性扩容即增加服务实例</li><li>如何做到对任务调度的执行情况统一监测</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull xuxueli/xxl-job-admin:2.3.1</span><br></pre></td></tr></table></figure><h3 id="创建数据卷目录"><a href="#创建数据卷目录" class="headerlink" title="创建数据卷目录"></a>创建数据卷目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p -m 777 /mydata/xxl-job/data/applogs</span><br></pre></td></tr></table></figure><h3 id="SQL文件导入到指定数据库"><a href="#SQL文件导入到指定数据库" class="headerlink" title="SQL文件导入到指定数据库"></a>SQL文件导入到指定数据库</h3><blockquote><p>SQL文件：<a href="https://gitee.com/xuxueli0323/xxl-job/blob/master/doc/db/tables_xxl_job.sql">https://gitee.com/xuxueli0323/xxl-job/blob/master/doc/db/tables_xxl_job.sql</a></p></blockquote><p><img src="https://s2.loli.net/2023/05/03/kgyw69xODiFzKra.png" alt="image-20230503011358348"></p><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --restart=always \</span><br><span class="line">-e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://1.117.34.49:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=1qaz@WSX#EDC&quot; \</span><br><span class="line"> -v /mydata/xxl-job/data/applogs:/data/applogs \</span><br><span class="line"> --name xxl-job-admin  \</span><br><span class="line"> -d xuxueli/xxl-job-admin:2.3.1</span><br></pre></td></tr></table></figure><h3 id="访问任务调度平台"><a href="#访问任务调度平台" class="headerlink" title="访问任务调度平台"></a>访问任务调度平台</h3><blockquote><p>访问：<a href="http://1.117.34.49:8080/xxl-job-admin">http://1.117.34.49:8080/xxl-job-admin</a></p></blockquote><p><img src="https://s2.loli.net/2023/05/03/GJvwaOesETqcd6x.png" alt="image-20230503013351386"></p><h2 id="SpringBoot集成XXL-JOB"><a href="#SpringBoot集成XXL-JOB" class="headerlink" title="SpringBoot集成XXL-JOB"></a>SpringBoot集成XXL-JOB</h2><blockquote><p>XXL-JOB由<strong>调度中心</strong>和<strong>执行器</strong>组成，上面部署了调度中心，下面介绍如何配置部署执行器。</p></blockquote><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置application-yml文件"><a href="#配置application-yml文件" class="headerlink" title="配置application.yml文件"></a>配置application.yml文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="comment"># 指定调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册</span></span><br><span class="line">      <span class="attr">address:</span> <span class="string">http://1.117.34.49:8080/xxl-job-admin</span></span><br><span class="line">    <span class="comment"># 执行器通讯TOKEN [选填]：非空时启用</span></span><br><span class="line">    <span class="attr">access-token:</span> <span class="string">default_token</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="comment"># 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span></span><br><span class="line">      <span class="attr">app-name:</span> <span class="string">spring-demo-xxl-job-executor</span></span><br><span class="line">      <span class="comment"># 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题</span></span><br><span class="line">      <span class="attr">address:</span></span><br><span class="line">      <span class="comment"># 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;</span></span><br><span class="line">      <span class="attr">ip:</span></span><br><span class="line">      <span class="comment"># 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口（执行器实际上是一个内嵌的服务，默认端口9999，配置多个同一服务实例时需要指定不同的执行器端口，否则会端口冲突）</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line">      <span class="comment"># 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径</span></span><br><span class="line">      <span class="attr">log-path:</span> <span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line">      <span class="comment"># 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能</span></span><br><span class="line">      <span class="attr">log-retention-days:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="编辑配置类"><a href="#编辑配置类" class="headerlink" title="编辑配置类"></a>编辑配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;xxl.job&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobProps</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> XxlJobAdminProps admin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行器配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> XxlJobExecutorProps executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与调度中心交互的accessToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">XxlJobAdminProps</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调度中心地址</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">XxlJobExecutorProps</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行器名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行器 IP</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行器端口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行器日志位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行器日志保留天数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调度中心新增执行器"><a href="#调度中心新增执行器" class="headerlink" title="调度中心新增执行器"></a>调度中心新增执行器</h3><p><img src="https://s2.loli.net/2023/05/03/y45dCv6mLEiOgAf.png" alt="image-20230503045053765"></p><h4 id="执行器的配置属性："><a href="#执行器的配置属性：" class="headerlink" title="执行器的配置属性："></a>执行器的配置属性：</h4><ul><li>AppName： 每个执行器集群的唯一标示 AppName，执行器会周期性以 AppName 为对象进行自动注册。可通过该配置自动发现注册成功的执行器，供任务调度时使用。</li><li>名称：执行器的名称（可以使用中文）</li><li>注册方式：调度中心获取执行器地址的方式。<ul><li>自动注册：执行器自动进行执行器注册，调度中心通过底层注册表可以动态发现执行器机器地址。</li><li>手动录入：人工手动录入执行器的地址信息，多地址逗号分隔，供调度中心使用。</li></ul></li><li>机器地址：”注册方式”为”手动录入”时有效，支持人工维护执行器的地址信息。</li></ul><h3 id="配置执行器自定义任务："><a href="#配置执行器自定义任务：" class="headerlink" title="配置执行器自定义任务："></a>配置执行器自定义任务：</h3><blockquote><p>配置自定义任务有很多种模式，包括Bean模式（基于方法）、Bean模式（基于类）、GLUE模式等。这里介绍通过Bean模式（基于方法)。</p><p>Bean模式（基于方法）就是每个任务对应一个方法，通过添加 <code>@XxLJob(value=&quot;自定义JobHandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)</code> 注解完成定义。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于方法注入，每个任务对应一个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@XxlJob</span>: ，注解value值对应的是调度中心新建任务的JobHandler属性的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 定时任务参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 任务异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;demoHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoHandler</span><span class="params">(String param)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 动态获取传递的参数（根据参数不同，当前调度的任务不同）</span></span><br><span class="line">        log.info(<span class="string">&quot;【param】= &#123;&#125;&quot;</span>, param);</span><br><span class="line">        <span class="comment">// 执行日志： 通过XxlJobHelper.log打印日志</span></span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;demo task run at: &#123;&#125;&quot;</span>, DateUtil.now());</span><br><span class="line">        <span class="comment">// 任务结果：默认任务结果为&quot;成功&quot;状态，不需要主动设置；可以通过XxlJobHelper.handleSuccess()/handleFail()自动设置任务结果</span></span><br><span class="line">        <span class="keyword">if</span> (RandomUtil.randomInt(<span class="number">1</span>, <span class="number">11</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            XxlJobHelper.handleSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">        XxlJobHelper.handleFail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调度中心新增任务"><a href="#调度中心新增任务" class="headerlink" title="调度中心新增任务"></a>调度中心新增任务</h3><p><img src="https://s2.loli.net/2023/05/03/j4zLSsDGpUTfVcw.webp" alt="image.png"></p><p><img src="https://s2.loli.net/2023/05/03/ktL8VusAiKegNUn.png" alt="image-20230503045742690"></p><h3 id="任务配置属性详细说明"><a href="#任务配置属性详细说明" class="headerlink" title="任务配置属性详细说明"></a>任务配置属性详细说明</h3><p><img src="https://s2.loli.net/2023/05/03/r1aVQWPslm9Ljfu.png" alt="image-20230503045953543"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XXL-JOB&quot;&gt;&lt;a href=&quot;#XXL-JOB&quot; class=&quot;headerlink&quot; title=&quot;XXL-JOB&quot;&gt;&lt;/a&gt;XXL-JOB&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    
    <category term="分布式任务" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>高级MQ</title>
    <link href="http://example.com/2023/03/17/%E9%AB%98%E7%BA%A7RabbitMq/"/>
    <id>http://example.com/2023/03/17/%E9%AB%98%E7%BA%A7RabbitMq/</id>
    <published>2023-03-17T14:25:22.000Z</published>
    <updated>2023-09-09T16:40:59.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级MQ"><a href="#高级MQ" class="headerlink" title="高级MQ"></a>高级MQ</h1><h2 id="MQ一些常见问题"><a href="#MQ一些常见问题" class="headerlink" title="MQ一些常见问题"></a>MQ一些常见问题</h2><p><img src="https://s2.loli.net/2023/03/13/wRjaG5FupUkTWJd.png" alt="image-20230313113621472"></p><p>消息可靠性问题：如何确保发送的消息至少被消费一次</p><p>延迟消息问题：如何实现消息的延迟投递</p><p>消息堆积问题：如何解决数百万消息堆积无法及时消费的问题</p><p>高可用问题：如何避免单点的MQ故障而导致的不可用问题</p><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><blockquote><p>消费者将消息投递给exchange（交换机），exchange再将消息路由到queue（队列），queue最后将消息投递到consumer（消费者）。</p></blockquote><p><img src="https://s2.loli.net/2023/03/16/xOjIubAQSiFLYMR.png" alt="image-20230316095145275"></p><ul><li>发送时丢失<ul><li>生产者发送的消息未送达exchange</li><li>消息到达exchange后未到达queue</li></ul></li><li>MQ基于内存存储消息，MQ宕机后，queue里的消息将会丢失</li><li>consumer接收到消息后未消费就宕机</li></ul><h3 id="生产者消息确认机制"><a href="#生产者消息确认机制" class="headerlink" title="生产者消息确认机制"></a>生产者消息确认机制</h3><blockquote><p>RabbitMQ提供了publiser confirm机制来避免消息发送到MQ过程中丢失的问题。</p><p>消息发送到MQ之后，会返回一个结果给发送者，表示消息是否处理成功。</p></blockquote><p><img src="https://s2.loli.net/2023/03/16/iSc6M5x3oFL8Jn1.png" alt="image-20230316101233374"></p><ul><li>publisher-confirm：发送者确认<ul><li>消息成功投递到交换机，返回ack</li><li>消息未投递到交换机，返回nack</li></ul></li><li>publisher-return：发送者回执<ul><li>消息投递到交换机，但没有路由到队列，返回ack以及路由失败原因</li></ul></li></ul><blockquote><p>注意：确认机制发送消息时，需要给每个消息设置一个全局唯一id，以区分不同消息，避免ack冲突。</p></blockquote><h4 id="SpringAMQP实现生产者确认"><a href="#SpringAMQP实现生产者确认" class="headerlink" title="SpringAMQP实现生产者确认"></a>SpringAMQP实现生产者确认</h4><h5 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 消息确认机制使用异步回调</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span>  <span class="comment"># 开启pusblier-return功能</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment"># 定义消息路由失败时的策略：true-调用returnCallback, false-直接丢弃消息</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/16/MZvVXfgoxdTt4qL.png" alt="image-20230316102359628"></p><h5 id="RabbitTemplate配置ReturnCallback"><a href="#RabbitTemplate配置ReturnCallback" class="headerlink" title="RabbitTemplate配置ReturnCallback"></a>RabbitTemplate配置ReturnCallback</h5><p><img src="https://s2.loli.net/2023/03/16/LVNFy3dBPbuenEp.png" alt="image-20230316104127492"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 设置ReturnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt;</span><br><span class="line">                log.info(<span class="string">&quot;消息发送失败, 应答码：&#123;&#125;，原因：&#123;&#125;，交换机：&#123;&#125;，路由机：&#123;&#125;，消息：&#123;&#125;&quot;</span>,</span><br><span class="line">                        replyCode, replyText, exchange, routingKey, message.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送消息指定消息ConfirmCallback"><a href="#发送消息指定消息ConfirmCallback" class="headerlink" title="发送消息指定消息ConfirmCallback"></a>发送消息指定消息ConfirmCallback</h5><p><img src="https://s2.loli.net/2023/03/16/1bInPe3QmwdHgaj.png" alt="image-20230316152945204"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">messgae</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息ID</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 添加callback</span></span><br><span class="line">    correlationData</span><br><span class="line">            .getFuture()</span><br><span class="line">            .addCallback(result -&gt; &#123;</span><br><span class="line">                        <span class="comment">// ack：消息成功</span></span><br><span class="line">                        <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;消息发送成功，ID：&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// nack：消息失败</span></span><br><span class="line">                            log.error(<span class="string">&quot;消息发送失败，ID：&#123;&#125;，原因：&#123;&#125;&quot;</span>, correlationData.getId(), result.getReason());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    ex-&gt; log.error(<span class="string">&quot;消息发送异常，ID：&#123;&#125;，原因：&#123;&#125;&quot;</span>, correlationData.getId(), ex.getMessage()));</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(directExchange, key, message);</span><br><span class="line">    log.info(<span class="string">&quot;send：&#123;&#125;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://s2.loli.net/2023/03/16/LmpIijeT34hF9AC.png" alt="image-20230316154443781"></p><p>SpringAMQP中消息确认的几种情况</p><ul><li>publisher-confirm<ul><li>消息成功发送到达exchange，返回ack</li><li>消息发送失败没有到达exchange，返回nack</li><li>消息发送过程中出现异常，没有收到回执</li></ul></li><li>publisher-return<ul><li>消息成功发送到exchange，但没有路由到队列中</li></ul></li></ul><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><blockquote><p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失</p></blockquote><h4 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">            .directExchange(<span class="string">&quot;direct.exchange&quot;</span>)</span><br><span class="line">            .durable(<span class="literal">true</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/16/nO6d4tVYqwFyp5b.png" alt="image-20230316162006288"></p><h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;direct.queue&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息持久化-1"><a href="#消息持久化-1" class="headerlink" title="消息持久化"></a>消息持久化</h4><blockquote><p>SpringAMQP中的消息默认是持久的，可以通过MessageProperties中的DeliveryMode来指定的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息准备</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        <span class="comment">// 消息持久化</span></span><br><span class="line">        .setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(directExchange,message);</span><br></pre></td></tr></table></figure><h3 id="消费者消息确认机制"><a href="#消费者消息确认机制" class="headerlink" title="消费者消息确认机制"></a>消费者消息确认机制</h3><p><img src="https://s2.loli.net/2023/03/17/Q7UXTF6Aqc2tGHy.png" alt="image-20230317124327738"></p><blockquote><p>RabbitMQ支持消费者确认机制，即消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才删除该消息。</p></blockquote><h4 id="SpringAMQP允许三种确认模式"><a href="#SpringAMQP允许三种确认模式" class="headerlink" title="SpringAMQP允许三种确认模式"></a>SpringAMQP允许三种确认模式</h4><ul><li>manual：手动ack，需要在业务代码结束后，调用api发送ack</li><li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常返回ack，抛出异常则返回nack</li><li>none：关闭ack，MQ假定消费者获取消息后成功处理，因此消费投递后立即被删除</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 允许预取消息次数</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># manual：手动ack auto：自动ack none：关闭ack</span></span><br></pre></td></tr></table></figure><h3 id="消费失败重试机制"><a href="#消费失败重试机制" class="headerlink" title="消费失败重试机制"></a>消费失败重试机制</h3><h4 id="消费者失败重试"><a href="#消费者失败重试" class="headerlink" title="消费者失败重试"></a>消费者失败重试</h4><blockquote><p>当消费者出现异常后，消息会不断的requeue（重新入列）到队列，再重新发送给消费者，然后再次异常，再次requeue，无线循环，导致mq的消息处理飙升，带来不必要的压力。</p></blockquote><p><img src="https://s2.loli.net/2023/03/17/iXbc6LYFSH8tsEZ.png" alt="image-20230317140751315"></p><blockquote><p>利用Spring的retry机制，在消费者出现异常时，利用本地重试，而不是无限制的requeue（重新入列）到mq队列。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 允许预取消息次数</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># auto：自动ack</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初始等待失败时长1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 下次失败的等待时长倍数</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">max-interval:</span> <span class="number">10</span> <span class="comment"># 最大等待时长</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># 是否为无状态 一般如果业务中包含事</span></span><br><span class="line">          <span class="string">务，这里默认为false</span></span><br></pre></td></tr></table></figure><h4 id="消费者失败消息处理策略"><a href="#消费者失败消息处理策略" class="headerlink" title="消费者失败消息处理策略"></a>消费者失败消息处理策略</h4><blockquote><p>在开启重试模式后，重试次数耗尽，如果消息依旧失败，则需要MessageRecoverer接口来处理。</p></blockquote><p>MessageRecover包含三种不同的实现</p><ul><li>RejectAndDontRequeueRecoverer（默认方式）：重试耗尽后，直接reject，丢弃消息。</li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</li><li>RepublishMessageRecoverer：重试耗尽吧，将失败消息投递到指定的交换机</li></ul><p><img src="https://s2.loli.net/2023/03/17/QkXeKjYg3Fan7OB.png" alt="image-20230317171250693"></p><p><img src="https://s2.loli.net/2023/03/17/uQlDkiwV7Od1C5F.png" alt="image-20230317151556679"></p><h4 id="消消费者失败消息处理策略"><a href="#消消费者失败消息处理策略" class="headerlink" title="消消费者失败消息处理策略"></a>消消费者失败消息处理策略</h4><p><img src="https://s2.loli.net/2023/03/17/pGygNkdxW8F5hMY.png" alt="image-20230317172149376"></p><h5 id="定义绑定失败消息的交换机、队列以及绑定关系"><a href="#定义绑定失败消息的交换机、队列以及绑定关系" class="headerlink" title="定义绑定失败消息的交换机、队列以及绑定关系"></a>定义绑定失败消息的交换机、队列以及绑定关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 失败消息配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">errorExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (FanoutExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;error.exchange&quot;</span>)</span><br><span class="line">                .durable(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(<span class="string">&quot;error.queue&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">fanoutBinding</span><span class="params">(FanoutExchange errorExchange, Queue errorQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(errorQueue)</span><br><span class="line">                .to(errorExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定于RepulishMessageRecoverer"><a href="#定于RepulishMessageRecoverer" class="headerlink" title="定于RepulishMessageRecoverer"></a>定于RepulishMessageRecoverer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republisherReceiver</span><span class="params">(RabbitTemplate rabbirTemplate)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbirTemplate, <span class="string">&quot;error.exchange&quot;</span>, <span class="string">&quot;error.queue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="确保RabbitMQ消息的可靠性"><a href="#确保RabbitMQ消息的可靠性" class="headerlink" title="确保RabbitMQ消息的可靠性"></a>确保RabbitMQ消息的可靠性</h4><ul><li>开启生产者确认机制，确保生产者的消息能到队列</li><li>开启持久化功能，确保消息未消费前在队列中不会丢失</li><li>开启消费者确认机制为auto，有spring确认消息处理成功后完成ack</li><li>开启消费者失败重试机制，并设置MessgeRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理</li></ul><p><img src="https://s2.loli.net/2023/03/17/FRWapuyHbPtJQX4.png" alt="image-20230317173221929"></p><h2 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h2><h3 id="死信"><a href="#死信" class="headerlink" title="死信"></a>死信</h3><p>当一个队列中的消息满足下列情况之一，可以成为死信（dead letter）:</p><ul><li>消费者使用basic.reject或者basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>被投递的队列消息堆积满了，最早的消息可能成功死信</li></ul><p>如果该队列配置了dead-letter-exchage属性，指定一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，简称DLX）</p><p><img src="https://s2.loli.net/2023/03/21/TKPhptLX8BUaNwx.png" alt="image-20230321095223640"></p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><h4 id="什么消息会成为死信"><a href="#什么消息会成为死信" class="headerlink" title="什么消息会成为死信"></a>什么消息会成为死信</h4><ul><li>消息被消费者reject或者返回nack</li><li>消息超时未消费</li><li>队列满了</li></ul><h4 id="如何给队列绑定死信交换机"><a href="#如何给队列绑定死信交换机" class="headerlink" title="如何给队列绑定死信交换机"></a>如何给队列绑定死信交换机</h4><ul><li>给队列设置dead-letter-exchange属性，指定一个交换机</li><li>给队列设置dead-letter-routing-key属性，设置死信交换机与死信队列的RoutingKey</li></ul><p><img src="https://s2.loli.net/2023/03/21/tuq2mL5DAXJ91yP.png" alt="image-20230321095638710"></p><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><blockquote><p>TTL即Time-To-Live，如果一个队列中的消息TTL结束仍未被消费，则会变成死信</p></blockquote><p>TTL超时分为两种情况：</p><ul><li>消息所在队列设置了存活时间</li><li>消息本身设置了存活时间</li></ul><p><img src="https://s2.loli.net/2023/03/21/7vJjKZsrGCuPb94.png" alt="image-20230321123001146"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="声明交互机和队列"><a href="#声明交互机和队列" class="headerlink" title="声明交互机和队列"></a>声明交互机和队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ttl消息队列配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(RabbitEnum.QUEUE.getExchange())</span><br><span class="line">                .durable(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directTtlExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(RabbitEnum.QUEUE_TTL.getExchange())</span><br><span class="line">                .durable(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(RabbitEnum.QUEUE.getName())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directTtlQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(RabbitEnum.QUEUE_TTL.getName())</span><br><span class="line">                .deadLetterExchange(RabbitEnum.QUEUE.getExchange())</span><br><span class="line">                .deadLetterRoutingKey(RabbitEnum.QUEUE.getRouteKey())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">messageBinding</span><span class="params">(DirectExchange dlExchange, Queue dlQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(dlQueue)</span><br><span class="line">                .to(dlExchange)</span><br><span class="line">                .with(RabbitEnum.QUEUE.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">directTtlBinding</span><span class="params">(DirectExchange directTtlExchange, Queue directTtlQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(directTtlQueue)</span><br><span class="line">                .to(directTtlExchange)</span><br><span class="line">                .with(RabbitEnum.QUEUE_TTL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="给队列设置超时时间并指定路由"><a href="#给队列设置超时时间并指定路由" class="headerlink" title="给队列设置超时时间并指定路由"></a>给队列设置超时时间并指定路由</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">directTtlQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(RabbitEnum.QUEUE_TTL.getName())</span><br><span class="line">            .deadLetterExchange(RabbitEnum.QUEUE.getExchange())</span><br><span class="line">            .deadLetterRoutingKey(RabbitEnum.QUEUE.getRouteKey())</span><br><span class="line">            .ttl(<span class="number">10000</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlSender</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        Message message = MessageBuilder</span></span><br><span class="line"><span class="comment">//                // 设置消息内容</span></span><br><span class="line"><span class="comment">//                .withBody(&quot;hello, world&quot;.getBytes(StandardCharsets.UTF_8))</span></span><br><span class="line"><span class="comment">//                // 设置消息过期时间</span></span><br><span class="line"><span class="comment">//                .setExpiration(&quot;5000&quot;)</span></span><br><span class="line"><span class="comment">//                .build();</span></span><br><span class="line"><span class="comment">//        rabbitTemplate.convertAndSend(</span></span><br><span class="line"><span class="comment">//                RabbitEnum.QUEUE_TTL.getExchange(),</span></span><br><span class="line"><span class="comment">//                RabbitEnum.QUEUE_TTL.getRouteKey(),</span></span><br><span class="line"><span class="comment">//                message</span></span><br><span class="line"><span class="comment">//        );</span></span><br><span class="line"><span class="comment">//        log.info(&quot;发送消息：&#123;&#125;&quot;, new String(message.getBody()));</span></span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                RabbitEnum.QUEUE_TTL.getExchange(),</span><br><span class="line">                RabbitEnum.QUEUE_TTL.getRouteKey(),</span><br><span class="line">                message,</span><br><span class="line">                message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 设置消息过期时间</span></span><br><span class="line">                    message.getMessageProperties().setExpiration(String.valueOf(<span class="number">1000</span> * <span class="number">10</span>));</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;direct.dl.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接受消息：&#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><h5 id="消息超时的两种方式"><a href="#消息超时的两种方式" class="headerlink" title="消息超时的两种方式"></a>消息超时的两种方式</h5><ul><li>给队列设置ttl属性，进入队列后超过ttl时间的消息会会变成死信</li><li>给消息设置ttl属性，队列接受到消息超过ttl时间后变成死信</li><li>两者共存时，以时间短的ttl为准备</li></ul><p><img src="https://s2.loli.net/2023/03/21/i1l7jgcnEXCubfe.png" alt="image-20230321191537702"></p><p><img src="https://s2.loli.net/2023/03/21/hPYCeWNIai7lG3Q.png" alt="image-20230321201920474"></p><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p><img src="https://s2.loli.net/2023/03/21/1dFWsGkTeix8AQl.png" alt="image-20230321202735890"></p><h4 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h4><p>官方插件地址：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p><p><img src="https://s2.loli.net/2023/03/22/xqWoFnJpju9aSIG.png" alt="image-20230322093852957"></p><h5 id="将文件放到挂载目录"><a href="#将文件放到挂载目录" class="headerlink" title="将文件放到挂载目录"></a>将文件放到挂载目录</h5><p><img src="https://s2.loli.net/2023/03/22/2iVyrnHWSEeFjDC.png" alt="image-20230322173707410"></p><h5 id="进入容器启动插件"><a href="#进入容器启动插件" class="headerlink" title="进入容器启动插件"></a>进入容器启动插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it rabbitmq /bin/bash</span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/22/zHKWwkgJEQuOynh.png" alt="image-20230322173540945"></p><p><img src="https://s2.loli.net/2023/03/23/mbjUfNKzwR7QH5p.png" alt="image-20230323093756654"></p><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p>DelayExchange插件的原理是对官方原生的Exchange做了功能的升级：</p><ul><li>将DelayExchange接受的消息暂存在内存中</li><li>在DelayExchange中计时，超时后投递到队列中</li></ul><blockquote><p>延迟交换机插件只负责延迟，消息路由依然是官方提供的三种模式。</p><p>我们需要添加延迟交换机插件时，指定路由方式，指定x-delay-type，可选类型有fanout，direct，topic。</p></blockquote><h5 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h5><p><img src="https://s2.loli.net/2023/03/23/WnSq1e7xkghjtLw.png" alt="image-20230323095102283"></p><h5 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h5><blockquote><p>消息的延迟时间要在发送消息时指定</p></blockquote><p><img src="https://s2.loli.net/2023/03/23/XBW2nxZC4Ofhw7Y.png" alt="image-20230323095549548"></p><h5 id="SpringAMQP使用延迟队列插件"><a href="#SpringAMQP使用延迟队列插件" class="headerlink" title="SpringAMQP使用延迟队列插件"></a>SpringAMQP使用延迟队列插件</h5><blockquote><p>DelayExchange的本质是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机。交换机的类型可以是任意类型，只要设定delayed属性为true即可。</p></blockquote><h6 id="使用注解声明"><a href="#使用注解声明" class="headerlink" title="使用注解声明"></a>使用注解声明</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/23/EtVARQDwkr2PysY.png" alt="image-20230323102126560"></p><h6 id="使用bean声明"><a href="#使用bean声明" class="headerlink" title="使用bean声明"></a>使用bean声明</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.exchange&quot;</span>)</span><br><span class="line">                .durable(<span class="literal">true</span>)</span><br><span class="line">                .delayed()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(<span class="string">&quot;delay.queue&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayBinding</span><span class="params">(DirectExchange delayExchange, Queue delayQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(delayQueue)</span><br><span class="line">                .to(delayExchange)</span><br><span class="line">                .with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/23/8Iw5WSzGeRkXKA2.png" alt="image-20230323102447618"></p><h5 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelaySender</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        amqpTemplate.convertAndSend(</span><br><span class="line">                <span class="string">&quot;delay.exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;delay&quot;</span>,</span><br><span class="line">                <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">                message -&gt; &#123;</span><br><span class="line">                    message.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息：&#123;&#125;&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p><img src="https://s2.loli.net/2023/03/23/RWLKT8eOtZ92vmh.png" alt="image-20230323111734045"></p><p>延迟队列插件使用步骤</p><ul><li>声明一个交换机，添加delayed属性为true</li><li>发送消息时，添加x-delay头，值为超时时间</li></ul><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><h3 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h3><blockquote><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限，较早进入队列的消息，可能会成为死信会被丢弃，导致消息堆积问题。</p><p>队列过长的话会占用系统较多内存，如果超过预定设置的占比，RabbitMQ为了释放内存，会将队列消息转储到硬盘中，这个过程称之为page out，page out操作会消耗较长的时间，page out的过程中队列不能被处理消息。</p></blockquote><p>解决消息堆积的三种思路</p><ul><li>增加更多消费者，提高消费速度</li><li>消费者内开启线程池加快消息处理速度</li><li>扩大队列容积，提供堆积上限</li></ul><p><img src="https://s2.loli.net/2023/03/23/kyOBbRdV8QMwes1.png" alt="image-20230323112355158"></p><h3 id="惰性队列-1"><a href="#惰性队列-1" class="headerlink" title="惰性队列"></a>惰性队列</h3><blockquote><p>从RabbitMQ的3.6.0版本开始，RabbitMQ增加了Lazy Queues的概念，也就是惰性队列。</p></blockquote><h4 id="惰性队列的特征"><a href="#惰性队列的特征" class="headerlink" title="惰性队列的特征"></a>惰性队列的特征</h4><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者消费消息要从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul><p><img src="https://s2.loli.net/2023/03/23/bidgHMq2DuL7Cnt.png" alt="image-20230323113534493"></p><p><img src="https://s2.loli.net/2023/03/23/5IZPXFNJMpbL2m7.png" alt="image-20230323114359719"></p><h4 id="使用SpringAMQP声明惰性队列"><a href="#使用SpringAMQP声明惰性队列" class="headerlink" title="使用SpringAMQP声明惰性队列"></a>使用SpringAMQP声明惰性队列</h4><ul><li>基于bean方式声明</li></ul><p><img src="https://s2.loli.net/2023/03/23/7dFAhUIwVcDqzLm.png" alt="image-20230323115830962"></p><ul><li>基于注解方式声明</li></ul><p><img src="https://s2.loli.net/2023/03/23/vo59bIfFqtXlpwu.png" alt="image-20230323120130654"></p><h5 id="发送消息-3"><a href="#发送消息-3" class="headerlink" title="发送消息"></a>发送消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySender</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            amqpTemplate.convertAndSend(<span class="string">&quot;lazy.exchange&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/23/pfaxcY2PD9nemkB.png" alt="image-20230323120612180"></p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><h5 id="惰性队列的优点"><a href="#惰性队列的优点" class="headerlink" title="惰性队列的优点"></a>惰性队列的优点</h5><ul><li>基于磁盘存储，消息上限高</li><li>没有间歇性的page out，性能比较稳定</li></ul><h5 id="惰性队列的缺点"><a href="#惰性队列的缺点" class="headerlink" title="惰性队列的缺点"></a>惰性队列的缺点</h5><ul><li>基于磁盘存储，消息处理存在时延，消息时效性会降低</li><li>性能受限于磁盘IO</li></ul><p><img src="https://s2.loli.net/2023/03/24/Jl8j4fhcDMbit6Y.png" alt="image-20230324093715376"></p><h2 id="MQ集群"><a href="#MQ集群" class="headerlink" title="MQ集群"></a>MQ集群</h2><h3 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h3><blockquote><p>RabbitMQ是基于Erlang语言编写的，而Erlang是面向并发的语言，天然支持集群模式。</p></blockquote><p>RabbitMQ的集群有两种模式：</p><ul><li>普通集群：一种分布式集群，将队列分散到集群的各个节点，提高整个集群的并发能力</li><li>镜像集群：一种主从集群，普通部署的基础上，添加了主从备份功能，提高集群的数据可用性</li></ul><blockquote><p>镜像集群虽然支持主从，但是主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ在3.8版本以后，推出了新的功能：仲裁队列来代替镜像集群，底层采用Raft协议确保主从的数据一致性。</p></blockquote><h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><blockquote><p>普通集群即标准集群（classic cluster）</p></blockquote><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>在集群的各个节点间恭共享部分数据，包括交换机、队列元信息（队列的名字、队列的所在节点等），但不包括队列中的消息</li><li>访问集群某个节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回（引用传递），当队列所在节点宕机时，队列中的消息将会丢失</li></ul><blockquote><p>集群各个节点共享的队列元信息的作用是：引用传递-消费者访问集群某一个节点时，如果要访问的队列不在该节点，由于集群节点共享队列元信息，该节点会帮消费者将消息从队列所在节点传递到当前节点并返回</p></blockquote><p><img src="https://s2.loli.net/2023/03/27/aPc9o2OrmAHdFXS.png" alt="image-20230327000955017"></p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>我们部署三个节点的RabbitMQ普通模式集群（集群中节点标识默认是：rabbit@[hostname]）</p><p>RabbitMQ依赖Erlang，Erlang语言是面向并发和分布式的语言，默认支持集群模式，底层做节点通讯时需要授权和身份认证，使用cookie认证来判断是否被允许相互通信。只有每个集群节点必须具有相同的cookie时，实例之间才可以相互的通信（cookie是一串最多255个字符的字母数字字符）。</p><h5 id="读取cookie信息"><a href="#读取cookie信息" class="headerlink" title="读取cookie信息"></a>读取cookie信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it rabbitmq cat /var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/09/8aPFZE7oIrtGLgT.png" alt="image-20230909230810351"></p><h5 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件夹</span></span><br><span class="line">mkdir -p /mydata/rabbitmq-cluster</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建配置文件</span></span><br><span class="line">touch rabbitmq.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置</span></span><br><span class="line">loopback_users.guest = false</span><br><span class="line">listeners.tcp.default = 5672</span><br><span class="line">cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config</span><br><span class="line">cluster_formation.classic_config.nodes.1 =rabbit@mq1</span><br><span class="line">cluster_formation.classic_config.nodes.2 = rabbit@mq2</span><br><span class="line">cluster_formation.classic_config.nodes.3 = rabbit@mq3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建cookie文件</span></span><br><span class="line">touch .erlang.cookie</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入cookie</span></span><br><span class="line">echo &quot;XSPZIJEFHCNREHSPFXUX&quot; &gt; .erlang.cookie</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改权限</span></span><br><span class="line">chmod 600 .erlang.cookie</span><br></pre></td></tr></table></figure><h5 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir rabbitmq1 rabbitmq2 rabbitmq3</span><br><span class="line">cp rabbitmq.conf rabbitmq1</span><br><span class="line">cp rabbitmq.conf rabbitmq2</span><br><span class="line">cp rabbitmq.conf rabbitmq3</span><br><span class="line">cp .erlang.cookie rabbitmq1</span><br><span class="line">cp .erlang.cookie rabbitmq2</span><br><span class="line">cp .erlang.cookie rabbitmq3</span><br></pre></td></tr></table></figure><h5 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create rabbitmq-net</span><br></pre></td></tr></table></figure><h5 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 5673:5672 -p 15673:15672 --name rabbitmq1 --net rabbitmq-net \</span><br><span class="line">-v /mydata/rabbitmq-cluster/rabbitmq1/rabbitmq.conf:/etc/rabbitmg/rabbitmg.conf \</span><br><span class="line">-v /mydata/rabbitmq-cluster/rabbitmq1/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-v /mydata/rabbitmq/plugins:/plugins \</span><br><span class="line">-d rabbitmq:3.9-management</span><br><span class="line"></span><br><span class="line">docker run -p 5674:5672 -p 15674:15672 --name rabbitmq2 --net rabbitmq-net \</span><br><span class="line">-v /mydata/rabbitmq-cluster/rabbitmq2/rabbitmq.conf:/etc/rabbitmg/rabbitmg.conf \</span><br><span class="line">-v /mydata/rabbitmq-cluster/rabbitmq2/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-v /mydata/rabbitmq/plugins:/plugins \</span><br><span class="line">-d rabbitmq:3.9-management</span><br><span class="line"></span><br><span class="line">docker run -p 5675:5672 -p 15675:15672 --name rabbitmq3 --net rabbitmq-net \</span><br><span class="line">-v /mydata/rabbitmq-cluster/rabbitmq3/rabbitmq.conf:/etc/rabbitmg/rabbitmg.conf \</span><br><span class="line">-v /mydata/rabbitmq-cluster/rabbitmq3/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-v /mydata/rabbitmq/plugins:/plugins \</span><br><span class="line">-d rabbitmq:3.9-management</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/09/yNcs3IhxUEjv1p4.png" alt="image-20230909235032545"></p><h3 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h3><blockquote><p>普通集群一旦创建队列的主机宕机，队列就不可用，不具备高可用的能力。</p></blockquote><p>镜像集群（本质是主从模式）</p><ul><li><p>交换机、队列、队列中的消息会在各个RabbitMQ的镜像节点之间同步数据</p></li><li><p>创建队列的节点被称为该队列的主节点，备份到的其他节点就叫做该队列的镜像节点</p></li><li><p>一个队列的主节点可能是另一个队列的镜像节点</p></li><li><p>所有操作都在主节点完成，然后同步给镜像节点</p></li><li><p>当主节点宕机时，镜像节点会替代成为新的主节点</p></li></ul><p><img src="https://s2.loli.net/2023/09/10/oQTa3DUwjs9AMzI.png" alt="image-20230910000550009"></p><h4 id="镜像模式的配置"><a href="#镜像模式的配置" class="headerlink" title="镜像模式的配置"></a>镜像模式的配置</h4><p>镜像模式的配置有三种模式：</p><p><img src="https://s2.loli.net/2023/09/10/s8xmw1HSMPUp7G9.png" alt="image-20230910001130565"></p><h5 id="exactly模式"><a href="#exactly模式" class="headerlink" title="exactly模式"></a>exactly模式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-two &quot;^two\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;, &quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>rabbitmqctl：RabbitMQ客户端命令行</li><li>set_policy：设置策略</li><li>“^two.“：匹配队列的正则表达式，符合命名规则的队列才会生效</li><li>策略内容：<ul><li>“ha-mode”:”exactly”：策略模式</li><li>“ha-params”:2：策略参数</li><li>“ha-sync-mode”:”automatic”：同步策略</li></ul></li></ul><p><img src="https://s2.loli.net/2023/09/10/w2aRIA1H7DJCW6n.png" alt="image-20230910002220268"></p><h5 id="all模式"><a href="#all模式" class="headerlink" title="all模式"></a>all模式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all &quot;^all\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/10/6cWBfqEzlr4bxKy.png" alt="image-20230910002229750"></p><h5 id="nodes模式"><a href="#nodes模式" class="headerlink" title="nodes模式"></a>nodes模式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-nodes &quot;^nodes\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/10/IhgFWyURXkDJizm.png" alt="image-20230910002511664"></p><h3 id="仲裁集群"><a href="#仲裁集群" class="headerlink" title="仲裁集群"></a>仲裁集群</h3><blockquote><p>镜像集群虽然支持主从，但是主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ在3.8版本以后，推出了新的功能：仲裁队列来代替镜像集群，底层采用Raft协议确保主从的数据一致性</p></blockquote><ul><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用简单，没有复杂的配置</li><li>主从同步基于Raft协议，保证强一致性</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="控制台添加"><a href="#控制台添加" class="headerlink" title="控制台添加"></a>控制台添加</h5><p>在控制台添加一个队列，选择队列类型为Quorum类型</p><p><img src="https://s2.loli.net/2023/09/10/q4knUQLpvCDNBzx.png" alt="image-20230910003309500"></p><h4 id="整合SpringAmqp"><a href="#整合SpringAmqp" class="headerlink" title="整合SpringAmqp"></a>整合SpringAmqp</h4><h5 id="SpringAmqp添加"><a href="#SpringAmqp添加" class="headerlink" title="SpringAmqp添加"></a>SpringAmqp添加</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> QueueBuilder</span><br><span class="line">    .durable(<span class="string">&quot;quorum.queue&quot;</span>)</span><br><span class="line">    .quorum()<span class="comment">// 仲裁队列</span></span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SpringAmqp配置"><a href="#SpringAmqp配置" class="headerlink" title="SpringAmqp配置"></a>SpringAmqp配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">addresses:</span> <span class="string">xxx.xxx.xxx.xxx:xxx</span> <span class="string">xxx.xxx.xxx.xxx:xxx</span> <span class="string">xxx.xxx.xxx.xxx:xxx</span>  <span class="string">//</span> <span class="string">集群节点地址集合</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">xxxxxx</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">xxxxxx</span></span><br><span class="line"><span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高级MQ&quot;&gt;&lt;a href=&quot;#高级MQ&quot; class=&quot;headerlink&quot; title=&quot;高级MQ&quot;&gt;&lt;/a&gt;高级MQ&lt;/h1&gt;&lt;h2 id=&quot;MQ一些常见问题&quot;&gt;&lt;a href=&quot;#MQ一些常见问题&quot; class=&quot;headerlink&quot; title=&quot;M</summary>
      
    
    
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>MySQL运维</title>
    <link href="http://example.com/2023/02/27/MySQL%E8%BF%90%E7%BB%B4/"/>
    <id>http://example.com/2023/02/27/MySQL%E8%BF%90%E7%BB%B4/</id>
    <published>2023-02-27T05:39:22.000Z</published>
    <updated>2023-05-09T13:24:41.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL运维"><a href="#MySQL运维" class="headerlink" title="MySQL运维"></a>MySQL运维</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><blockquote><p>错误日志是MySQL中最重要的日志之一，它记录了当mysqlId启动、停止以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，查看此日志。</p></blockquote><blockquote><p>该日志时默认开启的，默认存放目录/var/log/，默认的日志文件名为mysqld.log。</p></blockquote><h4 id="日志变量"><a href="#日志变量" class="headerlink" title="日志变量"></a>日志变量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看日志位置</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/RZILuGEQ9lvzM76.png" alt="image-20230227160452905"></p><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -50f ./xxx.err</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/JsgUKjL6kflcpMB.png" alt="image-20230227160802360"></p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><blockquote><p>二进制日志（BINLOG）记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>灾难数据恢复</li><li>MySQL主从复制</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%log_bin%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/zUeNlIXvWH4iBfF.png" alt="image-20230227161951389"></p><p><img src="https://s2.loli.net/2023/02/27/uOAEV7Rjs8NrocK.png" alt="image-20230227162219636"></p><h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><blockquote><p>MySQL服务器中提供了多种格式来记录二进制日志</p></blockquote><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的SQL语句，对于数据进行修改的SQL都将记录在日志文件中</td></tr><tr><td>ROW（default）</td><td>基于行的日志记录，记录的是每一行的数据变更</td></tr><tr><td>MIXED</td><td>综合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊的情况下会自动切换为ROW进行记录</td></tr></tbody></table><h4 id="日志变量-1"><a href="#日志变量-1" class="headerlink" title="日志变量"></a>日志变量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/yvpzUamlkr76V1Z.png" alt="image-20230227162726006"></p><h4 id="查看日志-1"><a href="#查看日志-1" class="headerlink" title="查看日志"></a>查看日志</h4><blockquote><p>二进制日志由二进制的方式存储，不能直接读取，需要通过二进制日志查询工具<code>mysqlbinlog</code>来查看。</p></blockquote><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [options] log_filename</span><br></pre></td></tr></table></figure><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d # 指定数据库名称，列出指定的数据库相关操作</span><br><span class="line">-o # 忽略日志的前n行命令</span><br><span class="line">-v # 将行事件（数据变更）重构为SQL语句</span><br><span class="line">-w # 将行事件（数据变更）重构为SQL语句并输出注释信息</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/swElOmr6Sbg2chH.png" alt="image-20230227165854111"></p><h4 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h4><blockquote><p>对于比较繁忙的业务系统，每天生成的binlog数据较多，长时间不清理，将占用大量的磁盘空间。</p></blockquote><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部binlog日志，删除后将日志编号从binlog.000001重新开始</td></tr><tr><td>purge master logs to ‘binlog.***’</td><td>删除***编号之前的所有日志</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td><td>删除日志为’yyyy-mm-dd hh24:mi:ss’之前产生的所有日志</td></tr></tbody></table><blockquote><p>MySQL配置文件中配置二进制日志的过期时间，设置后二进制日志过期会自动删除</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/lLZdrGQS64KkwzP.png" alt="image-20230227170902710"></p><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><blockquote><p>查询日志中记录客户端所有操作语句，而二进制日志不包含查询数据的SQL语句，默认情况下，查询日志是未开启的。</p></blockquote><h4 id="日志变量-2"><a href="#日志变量-2" class="headerlink" title="日志变量"></a>日志变量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/G7xp8RHTUPlbMyn.png" alt="image-20230227171226909"></p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /etc/my.cnf配置文件</span><br><span class="line"># 设置查询日志是否开启：0-&gt;关闭 1-&gt;开启</span><br><span class="line">general_log = 1</span><br><span class="line"># 设置日志的文件名，如果没有指定，默认的文件名为hos    t_name.log</span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/ViOkgx1c7dPQZSb.png" alt="image-20230227171943243"></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><blockquote><p>慢查询日志记录了所有执行时间超过参数long_query_time设置值并且扫描记录数不小于min_examined_row_limit的所有的SQL语句的日志。默认未开启。long_query_time默认为10秒，最小为0秒，精度可以到微秒。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置慢查询日志是否开启</span></span><br><span class="line">slow_query_log = 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置执行时间参数（单位：秒）</span></span><br><span class="line">long_query_time = 2</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，慢查询日志不会记录管理语句和不使用索引进行查找的查询。可以使用log_show_admin_statements和log_queries_not_using_indexes。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记录执行较慢的管理语句</span></span><br><span class="line">log_show_admin_statements = 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记录执行较慢的未使用索引的语句</span></span><br><span class="line">log_queries_not_using_indexes = 1</span><br></pre></td></tr></table></figure><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（日志重做）。使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制，从库同时可以作为其他服务器的主库，实现链状复制。</p></blockquote><p><img src="https://s2.loli.net/2023/02/28/FugdmB9iInkMhYo.png" alt="image-20230228142608267"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>主库出现问题，可以快速切换到从库提供服务</p></li><li><p>实现读写分离，降低主库的访问压力，另外从服务器可以使用MyISAM，提升查询性能以及节约系统的开销</p></li><li><p>主从服务器负责各自的读和写，极大程度缓解了锁的争用</p><blockquote><p>从库中执行备份（添加全局锁），避免备份期间影响主库服务</p></blockquote></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制主要涉及三种线程：<code>binlog线程</code>、<code>I/O线程</code>和<code>SQL线程</code></p><ul><li>binlog线程：负责将主服务器上的数据更改写入二进制日志(binary log)中</li><li>I/O线程：负责从主服务器上读取二进制日志(binary log)，并写入从服务器的中继日志(relay log)中</li><li>SQL线程：负责读取中继日志(relay log)并重放其中的SQL语句</li></ul><p><img src="https://pdai.tech/images/mysql/master-slave.png" alt="img"></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>主库在提交事务时，binlog线程会将数据变更记录在二进制日志文件binary log中</li><li>从库I/O线程从主库读取二进制文件binary log，并写入从库的中继日志relay log中</li><li>从库SQL线程读取中继日志relay log并重放其中的SQL语句</li></ul><p><img src="https://s2.loli.net/2023/02/28/olPcbE3eOfHgapu.png"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="https://s2.loli.net/2023/02/28/xecUrpG8YDVqnBu.png" alt="img"></p><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://s2.loli.net/2023/05/09/1mT3wfQMbaOFC5J.png" alt="image-20230509174116100"></p><p>使用单个数据库进行数据存储存在以下性能瓶颈：</p><ul><li><strong>IO瓶颈</strong>：热点数据过多，导致缓存不足，产生大量<strong>磁盘IO</strong>；请求数量过多，带宽不足导致<strong>网络IO</strong>瓶颈</li><li><strong>CPU瓶颈</strong>：排序、分组、连接查询、集合统计等SQL语会耗费大量CPU资源，请求数量多会出现CPU瓶颈</li></ul><blockquote><p>分库分表的思想是：将数据<strong>分散存储</strong>，使得单一数据库/表的数据量表变小缓解单一数据库的性能问题，从而达到提升数据库性能的目的</p></blockquote><h4 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h4><p><img src="https://s2.loli.net/2023/05/09/4PWVKrLCqJAcvbD.png" alt="image-20230509191742925"></p><h5 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h5><p><img src="https://s2.loli.net/2023/05/09/BeKqg8E3GnXThWY.png" alt="image-20230509193450618"></p><p><img src="https://s2.loli.net/2023/05/09/2HsfEVOxtcrGJSW.jpg" alt="img"></p><h5 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h5><p><img src="https://s2.loli.net/2023/05/09/SLHZUwXljt5TB9K.png" alt="image-20230509192210033"></p><p><img src="https://s2.loli.net/2023/05/09/Z7tWkaJog5nwDQq.jpg" alt="img"></p><ul><li>垂直分库：以表为依据，根据业务将<strong>不同的表</strong>拆分到不同库中，通常按照数据库中表的密集程度部署到不同的库中。<ul><li>每个库的表结构和数据不一样，所有库的并集是全量数据</li></ul></li><li>垂直分表：以字段为依据，根据字段属性将<strong>不同字段</strong>拆分到不同表中，通常按照列的关系密集程度进行切分，也可以将经常被使用的列和不经常被使用的列切分到不同的表中。<ul><li>某个表的表结构和数据不一样，一般通过一列（主键/外键）关联，所有表的并集是全量数据</li></ul></li></ul><h4 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h4><p><img src="https://s2.loli.net/2023/05/09/CefulaWQ4v5ySjM.png" alt="image-20230509193730407"></p><h3 id="MyCat概述"><a href="#MyCat概述" class="headerlink" title="MyCat概述"></a>MyCat概述</h3><h3 id="MyCat入门"><a href="#MyCat入门" class="headerlink" title="MyCat入门"></a>MyCat入门</h3><h3 id="MyCat配置"><a href="#MyCat配置" class="headerlink" title="MyCat配置"></a>MyCat配置</h3><h3 id="MyCat分片"><a href="#MyCat分片" class="headerlink" title="MyCat分片"></a>MyCat分片</h3><h4 id="MyCat管理与监控"><a href="#MyCat管理与监控" class="headerlink" title="MyCat管理与监控"></a>MyCat管理与监控</h4><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL运维&quot;&gt;&lt;a href=&quot;#MySQL运维&quot; class=&quot;headerlink&quot; title=&quot;MySQL运维&quot;&gt;&lt;/a&gt;MySQL运维&lt;/h1&gt;&lt;h2 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL进阶</title>
    <link href="http://example.com/2023/02/08/MySQL%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2023/02/08/MySQL%E8%BF%9B%E9%98%B6/</id>
    <published>2023-02-08T00:31:22.000Z</published>
    <updated>2023-06-18T15:09:25.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL进阶篇"><a href="#MySQL进阶篇" class="headerlink" title="MySQL进阶篇"></a>MySQL进阶篇</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h3><blockquote><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即事务时逻辑上的一组操作，要么同时执行成功，要么同时执行失败。</p></blockquote><p><img src="https://s2.loli.net/2023/02/03/j2m3z8rTkByhKMH.png" alt="img"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account`  (</span><br><span class="line">  `id` <span class="type">bigint</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `money` <span class="type">int</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;余额&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">3</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of account</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `account` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `account` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/03/JqF3E5U7YcwbRTK.png" alt="image-20230203092714322"></p><blockquote><p>默认MySQL的事务是自动提交的，当执行一条DML语句，MySQL会立即隐式的提交事务。</p></blockquote><p><img src="https://s2.loli.net/2023/02/03/ySB5TYRGoQuiF2m.png" alt="image-20230203092727566"></p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p><img src="https://s2.loli.net/2023/02/03/NeiuAf8G2hbJgnM.png" alt="image-20230203094016558"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 转账流程</span></span><br><span class="line"><span class="comment">-- 查询小红余额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 更新小红余额-1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 更新小明余额+1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="关闭事务的自动提交"><a href="#关闭事务的自动提交" class="headerlink" title="关闭事务的自动提交"></a>关闭事务的自动提交</h4><h5 id="查看-设置事务提交方式"><a href="#查看-设置事务提交方式" class="headerlink" title="查看/设置事务提交方式"></a>查看/设置事务提交方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务提交方式</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">-- 设置事务提交方式(1-&gt;默认提交)</span><br><span class="line">SET @@autocommit = 0;</span><br></pre></td></tr></table></figure><h5 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h5 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/03/ELGSVCpe7jl9kAK.png" alt="image-20230203111040579"></p><h4 id="显示开启事务"><a href="#显示开启事务" class="headerlink" title="显示开启事务"></a>显示开启事务</h4><h5 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- 或者start transaction</span></span><br></pre></td></tr></table></figure><h5 id="提交事务-1"><a href="#提交事务-1" class="headerlink" title="提交事务"></a>提交事务</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h5 id="回滚事务-1"><a href="#回滚事务-1" class="headerlink" title="回滚事务"></a>回滚事务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/03/3XFZDJcPq4SREtr.png" alt="image-20230203111547757"></p><h3 id="事务四大特征（ACID）"><a href="#事务四大特征（ACID）" class="headerlink" title="事务四大特征（ACID）"></a>事务四大特征（ACID）</h3><p><img src="https://s2.loli.net/2023/02/05/z2y8wiUdCDeSbxZ.png" alt="image-20230205214607139"></p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，事务的原子性确保事务要么全部成功，要么全部失败。</li></ul><p><img src="https://s2.loli.net/2023/02/05/qHxCkbJBFR9lmyD.png" alt="image-20230205214947233"></p><ul><li>一致性（Consistency）：事务执行前后，数据保持一致。</li><li>隔离性（Isolation）：并发访问数据库时，一个事务不会被另一个事务所干扰，各并发事务之间的数据库是独立的，这保证了事务在不受外部并发操作影响的独立环境下运行。</li></ul><p><img src="https://s2.loli.net/2023/02/05/DriYnLbfURXOc9q.png" alt="image-20230205220559737"></p><ul><li>持久性（Durability）：事务一旦被提交或回滚，它对数据库中数据的改变是持久的。</li></ul><p><img src="https://s2.loli.net/2023/02/05/dRhNHIUz42t5r9D.png" alt="image-20230205220643914"></p><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ul><li><h4 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="脏读（Dirty read）"></a>脏读（Dirty read）</h4></li></ul><blockquote><p>一个事务读取了另一个事务还没有提交的数据。</p><p>当事务1正在访问数据并对数据进行修改，而这种修改还提交时，事务2访问了这个数据并使用了这个数据，导致事务2读到了事务1还没有提交的脏数据。</p></blockquote><p><img src="https://s2.loli.net/2023/02/05/9oIkYvdi5yrwqG4.png" alt="image-20230205223902603"></p><ul><li><h4 id="丢弃修改（Lost-to-modify）"><a href="#丢弃修改（Lost-to-modify）" class="headerlink" title="丢弃修改（Lost to modify）"></a>丢弃修改（Lost to modify）</h4></li></ul><blockquote><p>一个事务对数据的修改保存被另一个事务的修改顶替，导致前一个事务的修改丢失。</p><p>事务1读取一个数据，事务2同时读取了数据，事务1修改了这个数据并提交，事务2也修改了这个数据并提交，事务1修改的结果被丢弃。</p></blockquote><ul><li><h4 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="不可重复读（Unrepeatable read）"></a>不可重复读（Unrepeatable read）</h4></li></ul><blockquote><p>一个事务内多次读取同一个数据，由于两次读取的间隔被其他事务修改，两次读取的数据不同。</p></blockquote><p><img src="https://s2.loli.net/2023/02/05/4nzZXQ67gBUNpdx.png" alt="image-20230205223802723"></p><ul><li><h4 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="幻读（Phantom read）"></a>幻读（Phantom read）</h4></li></ul><blockquote><p>事务获取数据发现没有对应的数据行，在插入时发现该数据已经存在。</p></blockquote><p><img src="https://s2.loli.net/2023/02/05/Nu2mbg9PE8HSi3d.png" alt="image-20230205224225940"></p><h4 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h4><blockquote><p>不可重复读面向的是同一条记录，幻读面向的是同一个范围。</p></blockquote><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="https://s2.loli.net/2023/02/05/Jwq7kzoehL9S5if.png" alt="image-20230205235931495"></p><h4 id="查看事务隔离级别"><a href="#查看事务隔离级别" class="headerlink" title="查看事务隔离级别"></a>查看事务隔离级别</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@TRANSACTION</span>_ISOLATION</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/06/K9cMVro3Xd2wyzB.png" alt="image-20230206000944954"></p><h4 id="设置事务隔离级别"><a href="#设置事务隔离级别" class="headerlink" title="设置事务隔离级别"></a>设置事务隔离级别</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED<span class="operator">|</span>READ COMMITTED<span class="operator">|</span>REPEATABLE READ<span class="operator">|</span>SERIALIZABLE]</span><br></pre></td></tr></table></figure><h4 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h4><p>出现<code>脏读</code></p><p><img src="https://s2.loli.net/2023/02/06/sSBuYrgPlL7U6V2.png" alt="image-20230206121952347"></p><h4 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h4><p>避免<code>脏读</code>，出现<code>不可重复读</code></p><p><img src="https://s2.loli.net/2023/02/06/HOP6wVhBEvYdCIk.png" alt="image-20230206132939946"></p><p><img src="https://s2.loli.net/2023/02/06/vVQpDGtckL3yTFU.png" alt="image-20230206135634049"></p><h4 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h4><blockquote><p>避免<code>不可重复度读</code>，出现<code>幻读</code></p></blockquote><p><img src="https://s2.loli.net/2023/02/06/qnYoMD5VTC43xr9.png" alt="image-20230206150509574"></p><p><img src="https://s2.loli.net/2023/02/06/burniATzSD8xQWK.png" alt="image-20230206170435638"></p><h4 id="SerialIzable"><a href="#SerialIzable" class="headerlink" title="SerialIzable"></a>SerialIzable</h4><p><img src="https://s2.loli.net/2023/02/06/w3krpiWAhMznTXL.png" alt="image-20230206172524986"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>事务隔离级别越高，数据越安全，但性能越低</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2023/02/08/34lBgVTKrxqazUi.png" alt="image-20230208111236531"></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="https://s2.loli.net/2022/08/16/UtRCdhWENvTcsHz.webp" alt="img"></p><h4 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h4><blockquote><p>服务层是与<strong>客户端连接服务</strong>，主要完成一些类似于连接处理、授权认证及相关的安全方案，服务会为安全接入的每个客户端验证他所具有的操作权限。</p></blockquote><h4 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h4><blockquote><p>服务层完成<strong>核心</strong>服务功能，如SQL接入、缓存查询、SQL的分析和优化、部分内置函数的执行，所有跨存储引擎的功能在这一层实现，如过程、函数等。</p></blockquote><h4 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h4><blockquote><p>存储引擎负责了MySQL中<strong>数据的存储和提取</strong>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，可以根据自己的需要，来选取合适的存储引擎。</p></blockquote><h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h4><blockquote><p>将数据存储在<strong>文件系统</strong>之上，并完成与存储引擎的交互。</p></blockquote><p><img src="https://s2.loli.net/2022/11/08/mGOcUVXD674taRg.png" alt="image-20221108233735095"></p><p><img src="https://s2.loli.net/2022/08/16/PruSz6Fx2nWc4lq.webp" alt="image.png"></p><h3 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h3><blockquote><p> 存储引擎是存储数据、建立索引、更新或查询数据等技术的实现方式。</p><p>存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p></blockquote><h4 id="查询表的存储引擎"><a href="#查询表的存储引擎" class="headerlink" title="查询表的存储引擎"></a>查询表的存储引擎</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询建表语句 <span class="comment">--默认存储引擎：INNODB</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/08/KLYAMF7fd4hzlnD.png" alt="image-20221108234716405"></p><h4 id="创建表时指定存储引擎"><a href="#创建表时指定存储引擎" class="headerlink" title="创建表时指定存储引擎"></a>创建表时指定存储引擎</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `表名` (</span><br><span class="line">...</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/08/uQ6UbNmYqa9xrIw.png" alt="image-20221108235050017"></p><h4 id="查看当前数据库支持的存储引擎"><a href="#查看当前数据库支持的存储引擎" class="headerlink" title="查看当前数据库支持的存储引擎"></a>查看当前数据库支持的存储引擎</h4><p><img src="https://s2.loli.net/2022/11/08/Soyxi4kqDJE6KrO.png" alt="image-20221108235510767"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前数据库支持的存储引擎</span><br><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><blockquote><p>  InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。</p></blockquote><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>DML操作遵循ACID模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5><p>xxx.ibd：xxx代表的是表名，InnoDB引擎的每张表都会对应一个表空间文件，存储该表的表结构、数据和索引。参数：innodb_file_per_table</p><p><img src="https://s2.loli.net/2022/11/09/ucvY37QpyqxwD6k.png" alt="image-20221109232246900"></p><p>进入MySQL Server的Data文件夹，查看表结构 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi xxx.ibd</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/09/iecharfLRUSuOVz.png" alt="image-20221109232609824"></p><p>InnoDB的逻辑存储结构</p><p><img src="https://s2.loli.net/2022/11/09/hYFePBZpUbaQcSI.png" alt="image-20221109233149770"></p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><blockquote><p>MyISAM是MySQL早期的默认存储引擎</p></blockquote><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><h5 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h5><p>xxx.sdi：存储表结构信息</p><p>xxx.MYD：存储数据</p><p>xxx.MYI：存储索引</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><blockquote><p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题或断电问题的影响，只能将这些表作为临时表或者缓存使用。</p></blockquote><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul><li>内存存放</li><li>hash索引（默认）</li></ul><h5 id="文件-2"><a href="#文件-2" class="headerlink" title="文件"></a>文件</h5><p>xxx.sdi：存储表结构信息</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2022/11/09/EGYZBPvpIf8bOCV.png" alt="image-20221109234316209"></p><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p><img src="https://s2.loli.net/2022/11/09/RZlwWKt915pfm6L.png" alt="image-20221109235036592"></p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2022/11/09/seFU8Lo7gmkQP9E.png" alt="image-20221109235907183"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><blockquote><p>索引（index）是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>（<strong>有序</strong>）。</p><p>在数据之外，数据库系统还<strong>维护</strong>着满足<strong>特定查找算法</strong>的数据结构即索引，这些数据结构以某种方式引用（<strong>指向</strong>）数据，以实现高级查找算法。</p></blockquote><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><blockquote><p>二叉树索引结构的只是一个示意图，并不是真实的索引结构</p></blockquote><p><img src="https://s2.loli.net/2022/11/10/tm4BuDYrbC1KNLv.png" alt="image-20221110161951161"></p><h4 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>索引提高数据检索的效率，降级数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>索引列会占用一定磁盘空间</li><li>索引大大提高查询效率，同时降低更新表的速度（新增，修改和删除）</li></ul><p><img src="https://s2.loli.net/2022/11/10/mxV9uQ6YJwnIWCd.png" alt="image-20221110162719161"></p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包括：</p><p><img src="https://s2.loli.net/2022/11/10/VOPx7lqu9W86fgk.png" alt="image-20221110230354617"></p><ul><li>B+ Tree索引：最常见的索引类型，大部分引擎支持B+树索引</li><li>Hash索引：底层数据结构使用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</li><li>R-tree空间索引：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</li><li>Full-text全文索引：一种通过建立倒排索引、快速匹配文档的方式，类似于Lucenes、Solr、ES</li></ul><p><img src="https://s2.loli.net/2022/11/10/nIUbikG4a3lNJEq.png" alt="image-20221110233548679"></p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><blockquote><p> 如果MySQL的索引结构采用二叉树的数据结构，理想的情况下，查询效率为log2n；</p><p>但是如果主键是顺序插入，则会形成一个单向链表。</p></blockquote><h5 id="二叉树缺点"><a href="#二叉树缺点" class="headerlink" title="二叉树缺点"></a>二叉树缺点</h5><blockquote><ul><li>顺序插入时，形成一个链表，查询性能大大降低</li><li>大数据量的情况下，层级较深，检索速度慢</li></ul></blockquote><p><img src="https://s2.loli.net/2022/11/11/poTPteKWb4LDlAF.png" alt="image-20221111094158256"></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><blockquote><p>红黑树是一颗自平衡二叉树</p></blockquote><p><img src="https://s2.loli.net/2022/11/11/KEgXWUlzhDbjPY8.png" alt="image-20221111095259654"></p><h5 id="红黑树缺点"><a href="#红黑树缺点" class="headerlink" title="红黑树缺点"></a>红黑树缺点</h5><blockquote><ul><li>大数据量的情况下，层级较深，检索速度慢</li></ul></blockquote><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><blockquote><p>B树是一种多路平衡查找树，B树的每个节点可以有多个分支，即多叉。</p><p>树的度数指的是一个节点的子节点个数。</p></blockquote><p><img src="https://s2.loli.net/2022/11/11/bEQWz1MhfcIu3YN.png" alt="image-20221111100446722"></p><p>通过一个数据结构可视化网站演示：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p><p><img src="https://s2.loli.net/2022/11/11/cr8WwdUPQoFzbGy.png" alt="image-20221111134903797"></p><p>顺序插入一组数据，观察树的变化过程</p><p><img src="https://s2.loli.net/2022/11/11/a295b3DtAU4h6J7.png" alt="image-20221111134932851"></p><h5 id="n阶B树特点"><a href="#n阶B树特点" class="headerlink" title="n阶B树特点"></a>n阶B树特点</h5><blockquote><ul><li>每一个节点最多存储n-1个Key，对应n个指针</li><li>一旦节点存储的Key数量超过n-1，中间元素就会向上分裂</li><li>B树中，非叶子节点和叶子节点都会存放数据</li></ul></blockquote><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><blockquote><p>B+Tree是B-Tree的变种</p><p>以一颗最大度数为4（4阶）的B+Tree为例，我们可以看到：</p><ul><li>绿色虚线框部分是索引部分，起到索引数据的作用，不存储数据</li><li>红色虚线框部分是数据存储部分，其叶子节点中存储具体的数据</li></ul></blockquote><p><img src="https://s2.loli.net/2022/11/11/mkObhc23jWRQXGq.png" alt="image-20221111142037841"></p><p>通过一个数据结构可视化网站演示：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p><p>与B-Tree的区别</p><blockquote><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成了一个单向链表</li><li>非叶子节点仅仅起到了索引数据的作用，具体数据都在叶子节点中存放</li></ul></blockquote><blockquote><p>MySQL中对于经典的B+Tree数据类型进行了优化，在原有的基础上，增加一个指向相邻叶子节点的链表指针，形成了有序指针的B+Tree，提高了区间访问的性能，利于数据库的排序操作。</p></blockquote><p><img src="https://s2.loli.net/2022/11/11/N8xtfb2Xemvd6WT.png" alt="image-20221111143409638"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><blockquote><p>哈希索引就是采用一定的Hash算法，将键值换算成新的Hash值，映射到哈希表对应的槽位上，然后存储在hash表中。</p></blockquote><p><img src="https://s2.loli.net/2022/11/11/La2SImJWo8eO5uE.png" alt="image-20221111144332172"></p><blockquote><p>如果两个（或多个）键值，映射到一个相同的槽位上，就产生Hash冲突（即Hash碰撞），可以通过链表来解决</p></blockquote><p><img src="https://s2.loli.net/2022/11/11/i69A3XxVsYUuCvz.png" alt="image-20221111144912391"></p><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><blockquote><ul><li>Hash索引只能用于对等比较（=，in），不支持范围查询（between,&gt;,&lt;,…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，Hash索引在等值查询上比B+树效率更高</li></ul></blockquote><h5 id="搜索引擎支持"><a href="#搜索引擎支持" class="headerlink" title="搜索引擎支持"></a>搜索引擎支持</h5><blockquote><p>在MySQL中，支持Hash索引的是Memory引擎，而InnoDB中具有自适应Hash功能，hash索引是在存储引擎根据B+Tree索引在指定条件下自动构建的</p></blockquote><h4 id="InnoDB存储引擎选择使用B-Tree索引结构"><a href="#InnoDB存储引擎选择使用B-Tree索引结构" class="headerlink" title="InnoDB存储引擎选择使用B+Tree索引结构"></a>InnoDB存储引擎选择使用B+Tree索引结构</h4><blockquote><ul><li>相对于二叉树，<strong>层级</strong>更<strong>少</strong>，<strong>搜索效率高</strong></li><li>相对于B-Tree，无论是叶子节点还是非叶子节点都会<strong>保存数据</strong>，这会导致一页中存储的键值减少即指针减少，保保存同样的大量数据，只能增加树的高度，导致性能的降低</li><li>相对于Hash索引，B+Tree支持<strong>范围匹配</strong>及<strong>排序</strong>操作</li></ul></blockquote><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><h4 id="索引的具体类型"><a href="#索引的具体类型" class="headerlink" title="索引的具体类型"></a>索引的具体类型</h4><blockquote><p>在MySQL数据库中，索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引</p></blockquote><p><img src="https://s2.loli.net/2022/11/11/EvzdPjxpIgmotVA.png" alt="image-20221111152229540"></p><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">主键索引</td><td align="center">针对于表中的主键创建的索引</td><td align="center">默认自动创建，只能有一个</td><td align="center">PRIMARY</td></tr><tr><td align="center">唯一索引</td><td align="center">避免同一个表中某数据列中的值重复</td><td align="center">可以存在多个</td><td align="center">UNIQUE</td></tr><tr><td align="center">常规索引</td><td align="center">快速定位特定数据</td><td align="center">可以存在多个</td><td align="center"></td></tr><tr><td align="center">全文索引</td><td align="center">查找是文本中关键词，而非比较索引中的值</td><td align="center">可以存在多个</td><td align="center">FULLTEXT</td></tr></tbody></table><h4 id="索引的存储形式"><a href="#索引的存储形式" class="headerlink" title="索引的存储形式"></a>索引的存储形式</h4><blockquote><p>在InnoDB存储引擎中，根据索引的存储形式，可以分为聚集索引和二级索引。</p></blockquote><p><img src="https://s2.loli.net/2022/11/11/K8RclpZVob5OWCP.png" alt="image-20221111153640531"></p><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">聚集索引（Clustered Index）</td><td align="center">将数据存储与索引放在一起，索引结构的叶子节点保存行数据</td><td align="center">必须有，而且只有一个</td></tr><tr><td align="center">二级索引（Secondary Index）</td><td align="center">将数据与索引分开存储，索引结构的叶子节点保存行数据对应的主键</td><td align="center">可以存在多个</td></tr></tbody></table><h4 id="聚集索引选择规则"><a href="#聚集索引选择规则" class="headerlink" title="聚集索引选择规则"></a>聚集索引选择规则</h4><blockquote><ul><li>如果存在主键，<strong>主键索引</strong>就是聚集索引</li><li>如果不存在主键，将使用第一个<strong>唯一索引</strong>（UNIQUE）作为聚集索引</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会<strong>自动生成</strong>一个<strong>rowid</strong>作为隐藏的聚集索引</li></ul></blockquote><h4 id="聚集索引和二级索引的结构实例"><a href="#聚集索引和二级索引的结构实例" class="headerlink" title="聚集索引和二级索引的结构实例"></a>聚集索引和二级索引的结构实例</h4><p><img src="https://s2.loli.net/2022/11/11/2EA1JZHkPIQingS.png" alt="image-20221111172107291"></p><blockquote><p>查询过程：select * from user where name = xxx</p><ul><li>由于根据name自动进行查询，所以先根据name字段的二级索引中进行匹配查找，在二级索引中查找到数据对应的主键值</li><li>根据主键值到聚集索引中查找主键值对应的记录即具体数据。</li></ul></blockquote><p><img src="https://s2.loli.net/2022/11/11/L61AuMviG3RblTj.webp" alt="image"></p><blockquote><p>回表查询：先到二级索引中查找数据对应的主键值，再到聚集索引中根据主键值获取具体数据的方式</p></blockquote><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h5 id="执行效率对比"><a href="#执行效率对比" class="headerlink" title="执行效率对比"></a>执行效率对比</h5><p><img src="https://s2.loli.net/2022/11/12/dLUAiBhsocTI2jY.png" alt="image-20221112024931232"></p><h5 id="InnoDB主键索引的B-Tree高度"><a href="#InnoDB主键索引的B-Tree高度" class="headerlink" title="InnoDB主键索引的B+Tree高度"></a>InnoDB主键索引的B+Tree高度</h5><p><img src="https://s2.loli.net/2022/11/12/e1chRGzfTwr4bLj.png" alt="image-20221112025418898"></p><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT] INDEX index_name <span class="keyword">ON</span> table_name(index_col_name,...)</span><br></pre></td></tr></table></figure><blockquote><p>index_col_name：索引关联字段（一个：单列索引 多个：关联索引或组合索引）</p></blockquote><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="查看索引-1"><a href="#查看索引-1" class="headerlink" title="查看索引"></a>查看索引</h5><p><img src="https://s2.loli.net/2022/11/12/PTiHQA1rWa94UYy.png" alt="image-20221112235204914"></p><p><img src="https://s2.loli.net/2022/11/12/9WfzpLsROIjx46E.png" alt="image-20221112225037346"></p><h5 id="创建普通索引"><a href="#创建普通索引" class="headerlink" title="创建普通索引"></a>创建普通索引</h5><p><img src="https://s2.loli.net/2022/11/13/gRNhEwJBC4bTWpY.png" alt="image-20221113015135770"></p><h5 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h5><p><img src="https://s2.loli.net/2022/11/13/SnPGuoLmENaxZpk.png" alt="image-20221113020511974"></p><h5 id="创建联合索引"><a href="#创建联合索引" class="headerlink" title="创建联合索引"></a>创建联合索引</h5><p><img src="https://s2.loli.net/2022/11/13/qMEVI6xlynCpwka.png" alt="image-20221113020814460"></p><p><img src="https://s2.loli.net/2022/11/13/OGRfq18C4MAaYnr.png" alt="image-20221113021129931"></p><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><h4 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h4><blockquote><p>通过SHOW [SESSION|GLOBAL] status命令可以提供服务器状态信息</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session：当前会话</span></span><br><span class="line"><span class="comment">-- global：全局数据</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;XXX&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="查询执行频次"><a href="#查询执行频次" class="headerlink" title="查询执行频次"></a>查询执行频次</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前数据库INSERT、UPDATE、DELETE、SELECT的全局访问频次</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"><span class="comment">-- Com_select：查询频次</span></span><br><span class="line"><span class="comment">-- Com_insert：新增频次</span></span><br><span class="line"><span class="comment">-- Com_update：修改频次</span></span><br><span class="line"><span class="comment">-- Com_delete：删除频次</span></span><br></pre></td></tr></table></figure><blockquote><p>通过上面的指令，可以查看当前数据库INSERT、UPDATE、DELETE、SELECT的全局访问频次，进而了解当前数据库是以查询为主还是以修改为主，从而为数据库的优化提供参考依据即如果以查询为主，我们可以考虑对数据库的索引进行优化。</p></blockquote><p><img src="https://s2.loli.net/2022/11/13/3n1CjHiIRJNDcv7.png" alt="image-20221113023744148"></p><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>如果当前数据库以查询为主，我们可以借助慢查询日志定位需要优化的查询语句</p><blockquote><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认：10秒）的所有SQL语句</p></blockquote><blockquote><p>慢查询日志默认没有开启，通过如下语句可以查看系统变量 slow_query_log</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/13/5NSHpDlhsBW6CvO.png" alt="image-20221113030051114"></p><p><img src="https://s2.loli.net/2022/11/13/NCwPzTQyDiH8F1B.png" alt="image-20221113030519615"></p><h5 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/mysql/my.cnf &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line"># 开启MySQL慢查询日志</span><br><span class="line">slow_query_log=1</span><br><span class="line"></span><br><span class="line"># 设置慢日志的时间为2秒</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/13/vgT1LRHcEFBJurO.png" alt="image-20221113070106913"></p><h5 id="重启MySQL服务"><a href="#重启MySQL服务" class="headerlink" title="重启MySQL服务"></a>重启MySQL服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><h5 id="查看慢查询日志状态"><a href="#查看慢查询日志状态" class="headerlink" title="查看慢查询日志状态"></a>查看慢查询日志状态</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/13/i6SnCEq5ZAWtyb1.png" alt="image-20221113072343747"></p><p><img src="https://s2.loli.net/2022/11/13/ZMSvnqfIFEN1Uko.png" alt="image-20221113072525365"></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM sys_user;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/13/tKjfT6lNespW4qo.png" alt="image-20221113073044559"></p><p>通过慢查询日志，可以定位到执行效率较低的SQL语句，从而针对性的进行优化。</p><h4 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h4><blockquote><p>通过show_profiles能够在SQL执行的各个过程时间消耗情况</p></blockquote><h5 id="查看MySQL是否支持profile"><a href="#查看MySQL是否支持profile" class="headerlink" title="查看MySQL是否支持profile"></a>查看MySQL是否支持profile</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@having</span>_profiling;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/14/QEXpVtPlfw9YcCe.png" alt="image-20221114095226425"></p><h5 id="开启profiling操作"><a href="#开启profiling操作" class="headerlink" title="开启profiling操作"></a>开启profiling操作</h5><blockquote><p>默认profiling是关闭的，通过set语句在session/global级别开启profiling</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET profiling = 1;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/14/2Mrad4pmtbf1EYq.png" alt="image-20221114095326308"></p><h5 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看<span class="keyword">SQL</span>语句耗时基本情况</span><br><span class="line"><span class="keyword">SHOW</span> profiles;</span><br><span class="line"></span><br><span class="line"># 查看指定query_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况</span><br><span class="line"><span class="keyword">SHOW</span> profile <span class="keyword">FOR</span> query query_id</span><br><span class="line"></span><br><span class="line"># 查看指定query_id的<span class="keyword">SQL</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">SHOW</span> profile CPU <span class="keyword">for</span> query query_id</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/14/jWFA2NZn7Jp81Lm.png" alt="image-20221114100326625"></p><p><img src="https://s2.loli.net/2022/11/14/q76BJKzivhrPTGx.png" alt="image-20221114101045847"></p><p><img src="https://s2.loli.net/2022/11/14/RMLVys6w2pazQcf.png" alt="image-20221114101232401"></p><h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><blockquote><p>通过EXPLAIN或者DECS指令可以获取MySQL执行SELECT语句的信息，包括执行过程中表如何连接、连接的顺序以及索引的使用，它可以帮助分析SQL问题，从而更好的使用索引以及优化查询语句。</p></blockquote><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句前加上关键字EXPLAIN<span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><blockquote><p>MySQL在执行一条查询之前会分析SQL语句，决定是否使用索引或全表扫描。使用EXPLAIN命令MySQL不会执行查询操作，经过SQL分析器分析后停止执行。</p></blockquote><p><img src="https://s2.loli.net/2022/11/14/AaYq89kluK3TVby.png" alt="image-20221114172254265"></p><p>EXPLAIN执行计划中各个字段的含义</p><table><thead><tr><th>字段</th><th align="left">含义</th></tr></thead><tbody><tr><td>id</td><td align="left">select 查询的序列号，表示查询中执行select子句或者是操作表的顺序（id不同，值越大先执行；id相同，执行顺序从上往下）</td></tr><tr><td>select_type</td><td align="left">select的类型，常见的取值有SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（联合查询，即第二个或者后面的查询）、SUBQUERY（子查询）</td></tr><tr><td>type</td><td align="left">连接类型，性能由好到差的连接类型为<strong>null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong>（一般来说，得保证查询至少达到range级别,最好能达到ref）</td></tr><tr><td>possible_key</td><td align="left">显示可能应用在查询语句中的索引</td></tr><tr><td>key</td><td align="left">实际使用到的索引，如果为null，则没有使用索引，如果为primary，则使用主键</td></tr><tr><td>key_len</td><td align="left">最长的索引宽度，表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际长度。如果键是NULL，长度就是NULL。在不损失精确性的情况下，长度越短越好</td></tr><tr><td>ref</td><td align="left">显示哪个字段或常数与key一起被使用</td></tr><tr><td>rows</td><td align="left">这个数表示mysql必须执行查询的行数，在innodb引擎的表中，是一个估计值</td></tr><tr><td>filtered</td><td align="left">表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</td></tr></tbody></table><h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><h4 id="验证索引效率"><a href="#验证索引效率" class="headerlink" title="验证索引效率"></a>验证索引效率</h4><p>字段建立索引后，查询效率大大提升，验证了通过索引可以提升数据的查询性能。</p><p><img src="https://s2.loli.net/2022/11/15/SDEHA49QNTxhzIy.png" alt="image-20221115110137850"></p><p><img src="https://s2.loli.net/2022/11/15/fgpxmZHV6aUSMGw.png" alt="image-20221115110815633"></p><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><blockquote><p>如果索引关联多列即联合索引，需要遵守最左前缀法则。</p><p>最左前缀法则指的是查询需要从索引的最左列开始，并且不跳过索引中的列。如果跳出了索引的每一列，索引将部分失效（即后面的字段索引失效）。</p></blockquote><p><img src="https://s2.loli.net/2022/11/15/2jdfiapsu7QmCY3.png" alt="image-20221115132024837"></p><h5 id="等值匹配查询"><a href="#等值匹配查询" class="headerlink" title="等值匹配查询"></a>等值匹配查询</h5><p>在表中有一个联合索引关联了三个字段：brand_id，product_category_id，feight_template_id</p><blockquote><p>对于最左前缀法则而言，查询时最左边的列必须存在，否则索引全部失效。如果中间不能跳过某一列，该列后面的字段索引将失效。</p></blockquote><p><img src="https://s2.loli.net/2022/11/15/pfzcYwdDu4mrljT.png" alt="image-20221115133143692"></p><p><img src="https://s2.loli.net/2022/11/15/FPdzbs71mQTeEhA.png" alt="image-20221115133203477"></p><blockquote><p> 如果查询条件的字段是全部存在但是，索引依旧完全满足最左前缀法则。所以最左前缀法则中指的是最左边的列，是指查询时，联合索引的最左边的字段必须存在，这与查询语句的先后顺序无关。</p></blockquote><h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><blockquote><p>联合索引中，出现范围查询（&gt;或&lt;），范围查询右侧的列索引失效。</p></blockquote><p><img src="https://s2.loli.net/2022/11/15/wThAukyMSiPRgrN.png" alt="image-20221115134205026"></p><blockquote><p>当范围查询使用&gt;=或&lt;=时，所有字段都走了索引。</p></blockquote><blockquote><p>在业务允许的情况下，尽可能的使用类似于&gt;=或&lt;=这类范围查询，而避免使用&gt;或&lt;</p></blockquote><h4 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h4><h5 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h5><blockquote><p>如果在索引列上进行运算操作，索引将失效</p></blockquote><p>当根据索引字段进行等值匹配查询时，索引生效。</p><p><img src="https://s2.loli.net/2022/11/15/w9PTOtzhBckCsva.png" alt="image-20221115140011040"></p><p>当根据索引字段进行函数运算操作后，索引失效。</p><p><img src="https://s2.loli.net/2022/11/15/6MzXYpFocWKsRlB.png" alt="image-20221115140308874"></p><h5 id="索引列查询隐式转换"><a href="#索引列查询隐式转换" class="headerlink" title="索引列查询隐式转换"></a>索引列查询隐式转换</h5><blockquote><p>索引列查询时隐式转换，会导致索引失效。</p><p>常见的是字符串类型字段使用时，不加引号，索引将失效。</p></blockquote><p><img src="https://s2.loli.net/2022/11/15/V9kcNHofZeOpSsi.png" alt="image-20221115143412436"></p><blockquote><p>隐式转换：当两边的操作数类型不一致时，MySQL会发生类型转换以使操作兼容，这些操作是隐式的。</p></blockquote><p>在字符串和数字操作数进行比较时，将其作为浮点数的比较，两边都是浮点数没有使用索引的原因是执行查询时，MySQL会使用CAST函数把每一行主键列的值转换为浮点数，再与条件参数做比较，在InnoDB存储引擎中，在索引列上使用函数会导致索引失效，导致全表扫描。</p><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><blockquote><p>如果是尾部模糊匹配，索引不会失效</p><p>如果是头部模糊匹配，索引会失效</p></blockquote><p><img src="https://s2.loli.net/2022/11/15/aTMY2VCFptxmuL5.png" alt="image-20221115152448370"></p><p>在like模糊查询中，在关键字后面加%，索引可以生效，在关键字前面加%，索引将失效。</p><h5 id="or连接条件"><a href="#or连接条件" class="headerlink" title="or连接条件"></a>or连接条件</h5><blockquote><p>查询条件用or分开，如果or前后有任一没有索引，涉及的索引都不会被用到</p></blockquote><p><img src="https://s2.loli.net/2022/11/15/R4rgUXVCqJM1Ef3.png" alt="image-20221115160237189"></p><blockquote><p>当or连接的条件，左右两边字段都有索引时，索引才会生效</p></blockquote><h5 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h5><blockquote><p>如果MySQL分析评估使用索引比全表查询更慢，则不使用索引</p></blockquote><p><img src="https://s2.loli.net/2022/11/15/hZasvPJ21wXRlyo.png" alt="image-20221115161320096"></p><blockquote><p>因为MySQL在查询时会评估使用索引的效率与全表扫描的效率，如果全表扫描更快，放弃索引，使用全表扫描。因为索引的作用是检索少量数据的，如果通过索引查询返回大量的数据，则不如全表扫描，此时索引失效。</p></blockquote><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p><img src="https://s2.loli.net/2022/11/15/IvnQAJbUsCTNhjE.png" alt="image-20221115164422614"></p><p>上图中，查询语句中右两个索引可能被用到分别是组合索引和单列索引，MySQL会自动在其中选择一个。</p><blockquote><p>我们可以用过SQL提示的方式指定使用的索引。</p><p>SQL提示是优化数据库的一个重要手段，它是在SQL语句中加入一些提示来达到优化操作的目的。</p></blockquote><h5 id="use-index"><a href="#use-index" class="headerlink" title="use index"></a>use index</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 USE INDEX <span class="keyword">WHERE</span> 查询条件</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/15/d3DVMpaBmgwXAzk.png" alt="image-20221115165644150"></p><h5 id="ignore-index"><a href="#ignore-index" class="headerlink" title="ignore index"></a>ignore index</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 IGNORE INDEX <span class="keyword">WHERE</span> 查询条件</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/15/amoHZqWzfRYckVF.png" alt="image-20221115165656341"></p><h5 id="force-index"><a href="#force-index" class="headerlink" title="force index"></a>force index</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 FORCE INDEX <span class="keyword">WHERE</span> 查询条件</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/15/oWk1hgrCe7YiJSd.png" alt="image-20221115165708208"></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote><p>覆盖索引：查询使用索引并在该索引中已经全部能够找到需要返回的列</p><p>尽量使用覆盖索引，减少select *。</p></blockquote><p><img src="https://s2.loli.net/2022/11/16/VT1jvHsxliuROXN.png" alt="image-20221116115801508"></p><p><img src="https://s2.loli.net/2022/11/16/HPCkmzX9RgZxrQJ.png" alt="image-20221116115929492"></p><p>关注Extra的值有所不同，分别是Using index和Using index condition</p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using index</td><td>查找使用了索引，但是需要的数据都在索引列中可以找到，不需要回表查询</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><blockquote><p>联合索引关联了多个字段的信息，叶子节点存储了对应一行数据的id信息，当查询返回的数据在主键id和关联字段之中的时候，则直接走二级索引直接返回数据。如果超过了这个范围，就需要通过主键id去扫描聚集索引，再获取额外的数据即回表查询。依此一直使用select * 查询返回所有字段，很容易造车回表查询（除非根据主键id查询）</p></blockquote><h5 id="表结构以及索引示意图"><a href="#表结构以及索引示意图" class="headerlink" title="表结构以及索引示意图"></a>表结构以及索引示意图</h5><blockquote><p>id是主键即一个聚集索引，name是一个普通索引即一个二级索引（辅助索引）</p></blockquote><p>根据id查询直接通过聚集索引查询，一次索引扫描，直接返回数据，性能高</p><p><img src="https://s2.loli.net/2022/11/16/vxTzHykgAwZc1EB.png" alt="image-20221116123241040"></p><p>通过二级索引根据name字段查询，由于查询返回的字段为id，name，分别是索引字段和主键id，这两个字段都可以直接获取到，这就是覆盖索引，不需要回表查询，性能高<img src="https://s2.loli.net/2022/11/16/jmuxikhv2TrzRNW.webp" alt="image"></p><p>当查询的返回字段在二级索引中不包含时，需要进行二次索引扫描，也就是需要回表查询，性能相对较差一点</p><p><img src="https://s2.loli.net/2022/11/16/PfdlN4tcVX63LKY.webp" alt="image"></p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><blockquote><p>当索引的字段类型为字符串（varchar,text.longtext等）时，索引变得很大，浪费大量的磁盘IO，影响查询效率。</p><p>前缀索引可以将字符串的一部分前缀建立索引，大大节约索引空间，提高索引的效率</p></blockquote><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX 索引名 <span class="keyword">ON</span> 表名(字段名(n))</span><br></pre></td></tr></table></figure><h5 id="前缀长度"><a href="#前缀长度" class="headerlink" title="前缀长度"></a>前缀长度</h5><blockquote><p>前缀长度可以根据索引的选择性决定，而索引选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引的选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能最好</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> 表字段)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="built_in">substring</span>(表字段, <span class="number">1</span>, n))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(brand_story, <span class="number">1</span>, <span class="number">18</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pms_brand;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/16/wsN86DluHxBGWho.png" alt="image-20221116125427288"></p><h5 id="前缀索引的查询流程"><a href="#前缀索引的查询流程" class="headerlink" title="前缀索引的查询流程"></a>前缀索引的查询流程</h5><p><img src="https://s2.loli.net/2022/11/16/dDB5JV4gchKHbU3.webp" alt="image"></p><h4 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h4><blockquote><p>单列索引：一个索引包含单个列</p><p>联合索引：一个索引包含多个列</p></blockquote><p>使用了单列索引，查询会回表查询</p><p><img src="https://s2.loli.net/2022/11/16/2aS3sInDOdbzYRk.png" alt="image-20221116133247099"></p><p>创建一个联合索引</p><p><img src="https://s2.loli.net/2022/11/16/al1WFSb9Mvyz5UT.png" alt="image-20221116133456521"></p><p>指定使用联合索引，无需回表查询</p><p><img src="https://s2.loli.net/2022/11/16/DEJxLcQu42aMVvq.png" alt="image-20221116133710870"></p><blockquote><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议使用联合索引，而非单列索引。</p></blockquote><p>通过联合索引的查询的流程示意图（无需回表查询）</p><p><img src="https://s2.loli.net/2022/11/16/wzcnjBVAZf1TDPY.webp" alt="image"></p><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p><img src="https://s2.loli.net/2022/11/16/VDdMLmjRAsbIBOX.png" alt="image-20221116151825340"></p><ul><li>针对于数据量较大而且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果时字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时联合索引一些时候可以覆盖索引，节省存储空间，避免回表</li><li>控制索引的数量，索引并不是越多越好，索引越多，维护索引结构的代价越大，会影响增删改查的效率</li><li>如果索引列不能存储NULL值，在创建表时需要对该列使用NOT NULL进行约束。优化器判断每列是否包含NULL值，可以更好地确定哪个索引最有效地用于查询</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://s2.loli.net/2022/11/16/ZbljT6ArQzWd48v.png" alt="image-20221116154929970"></p><p><img src="https://s2.loli.net/2022/11/16/AhUiX8R7SoWqsmg.png" alt="image-20221116155327250"></p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="大量输入插入"><a href="#大量输入插入" class="headerlink" title="大量输入插入"></a>大量输入插入</h4><p>如果我们需要往数据库一次性插入多条记录，可以有三个方面的优化</p><ul><li>批量插入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (字段值,...),(字段值,...),(字段值,...);</span><br></pre></td></tr></table></figure><ul><li>手动提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (字段值,...),(字段值,...),(字段值,...);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (字段值,...),(字段值,...),(字段值,...);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (字段值,...),(字段值,...),(字段值,...);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ul><li>主键顺序插入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主键顺序插入：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">21</span> <span class="number">88</span> <span class="number">89</span></span><br></pre></td></tr></table></figure><h4 id="大批量数据插入"><a href="#大批量数据插入" class="headerlink" title="大批量数据插入"></a>大批量数据插入</h4><p>如果一次性需要插入大批量数据，使用insert语句插入性能比较低，可以使用MySQL提供的load指令进行插入。</p><p><img src="https://s2.loli.net/2022/11/16/S3DJHh1Ffj8Nz7T.png" alt="image-20221116225202392"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端，加上参数 --local-infile</span><br><span class="line">mysql --local-infile -uroot -p</span><br><span class="line"># 设置全局参数local_infile=1,开启从本地加载文件导入数据的开关</span><br><span class="line">SET global local_infile = 1;</span><br><span class="line"># 查看本地加载文件导入数据开关是否开启</span><br><span class="line">SELECT @@local_infile;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/16/oVqt8dkZysLcx32.png" alt="image-20221116225436102"></p><p><img src="https://s2.loli.net/2022/11/16/dc5IK1HJfWt4mEg.png" alt="image-20221116231242547"></p><p>执行如下指令，将数据脚本文件中的数据加载到表结构中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/文件名.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> 表名 fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>主键顺序插入性能插入高于乱序插入</p></blockquote><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><h4 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h4><p>在InnoDB存储引擎中，<strong>表数据</strong>是<strong>根据主键顺序组织存放</strong>的，这种存储方式的表称为索引组织表（Index Organized table IOT）。</p><p>行数据都是存储在聚集索引的叶子节点上。</p><p><img src="https://s2.loli.net/2022/11/16/ISkBGiwt8nzVRWu.png" alt="image-20221116232247103"></p><p><img src="https://s2.loli.net/2022/11/24/6qx4Dg8AmJENjM1.webp" alt="image"></p><p>页（Page）是InnoDB磁盘管理的最小单元，行数据是记录在逻辑结构Page页中，每一个页的大小是固定的，默认16k。这意味着一个页中所存储的行是有限的，如果插入数据行row在该页存储不下，将会存储到下一页中，页与页之间会通过指针连接。</p><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><blockquote><p>每页中包含了2-N行数据（如果一行数据过大会出现行溢出）。</p></blockquote><h5 id="主键顺序插入"><a href="#主键顺序插入" class="headerlink" title="主键顺序插入"></a>主键顺序插入</h5><p><img src="https://s2.loli.net/2022/11/24/mKMH1O43IjwFVsZ.png" alt="image-20221124141557766"></p><h5 id="主键乱序插入"><a href="#主键乱序插入" class="headerlink" title="主键乱序插入"></a>主键乱序插入</h5><p><img src="https://s2.loli.net/2022/11/24/bREgwy8NdzvkWPq.png" alt="image-20221124141759198"></p><p><img src="https://s2.loli.net/2022/11/24/WBDwqhEMAC4zkvG.png" alt="image-20221124141737202"></p><h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><blockquote><p>删除一行记录时，记录实际上并没有被物理删除，只是被标记（flaged）为删除状态并且它的空间允许被其他记录声明使用。</p><p>当页中删除记录达到MERGE_THRESHOLD（默认为页的50%），InnoDB会寻找最靠近页（前或后）看是否可以将两个页合并以优化空间使用。</p></blockquote><p><img src="https://s2.loli.net/2022/11/24/LCKM9JzUhdxGPDj.png" alt="image-20221124142054720"></p><p><img src="https://s2.loli.net/2022/11/24/n1F9wBZQ8WHqeXo.png" alt="image-20221124142126356"></p><blockquote><p>MERGE_THRESHOLD：合并页的阈值可以自己设置，在创建表或者在创建索引时指定。</p></blockquote><h4 id="索引设计原则-1"><a href="#索引设计原则-1" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><ul><li>在满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键，防止过多的页分裂现象</li><li>尽量不要使用uuid或者其他自然做主键</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><h4 id="MySQL排序的两种方式"><a href="#MySQL排序的两种方式" class="headerlink" title="MySQL排序的两种方式"></a>MySQL排序的两种方式</h4><ul><li>Using filesort：通过表单索引和全表扫描，读取满足条件的数据行，然后在<strong>排序缓冲区sort buffer</strong>中完成排序操作。所有不是通过索引直接返回排序结构的排序结果的排序都是FileSort排序。</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，不需额外排序，操作效率高。</li></ul><blockquote><p>Using index性能高，Using filesort性能低，在优化排序操作时，尽量要优化为Using index。</p></blockquote><p>由于排序字段没有建立索引，排序出现了Using firesort，性能较低。</p><p><img src="https://s2.loli.net/2022/11/24/eZVtLrOf7FRxmyb.png" alt="image-20221124165542137"></p><h5 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h5><p><img src="https://s2.loli.net/2022/11/24/w73dfCYRXtoskmj.png" alt="image-20221124170426753"></p><h5 id="倒叙排序"><a href="#倒叙排序" class="headerlink" title="倒叙排序"></a>倒叙排序</h5><p><img src="https://s2.loli.net/2022/11/24/Dz8AufiBvsKCk7x.png" alt="image-20221124170618939"></p><p>Extra中出现Backward index scan，代表反向索引。</p><p>MySQL中我们创建的索引默认索引的叶子节点是从小到大排序的，此时查询时从大到小，因此扫描时反向扫描，会出现Backward index scan。</p><p>在MySQL8版本中，支持降序索引，可以创建降序索引。</p><h5 id="一个升序和一个降序"><a href="#一个升序和一个降序" class="headerlink" title="一个升序和一个降序"></a>一个升序和一个降序</h5><p><img src="https://s2.loli.net/2022/11/24/JlaFIzOcGePR25g.png" alt="image-20221124232121276"></p><p>创建索引时，未指定顺序，默认按照升序排序</p><p><img src="https://s2.loli.net/2022/11/24/msaWOkFb534gpx9.png" alt="image-20221124232428591"></p><p><img src="https://s2.loli.net/2022/11/24/xc5f6lAmRLa4rzn.png" alt="image-20221124232712210"></p><p><img src="https://s2.loli.net/2022/11/24/sl6Ahr9OFmyXNib.png" alt="image-20221124232803104"></p><h5 id="升序-降序联合索引结构示意图"><a href="#升序-降序联合索引结构示意图" class="headerlink" title="升序/降序联合索引结构示意图"></a>升序/降序联合索引结构示意图</h5><p><img src="https://s2.loli.net/2022/11/24/FsKIoGpyzbJt2Tq.png" alt="image-20221124233111857"></p><p>值得注意的是，联合索引排序时，只支持覆盖索引，如果不是覆盖索引，需要回表查询数据，在排序缓冲区中对数据进行排序</p><p><img src="https://s2.loli.net/2022/11/24/CHQJcrTL8Np1deS.png" alt="image-20221124233452371"></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2022/11/24/ovCHQsAzlxJiGSw.png" alt="image-20221124234020342"></p><ul><li>根据排序字段建立合适的索引，多字段排序时，要遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，升序和降序混合要注意联合索引在创建时的规则（asc/desc）</li><li>如果大数据排序不可避免的出现filesort，可以适当增加排序缓冲区大小sort_buffer_size（默认256kb-如果超出缓冲区将到磁盘文件进行排序）</li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p>没有索引的情况下，出现 <code>Using temporary</code></p><p><img src="https://s2.loli.net/2022/11/25/3RxaZNeYmEzSsFG.png" alt="image-20221125012542346"></p><p>创建索引的情况下，出现<code>Using index</code></p><p><img src="https://s2.loli.net/2022/11/25/ibf3maWnI15F9Zh.png" alt="image-20221125012715904"></p><p>不符合最左前缀法则，出现了<code>Using temporary </code></p><p><img src="https://s2.loli.net/2022/11/26/vepozfdjqQ586Bc.png" alt="image-20221126010824433"></p><p><img src="https://s2.loli.net/2022/11/25/kEijzqKDHY3bplh.png" alt="image-20221125014244222"></p><p><img src="https://s2.loli.net/2022/11/25/IqhDNHOjQbE1zLY.png" alt="image-20221125014334850"></p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li><p>在分组操作时，可以通过索引提高效率</p></li><li><p>分组操作时，索引的使用满足最左前缀法则</p></li></ul><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p><img src="https://s2.loli.net/2022/11/26/nIfG87kuVvAyoir.png" alt="image-20221126012011290"></p><p>在数据量较大时，使用limit进行分页操作，偏移量越大，分页查询的效率越低。</p><blockquote><p>因为在执行limit分页查询时，MySQL需要排序页号前面的数据，返回limit指定区间的记录，丢弃前面全部的记录，使得查询排序的代价较大。</p></blockquote><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在分页查询时，通过<strong>覆盖索引后子查询</strong>的方式进行优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pms_product a, (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> pms_product <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">1100000</span>, <span class="number">2</span>) b <span class="keyword">WHERE</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/27/2U48wVkfDZtcxba.png" alt="image-20221127010814204"></p><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p><img src="https://s2.loli.net/2022/11/27/pfYekUbDqdhlCxK.png" alt="image-20221127011121933"></p><blockquote><ul><li>MyISAM引擎把一个表的总行数存储在磁盘上，因此执行count(*)时直接返回这个数，效率比较高，但这并不支持条件搜索。</li><li>InnoDB引擎执行count(*)时需将数据一行一行读出来再累积计数。</li></ul></blockquote><h4 id="InnoDB优化"><a href="#InnoDB优化" class="headerlink" title="InnoDB优化"></a>InnoDB优化</h4><p>将表的总行数存储在内存数据库中</p><h4 id="count用法"><a href="#count用法" class="headerlink" title="count用法"></a>count用法</h4><blockquote><p>count()是一个聚合函数，对于返回结果集一行一行的判断，如果count()函数的参数不是null，累计值加1，否则不加，最后返回累计值。</p></blockquote><table><thead><tr><th align="left">count用法</th><th>含义</th></tr></thead><tbody><tr><td align="left">count(主键)</td><td>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加。</td></tr><tr><td align="left">count(字段)</td><td>没有not null约束，InnoDB引擎会遍历整张表把每一行的字段都取出来，返回给服务层，服务层判断是否围为null，不为null，计数累加。有not null约束，InnoDB引擎会遍历整张表把每一行的字段值都取出来，给服务层直接按行进行累加。</td></tr><tr><td align="left">count(1)</td><td>InnoDB引擎遍历整张表，不取值，服务层对于返回的每一行，直接按行进行累加。</td></tr><tr><td align="left">count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是做了专门的优化，不取值，服务层直接按行进行累加。</td></tr></tbody></table><blockquote><p>按照效率排序的话，count(字段) &lt; count(主键id) &lt; count(1) ~ count(<em>)，尽量使用count(</em>)</p></blockquote><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>当开启多个事务执行根据id修改一条数据时，事务提交后，行锁释放。</p><p><img src="https://s2.loli.net/2022/11/27/oqr98UQHEa5jPWb.png" alt="image-20221127174446381"></p><p><img src="https://s2.loli.net/2022/11/27/Nnp54lwkvSEOyXs.png" alt="image-20221127174501154"></p><p>当我们开启多个事务，执行没有走索引的修改语句，行锁升级了表锁，导致update语句的性能大大降低。</p><p><img src="https://s2.loli.net/2022/11/27/fglXByKokchTnxI.png" alt="image-20221127174857488"></p><p><img src="https://s2.loli.net/2022/11/27/OvZ8TMr3QCwAcnW.png" alt="image-20221127174907041"></p><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。一旦行锁升级为表锁，update语句的性能将大大降低。</p><p><img src="https://s2.loli.net/2022/11/27/IkaX8tgqLiw4QTU.png" alt="image-20221127180418427"></p><p><img src="https://s2.loli.net/2022/11/27/2kVFY8zfKynDTbr.png" alt="image-20221127180428046"></p><p>尽量根据主键/索引字段进行数据更新。</p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p> <img src="https://s2.loli.net/2022/11/27/DyVfhlI1Ajc3Fmu.png" alt="image-20221127182837967"></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>锁是计算机协调多个线程或线程并发访问某一个资源的机制。除了传统计算资源（cpu、ram、I/O）的争用之外，数据同样是一种多个用户共享的资源。锁是保证数据并发访问的一致性和有效性的一种方式，但锁冲突也是影响数据库并发访问性能的一个重要因素。</p></blockquote><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按照锁的粒度分类</p><ul><li>全局锁：每次操作锁定数据库中的所有表</li><li>表级锁：每次操作锁定整张表</li><li>行级锁：每次操作锁定行数据</li></ul><p><img src="https://s2.loli.net/2023/01/26/DbRXxyAsC6Ln2MZ.png" alt=" "></p><p>按照锁的操作分类</p><ul><li>共享锁（读锁/S锁）：当事务对数据加上读锁后，其他事务只能对该数据加上读锁，不能做任何修改操作，不能添加写锁。只能当数据上的读锁被释放后，其他事务才能对其添加写锁。共享锁主要为了支持并发的读取数据出现的，读取数据时，不允许其他事务对当前数据进行修改操作，从而避免“不可重复读”的问题</li><li>排他锁（写锁/X锁）：当事务对数据加上写锁后，其他事务既不能对该数据添加读锁，也不能对该数据添加写锁，写锁与其他锁都是互斥的。只能当前数据写锁被释放后，其他事务才能对其添加写锁或者读锁，写锁的主要是为了解决在修改数据时，不允许其他事务对当前数据进行修改和读取操作，从而有效避免“脏读”问题的产生</li></ul><p><img src="https://s2.loli.net/2023/02/08/qgNzHGMU19ciwsm.webp" alt="数据库共享锁（读锁）与排它锁（写锁）和 读写锁的实现原理_数据库"></p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><blockquote><p>全局锁是对整个数据库实例加锁，加锁之后整个实例处于只读状态，只能允许读，不允许做任何写操作，后续的DML和DDL语句以及未提交的更新操作事务等都将处于被阻塞的状态。</p></blockquote><p><img src="https://s2.loli.net/2023/01/26/baTADpQGy2dmfl5.png" alt="image-20230126235914969"></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote><p>全库的逻辑备份：对于所有的表进行锁定，获取一致性视图，保证数据的完整性。</p></blockquote><p><img src="https://s2.loli.net/2023/02/02/cwZdOCAM4NXLgtY.png" alt="image-20230202095329844"></p><p><img src="https://s2.loli.net/2023/02/01/dVhMUyg6eATF3XR.png" alt="image-20230201162612590"></p><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/01/W9IZahTV7qYGB3Q.png" alt="image-20230201163747149"></p><p><img src="https://s2.loli.net/2023/02/01/PBoxYfrwhX3Lkds.png" alt="image-20230201164940462"></p><h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h 远程服务器ip -uroot -p 表名 &gt; 下载目录/文件名.sql</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/01/iL8u7fwyKI9otY4.png" alt="image-20230201165418843"></p><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/01/TVRk3nbYDBl4fG8.png" alt="image-20230201164052055"></p><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><h5 id="全局锁问题"><a href="#全局锁问题" class="headerlink" title="全局锁问题"></a>全局锁问题</h5><ul><li>主库上备份加上全局锁，锁期间不能执行写入或者更新等操作，业务停摆</li><li>从库上备份加上全局锁，锁期间从库不能执行主库同步的二进制日志（binlog），导致主从延迟</li></ul><p><img src="https://s2.loli.net/2023/02/01/2sEnw8MNTu7dlov.png" alt="image-20230201165759764"></p><h5 id="不加锁的数据备份"><a href="#不加锁的数据备份" class="headerlink" title="不加锁的数据备份"></a>不加锁的数据备份</h5><blockquote><p>在InnoDB引擎中，可以在备份时加上参数<code>--single-transaction</code>参数来完成不加锁的一致性数据备份</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -h 远程服务器ip -uroot -p 表名 &gt; 下载目录/文件名.sql</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/01/e8RZnOMLomx3YK9.png" alt="image-20230201165808032"></p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote><p>每次操作锁住整张表。锁的粒度大，发生锁冲突的概率最高导致并发度最低。</p></blockquote><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><h6 id="表锁分类"><a href="#表锁分类" class="headerlink" title="表锁分类"></a>表锁分类</h6><ul><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ul><h6 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加锁</span></span><br><span class="line">lock tables 表名[...] read/write</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">释放锁</span></span><br><span class="line">unlock tables/客户端断开连接</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/02/mYtnsd2MwNjx5ar.png" alt="image-20230202093733927"></p><h6 id="表共享读锁"><a href="#表共享读锁" class="headerlink" title="表共享读锁"></a>表共享读锁</h6><blockquote><p>不会阻塞读操作，但会阻塞其他客户端的写</p></blockquote><p><img src="https://s2.loli.net/2023/02/02/eU2fEo1jyilQ38S.png" alt="image-20230202094035444"></p><p><img src="https://s2.loli.net/2023/02/02/L9iwOYTXcjKAhlg.png" alt="image-20230202095041293"></p><p><img src="https://s2.loli.net/2023/02/02/QWwcBgbHYsdALx6.png" alt="image-20230202095148520"></p><p><img src="https://s2.loli.net/2023/02/02/evQsNOjzn5kL9Hm.png" alt="image-20230202095221053"></p><h6 id="表共享写锁"><a href="#表共享写锁" class="headerlink" title="表共享写锁"></a>表共享写锁</h6><blockquote><p>客户端对于表加表共享写锁，就可以读也可以写，但是其他客户端不可以读也不可以写</p></blockquote><p><img src="https://s2.loli.net/2023/02/02/A1qQsreaNYKZ4TD.png" alt="image-20230202095344309"></p><p><img src="https://s2.loli.net/2023/02/02/w6NGCJ7IBpacXMh.png" alt="image-20230202095746749"></p><p><img src="https://s2.loli.net/2023/02/02/WBm27Ee8ytLYZVi.png" alt="image-20230202100231978"></p><p><img src="https://s2.loli.net/2023/02/02/evQsNOjzn5kL9Hm.png" alt="image-20230202095221053"></p><h6 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h6><blockquote><p>读锁不会阻塞其他客户端的读，但会阻塞其他客户端以及本客户端的写。写锁既会阻塞其他客户端的读，也会阻塞其他客户端的写</p></blockquote><h5 id="元数据锁-meta-data-lock-MDL"><a href="#元数据锁-meta-data-lock-MDL" class="headerlink" title="元数据锁(meta data lock, MDL)"></a>元数据锁(meta data lock, MDL)</h5><blockquote><p><code>Meta Data Lock</code>元数据锁-MDL锁，基于表的元数据加锁。</p><p>所有存储引擎的表都会存在一个.frm文件，该文件只要存储表的结构（DDL语句），而DML锁就是基于.frm文件中的元数据加锁。</p><p>在MySQL5.5版本引入了MDL锁，MDL加锁过程是系统自动控制，无需手动获取锁</p></blockquote><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><blockquote><p>更改表结构时使用，在更改表结构时自动加上DML锁，加锁后，整张表不允许其他事务任何操作。</p><p>更改表结构的操作有向一张表创建/删除一个索引、修改一个字段的名称/数据类型、增加/删除一个表字段等情况</p></blockquote><p><img src="https://s2.loli.net/2023/02/02/bTLUo38sAtjIxhN.png" alt="image-20230202110523696"></p><p><img src="https://s2.loli.net/2023/02/02/RDtwi6IsPd84CBT.png" alt="image-20230202152731571"></p><h6 id="查看元数据锁"><a href="#查看元数据锁" class="headerlink" title="查看元数据锁"></a>查看元数据锁</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT object_type, object_schema, object_name, lock_type, lock_duration FROM `performance_schema`.metadata_locks;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/02/7oHLJj5qYES1wDO.png" alt="image-20230202152634853"></p><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><blockquote><p>在执行DML添加表锁时，为了避免行锁和表锁的冲突，表锁需要检查每行数据是否加锁，InnoDB引入意向锁，使用意向锁可以减少表锁的检查</p></blockquote><p><img src="https://s2.loli.net/2023/02/02/IoTiACSmecFzQ94.png" alt="image-20230202153223271"></p><p><img src="https://s2.loli.net/2023/02/02/rAyNlRGS2MqXaPp.png" alt="image-20230202205543833"></p><blockquote><p>由<code>是否有意向锁</code>和<code>意向锁的类型</code>判断<code>表锁是否可以添加成功 </code></p></blockquote><h6 id="意向锁的类型"><a href="#意向锁的类型" class="headerlink" title="意向锁的类型"></a>意向锁的类型</h6><ul><li>意向共享锁（IS）：由语句<code>select...lock in share mode</code>添加，与表锁共享锁（read）兼容，与表锁排他锁（write）互斥</li><li>意向排他锁（IX）：由语句<code>insert</code>,<code>update</code>,<code>delete</code>,<code>select...for update</code>添加，与表锁共享锁（read）和表锁排他锁（write）都互斥，意向锁之间不会互斥</li></ul><p><img src="https://s2.loli.net/2023/02/02/Hr9qbm7MKVuSywQ.png" alt="image-20230202210319003"></p><h6 id="查看意向锁以及行锁的加锁情况"><a href="#查看意向锁以及行锁的加锁情况" class="headerlink" title="查看意向锁以及行锁的加锁情况"></a>查看意向锁以及行锁的加锁情况</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> object_schema, Object_name, index_name, lock_type, lock_mode, lock_data <span class="keyword">FROM</span> `performance_schema`.data_locks;</span><br></pre></td></tr></table></figure><h6 id="意向共享锁实例"><a href="#意向共享锁实例" class="headerlink" title="意向共享锁实例"></a>意向共享锁实例</h6><p><img src="https://s2.loli.net/2023/02/02/YpN3TDFZ9Vl8H7w.png" alt="image-20230202212240302"></p><p><img src="https://s2.loli.net/2023/02/02/iINy4LQBqOWabHF.png" alt="image-20230202212333426"></p><p><img src="https://s2.loli.net/2023/02/02/EtsX9ZPkMSqIOng.png" alt="image-20230202213550901"></p><h6 id="意向互斥锁实例"><a href="#意向互斥锁实例" class="headerlink" title="意向互斥锁实例"></a>意向互斥锁实例</h6><p><img src="https://s2.loli.net/2023/02/02/nYaVPROkKDW8XAE.png" alt="image-20230202213306317"></p><p><img src="https://s2.loli.net/2023/02/02/31vE7hkVFBHZXiq.png" alt="image-20230202213513494"></p><p><img src="https://s2.loli.net/2023/02/07/USrC9WIKnOAyj4Y.png" alt="image-20230207162410962"></p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><blockquote><p>行级锁，每次操作锁住对应的行数据。锁的粒度小，发生锁冲突的概率最小，并发度最高，应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引来组织的，行锁通过对索<code>引上的索引项</code>加锁来实现，而不是对记录加的锁</p></blockquote><h4 id="行锁的类型"><a href="#行锁的类型" class="headerlink" title="行锁的类型"></a>行锁的类型</h4><p><img src="https://s2.loli.net/2023/02/02/LPCAwDlZqxfK6yO.png" alt="image-20230202223836265"></p><ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此进行update和delete，在RC、RR隔离级别下支持</li></ul><p><img src="https://s2.loli.net/2023/02/03/Jtq6RcBCSPvr3d5.png" alt="image-20230203092213274"></p><ul><li>间隙锁（Gap Lock）：锁定索引记录的间隙（不包含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RP隔离级别下支持</li></ul><p><img src="https://s2.loli.net/2023/02/03/BTNqoKPzL8tHUGI.png" alt="image-20230203092107621"></p><ul><li><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据和数据前面的间隙，在RP隔离级别下支持</p><blockquote><p>默认情况下，InnoDB在Repeatable Read事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引的扫描，以防止幻读。</p></blockquote></li></ul><p><img src="https://s2.loli.net/2023/02/06/pGx5yQq6wJ7Cm3Z.png" alt="image-20230206172846539"></p><h4 id="行锁的分类"><a href="#行锁的分类" class="headerlink" title="行锁的分类"></a>行锁的分类</h4><ul><li>共享锁（S）：多个事务对于同一数据可以共享一把锁<code>访问数据</code>，但是，阻止其他事务获得相同数据的排它锁</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获取相同数据的共享锁和排他锁</li></ul><p><img src="https://s2.loli.net/2023/02/06/Lg7xvtODiZuA3zl.png" alt="image-20230206173017938"></p><p><img src="https://s2.loli.net/2023/02/06/XiDtRc8FoxKrZ95.png" alt="image-20230206175419269"></p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img src="https://s2.loli.net/2023/02/07/iWtqdoCZQ3p4euM.png" alt="image-20230207164027220"></p><ul><li>针对<code>唯一索引</code>进行<code>检索</code>时，对已存在的记录<code>等值匹配</code>时，会自动优化为<code>行锁</code></li><li>InnoDB的<code>行锁</code>时针对于<code>索引</code>加的锁,，不通过索引条件检索数据时，那么InnoDB将对表中的所有记录加锁，此时锁就会升级为<code>表锁</code></li></ul><p><img src="https://s2.loli.net/2023/02/07/NH8xCsVcGDhw6ZJ.png" alt="image-20230207143643657"></p><p><img src="https://s2.loli.net/2023/02/07/JHDpVQejLfF2t1R.png" alt="image-20230207145334155"></p><p><img src="https://s2.loli.net/2023/02/07/BeFq9KkQXcz5j4M.png" alt="image-20230207145855052"></p><p><img src="https://s2.loli.net/2023/02/07/htxOBm6Ln9zApJF.png" alt="image-20230207163214815"></p><blockquote><p>InnoDB行锁是通过给索引上索引项加锁来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁。</p></blockquote><h4 id="间隙锁-临键锁"><a href="#间隙锁-临键锁" class="headerlink" title="间隙锁/临键锁"></a>间隙锁/临键锁</h4><p><img src="https://s2.loli.net/2023/02/07/zHV7raUw6jTDWNi.png" alt="image-20230207164014211"></p><ul><li>针对唯一索引上的等值查询，给不存在的记录加锁时，会优化为间隙锁</li></ul><p><img src="https://s2.loli.net/2023/02/08/TXQL6emCM3tBaNg.png" alt="image-20230208094908517"></p><ul><li>针对普通索引上的等值查询，向右遍历到最后一个值不满足查询条件时，next-key-lock退化为间隙锁</li></ul><p><img src="https://s2.loli.net/2023/02/08/GtLh2YVqzsCruv4.png" alt="image-20230208100950091"></p><p><img src="https://s2.loli.net/2023/02/08/8M6kHwpqo4vtj7f.png" alt="image-20230208100101615"></p><p><img src="https://s2.loli.net/2023/02/08/9ZYEUFQbHaM6eqW.png" alt="image-20230208100853005"></p><ul><li>针对唯一索引上的范围查询，会访问到不满足条件的第一个值为止</li></ul><p><img src="https://s2.loli.net/2023/02/08/HiP5N9BOGnf2yAz.png" alt="image-20230208102540664"></p><blockquote><p>间隙锁的唯一目的时防止其他事务插入间隙造成幻读，间隙锁是非互斥锁的，间隙锁可以共存的，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p></blockquote><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>在并发访问时，解决数据访问的一致性和有效性问题。</p><p>锁按照粒度划分为全局锁、表级锁、行级锁</p></blockquote><h4 id="全局锁-1"><a href="#全局锁-1" class="headerlink" title="全局锁"></a>全局锁</h4><blockquote><p>对于整个数据库实例加锁，加锁后整个实例处于只读状态，性能较差，数据逻辑备份时使用。</p></blockquote><h4 id="表级锁-1"><a href="#表级锁-1" class="headerlink" title="表级锁"></a>表级锁</h4><blockquote><p>操作锁住整个表，锁的粒度大，发生锁冲突的概念高，常见有表锁、元数据锁（避免DML和DDL的冲突），意向锁（避免添加表锁时，全表扫描检查行锁）</p></blockquote><h4 id="行级锁-1"><a href="#行级锁-1" class="headerlink" title="行级锁"></a>行级锁</h4><blockquote><p> 操作锁住对应的行数据，锁定粒度最小，发生锁冲突的概率最低，分为行锁、临界锁、间隙锁</p></blockquote><h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><img src="https://s2.loli.net/2023/02/08/JXQLwOZvW8cy531.png" alt="image-20230208111813154"></p><blockquote><p>表空间（Tablespace）-&gt; 段（Segment）-&gt;区（Extent）-&gt;页（Page）-&gt;行（Row）</p></blockquote><p><img src="https://s2.loli.net/2023/02/08/7OGsmDCV6nJYdZX.png"></p><ul><li><p>表空间（idb文件）：一个MySQL实例可以对应多个表空间，用于存储记录、索引等数据</p></li><li><p>段：分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）。由于InnoDB是索引组织表，数据段是B+树的叶子节点，索引段时B+树的非叶子节点。段用来管理多个区（Extent）</p></li><li><p>区：表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16k，即一个区一共有64个连续的页</p></li><li><p>页：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区</p></li><li><p>行：InnoDB存储引擎数据是按行进行存放的</p><blockquote><p>行中的字段Tri_id是隐藏列，每次对某条记录进行改动时，都会将对应的事务id赋值在Trx_id</p><p>行中的字段Roll_pointer相当于一个指针，指向该记录修改前的数据。每次对某条记录进行改动时，都会将修改前的版本写在undo日志中，Roll_pointer就指向修改前的undo日志</p></blockquote></li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><blockquote><p>MySQL5.5版本开始，默认使用InnoDB存储引擎</p><p>InnoDB架构中分为内存结构和磁盘结构。</p></blockquote><p><img src="https://s2.loli.net/2023/02/08/6vysL5DaFATeIlU.png" alt="image-20230208112649963"></p><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><blockquote><p>内存结构由缓存池（Buffer Pool），更改缓存区（Change Buffer）、日志缓冲区（Log Buffer）以及自适应哈希索引（Adaptive Hash Index）。  </p></blockquote><p><img src="https://s2.loli.net/2023/02/08/Y8FTmPEWbdDgt51.png" alt="image-20230208132905935"></p><ul><li><h5 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h5><p>缓冲池是主内存中的一个区域，可以缓存磁盘上经常操作的数据，在执行增删改查的操作时，先操作缓冲池中的数据（若缓冲池中没有数据，则从磁盘加载并缓存），然后在以一定频率刷新磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以页（Page）为单位，底层采用链表数据结构管理Page，根据状态，将Page分为三个类型：</p><ul><li>free page：空闲page，未被使用</li><li>clean page：被使用page，数据没有被修改过</li><li>dirty page：脏页，被使用page，数据被修改过，数据与磁盘的数据发生了不一致</li></ul></li></ul><p><img src="https://s2.loli.net/2023/02/08/MQbFKDkShTdXYw9.png" alt="image-20230208134028182"></p><ul><li><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据不存在于Buffer Pool中时，语句执行不会直接操作磁盘，而是直接将数据变更存储在更改缓冲区Change Buffer中，在之后数据被读取时，再将数据合并恢复到Buffer Pool中，再一定的频率将合并后的数据刷新到磁盘中。</p><p>Change Buffer的作用：与聚集索引不用，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引，插入和删除的效率比较慢。同样，新增和删除还有可能会影响索引树中不相邻的二级索引页。另外，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p></li></ul><p><img src="https://s2.loli.net/2023/02/08/3Z6Sxw7PhLoDagk.png" alt="image-20230208134938768"></p><ul><li><h5 id="Adaptive-Hash-index"><a href="#Adaptive-Hash-index" class="headerlink" title="Adaptive Hash index"></a>Adaptive Hash index</h5><p>自适应哈希索引，用于优化对Buffer Pool数据的查询，InnoDB存储引擎会监控对表上各种索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。自定义哈希索引无需人工干预，是系统根据情况自动完成的。</p></li></ul><p><img src="https://s2.loli.net/2023/02/08/JaEqLwBXgv6TVte.png" alt="image-20230208143643277"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看自定义哈希索引的开启状态</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%hash_index%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/08/Hq3G2EhmPUv1T6r.png" alt="image-20230208152302343"></p><ul><li><h5 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h5><p>日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log、undo log），默认大小为16MB，日志缓冲区的日志会定定期刷新到磁盘中。当一共事务需要更新、插入或删除多条数据时，日志缓冲区开源节省磁盘I/O。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 日志缓冲区大小</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_buffer_size%&#x27;</span></span><br><span class="line"># 日志刷新到磁盘时机</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%flush_log%&#x27;</span>;</span><br><span class="line">#<span class="number">0</span>:每秒将日志写入并刷新磁盘一次</span><br><span class="line">#<span class="number">1</span>:日志在每次事务提交时写入并刷新到磁盘</span><br><span class="line">#<span class="number">2</span>:日志在每次事务提交后写入,并每秒刷新到磁盘一次</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2023/02/08/xjDIM3flBUbF6VO.png" alt="image-20230208194831313"></p><p><img src="https://s2.loli.net/2023/02/08/SDfQawWO7TBm2Ct.png" alt="image-20230208194739441"></p><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="https://s2.loli.net/2023/02/09/kYjAoWHFLIf5xvz.png" alt="image-20230209092741961"></p><ul><li><h5 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h5><p>系统表空间，更改缓冲区的存储区域。如果表在系统表空间而不是每个表文件或者通用表空间中创建的，它也可能包含索引和数据。在MySQL5.X版本中包含InnoDB数据字典、undolog等文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%data_file_path%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/09/xci4ltC1jDrXU8M.png" alt="image-20230209093322748"></p></li></ul><p><img src="https://s2.loli.net/2023/02/08/CMGwrFLHsqUYhR2.png" alt="image-20230208195258668"></p><ul><li><h5 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table Tablespaces"></a>File-Per-Table Tablespaces</h5><p>独立表空间，每个表的文件表空间包含单个表InnoDB表的数据和索引以及存储在文件系统上的单个数据文件中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看独立表空间是否开启</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%file_per_table%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/09/Sf29GAWKaqsdjTN.png" alt="image-20230209094019806"></p></li><li><h5 id="General-Tablespaces"><a href="#General-Tablespaces" class="headerlink" title="General Tablespaces"></a>General Tablespaces</h5><p>通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，以指定该表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建通用表空间</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE XXX <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;file_name.idb&#x27;</span> ENGINE <span class="operator">=</span> innodb; </span><br><span class="line"># 指定表空间</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> xxx TABLESPACE XXX;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/09/IPcNUOoGmZ2FCDK.png" alt="image-20230209101910770"></p></li><li><h5 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h5><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16MB），用于存储undo log日志。 </p></li><li><h5 id="Temporary-Tablespaces"><a href="#Temporary-Tablespaces" class="headerlink" title="Temporary Tablespaces"></a>Temporary Tablespaces</h5><p>InnoDB使用会话临时表空间和全局临时表空间，存储用户创建的临时表等数据。</p></li></ul><p><img src="https://s2.loli.net/2023/02/09/16bYIerjL7ci5BA.png" alt="image-20230209102231804"></p><ul><li><h5 id="Doublewirte-Buffer-Files"><a href="#Doublewirte-Buffer-Files" class="headerlink" title="Doublewirte Buffer Files"></a>Doublewirte Buffer Files</h5><p>双写缓冲区，innoDB引擎将数据从内存结构中Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p></li><li><h5 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h5><p>重做日志，用来实现事务的持久化。该日志文件由两个部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log），前者是内存中，后者在磁盘中，当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p></li></ul><p><img src="https://s2.loli.net/2023/02/09/WpeR5wCQ7LBTVPi.png" alt="image-20230209102637183"></p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p><img src="https://s2.loli.net/2023/02/09/GOwtJYqgZXpDlCz.png" alt="image-20230209103652258"></p><blockquote><p>后台线程的作用就是将InnoDB存储引擎缓冲池的数据在合适的时机刷新到磁盘当中。</p></blockquote><p><img src="https://s2.loli.net/2023/02/09/kKBf8qLYOpGdA15.png" alt="image-20230209103544969"></p><ul><li><h4 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h4><p>核心后台线程，负责调度其他线程，将缓冲池中的数据异步刷新到磁盘中来保持数据的一致性以及脏页，合并插入缓存，undo页的回收。</p></li><li><h4 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h4><p>InnoDB存储引擎中大量使用异步AIO来处理I/O请求，极大提高数据库的性能。而IO Thread负责这些I/O请求的回调。</p><ul><li>Read thread：负责读操作</li><li>Write thread：负责写操作</li><li>Log thread：负责将日志缓冲区刷新到磁盘</li><li>Insert buffer thread：负责将写缓存区内容刷新到磁盘</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status; </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/09/un6YAqFKLBa4bEV.png" alt="image-20230209104624342"></p><p><img src="https://s2.loli.net/2023/02/09/4asXk2twP1rp35E.png" alt="image-20230209105051778"></p></li><li><h4 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h4><p>主要用于回收事务已经提交的undo log，在事务提交之后，回收不用的undo log</p></li><li><h4 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h4><p>协助Master Thread刷新脏页到磁盘的线程以减轻Master Thread的工作压力，减少阻塞</p></li></ul><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p><img src="https://s2.loli.net/2023/02/09/kUO9lwMNH7oPvAQ.png" alt="image-20230209105955708"></p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><blockquote><p>重做日志，记录的是提交时<code>数据页的物理修改</code>，是用来实现事务的<code>持久化</code></p><p>该日志文件由两个部门组成：<code>重做日志缓冲</code>（redo log buffer）以及<code>重做日志文件</code>（redo log file），前者是在内存中，后者在磁盘中。</p><p>当事务提交之后会把所有修改信息都存在该日志文件中。用于在刷新脏页到磁盘发生错误时，进行数据恢复使用。</p></blockquote><p>当客户端发起事务操作，当缓冲区没有需要修改的数据，会通过后台线程将数据从磁盘中读取出来并写入到缓冲区中，事务执行直接操作缓冲区中的数据，此时存放缓冲区的数据变成了脏页，将会以一定的频率调度后台线程将数据刷新到磁盘中，当刷新脏页数据到磁盘的过程中发生错误时，会导致事务的持久性不能被保证。而添加redo log后，将每次缓冲区数据的操作写到redo log buffer（重做日志缓冲）以记录数据页的变化，同时将redo log buffer（重做日志缓冲）以追加的方式同步到redo log file（重做日志文件）中，当刷新脏页到磁盘发生错误时，进行数据恢复。</p><p><img src="https://s2.loli.net/2023/02/09/faZv74Dq3yAJi5G.png" alt="image-20230209111841037"></p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><blockquote><p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<code>回滚</code>和<code>MVCC(即多版本并发控制)</code></p><p>undo log和redo log记录物理日志不一样，undo log是逻辑日志，这意味着当delete一条记录时，undo log中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。当执行rollback操作时，可以从undo log中的逻辑记录读取到响应的内容并进行回滚。</p></blockquote><ul><li>undo log销毁：undo log在事务执行时产生，当事务提交时，undo log日志不会被立即删除，因为这些日志可能还用于MVCC</li><li>undo log存储：undo log采用Segment段的方式进行管理和记录，存放于rollback segment回滚段中，rollback内部包含1024个undo log segment</li></ul><p><img src="https://s2.loli.net/2023/02/09/nedLAR3rP6WV98F.png" alt="image-20230209151000875"></p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><h5 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h5></li></ul><blockquote><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制，是一种并发控制的方法，实现对数据库的并发访问和事务内存。</p><p>通过维护数据的多个版本，更好的方式处理读写冲突，使得不加锁，也可以非阻塞并发读。比如快照读就是MySQL实现MVCC提供一共非阻塞读的功能。</p><p>MVCC的具体实现需要依赖于数据库记录中的三个隐式字段、undo log日志以及readView。</p></blockquote><ul><li><h5 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h5></li></ul><p>读取的是记录的最新版本，读取时保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><p>使用当前读的操作有：select…lock in share mode（共享锁），select…for update、update、insert、delete（排他锁）</p><p><img src="https://s2.loli.net/2023/06/18/QA9in4JpGtvK8fR.png" alt="image-20230618161137311"></p><p>由上图可见：当事务2执行修改操作并提交事务后，事务1读取的还是之前的数据，这是由于事务的默认隔离级别是可重复读，当使用 <code>SELECT...LOCK IN SHARE MODE</code>，<code>SELECT...FOR UPDATE</code></p><ul><li><h5 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h5></li></ul><blockquote><p>快照读：读取记录数据的可见版本，即不加锁的非阻塞读。快照读可能读到的不一定是数据的最新版本，有可能是之前的历史版本。</p><p>上面演示的事务1读取的还是历史版本的数据就是基于<code>快照读</code></p></blockquote><p>简单的select在不同的事务管理级别下的类型</p><p><code>Read Committed</code>：每次select都生成一个快照读</p><p><code>Repeatable Read</code>：开启事务后，第一个select是快照读的地方</p><p><code>Serializable</code>：快照读会退化为当前读，每次读取操作都会加锁</p><p><img src="https://s2.loli.net/2023/02/09/iUdpxKXN1T3C7Dc.png" alt="image-20230209152221266"></p><p><img src="https://s2.loli.net/2023/02/09/iLZgeN9HtBMWovh.png" alt="image-20230209174106147"></p><ul><li><h5 id="MVCC-2"><a href="#MVCC-2" class="headerlink" title="MVCC"></a>MVCC</h5></li></ul><blockquote><p><code>MVCC</code> 全称 <code>Multi-Version Concurrency Controller</code> 多版本并发控制，是指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供一个非阻塞读功能。</p><p>MVCC具体实现，依赖于数据库记录中的<strong>三个隐式字段</strong>、<strong>undo log日志</strong>，<strong>readView</strong></p></blockquote><blockquote><p><code>MVCC</code>就是为了实现读-写冲突不加锁，这个读的指的是<code>快照读</code>，而非当前读。当前读实际上是一种加上悲观锁的操作。</p></blockquote><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="记录中的隐藏字段"><a href="#记录中的隐藏字段" class="headerlink" title="记录中的隐藏字段"></a>记录中的隐藏字段</h5><ul><li>DB_TRX_ID（事务ID-6bytes）：<strong>最近修改事务ID</strong>，记录创建这条记录/最后一次修改改记录的事务ID</li><li>DB_ROLL_PTR（回滚指针-7bytes）：指向这条记录的<strong>上一个版本</strong>，用于配合undo log指向上一个版本</li><li>DB_ROW_ID（隐式主键-6bytes）：隐含的自增ID，如果数据表<strong>没有主键</strong>，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li></ul><p><img src="https://s2.loli.net/2023/02/09/VsBdqav4bNotGy8.png" alt="image-20230209174617300"></p><p><img src="https://s2.loli.net/2023/02/09/1SdAuUJX76fZl2s.png" alt="img"></p><h6 id="Ibd2sdi"><a href="#Ibd2sdi" class="headerlink" title="Ibd2sdi"></a>Ibd2sdi</h6><blockquote><p>查看 <code>ibd</code> 文件的一些数据字典信息</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi ums_member.ibd</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/18/aveTwbuCPxGHM3F.png" alt="image-20230618152151593"></p><p><img src="https://s2.loli.net/2023/06/18/mkyCpdjOVoU7GJ6.png" alt="image-20230618152252217"></p><h5 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h5><p><strong>回滚日志</strong>，为了回滚而记录的日志，<code>insert</code>、<code>update</code>、<code>delete</code> 产生便于<strong>数据回滚</strong>的日志（查询操作并不会修改任何用户记录，执行查询操作时，不需要记录相应的undo log）</p><p>当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，<strong>可以被立即删除</strong></p><p>当 update、delete 时，产生的 undo log 日志不仅在回滚时需要，在快照读时也需要，<strong>不会被立即删除</strong></p><ul><li><code>Insert undo log</code>：插入一条记录时，要将这条记录的主键值记录下来，回滚时只需要将这个主键值对应的记录删除</li><li><code>Update undo log</code>：修改一条记录时，至少要把修改这条记录前的旧值记录下来，回滚时再把这条记录更新为旧值就好</li><li><code>Delete undo log</code>：删除一条记录时，至少要把这条记录中的内容记录下来，回滚时再把由这些内容组成的记录插入表中即可</li></ul><h6 id="undo版本链"><a href="#undo版本链" class="headerlink" title="undo版本链"></a>undo版本链</h6><blockquote><p>在并发访问的情况下，<strong>不同事务</strong>或相同事务对<strong>同一条记录</strong>进行修改，会导致该记录的<strong>undo log生成一条记录版本链表</strong>，链表的头部是最新的旧记录，链表尾部是最早的旧纪录</p></blockquote><p><img src="https://s2.loli.net/2023/02/10/6tMZYFa9C2OW3fI.png" alt="image-20230210104216333"></p><h5 id="Read-View（读视图）"><a href="#Read-View（读视图）" class="headerlink" title="Read View（读视图）"></a>Read View（读视图）</h5><p><img src="https://s2.loli.net/2023/02/10/5smRkOXrfaZLHbu.png" alt="image-20230210104713952"></p><blockquote><p>Read View 就是事务进行快照读操作时生产的读视图，是<strong>快照读</strong>执行时MVCC提取数据的依据</p><p>在事务执行的快照读时，会生成数据库系统当前的一个快照，记录并维护系统当前活跃的事务（未提交的）id</p><p>当每个事务开启时，会被分配一个ID，这个ID是递增的，所以最新的事务，ID值越大</p></blockquote><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃事务的ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td><strong>预分配</strong>事务ID，当前最大事务ID+1（因为事务是依次递增）</td></tr><tr><td>creator_trx_id</td><td>Read View 创建者的事务ID</td></tr></tbody></table><h6 id="版本链数据访问规则"><a href="#版本链数据访问规则" class="headerlink" title="版本链数据访问规则"></a>版本链数据访问规则</h6><p><img src="https://s2.loli.net/2023/06/18/rlMcsD98xwvpGmU.png" alt="image-20230618211650706"></p><p><code>trx_id</code>：代表<code>当前事务ID</code></p><ul><li><code>trx_id = creator_trx_id</code>：<strong>可以</strong>访问该版本-说明数据是由<strong>当前事务</strong>更改的</li><li><code>trx_id &lt; min_trx_id</code>：<strong>可以</strong>访问该版本-说明数据<strong>已经提交</strong></li><li><code>trx_id &gt; max_trx_id</code>：不可以访问该版本-说明事务在ReadView生成后才开启</li><li><code>min_trx_id &lt;= trx_id &lt;= max_trx_id</code>： 如果<strong>trx_id不在m_ids</strong>中是可以访问该版本的，说明数据<strong>已经提交</strong></li></ul><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li><code>READ COMMITTED</code>：事务中每一次执行快照读时生成Read View</li><li> <code>REPEATABLE READ</code>：在事务中第一次执行快照读时生成Read View，后续复用该Read View</li></ul><h6 id="RC"><a href="#RC" class="headerlink" title="RC"></a>RC</h6><p>RC（<code>Read Committed-可重复读</code>）隔离级别下，在事务中每一次执行快照读时生成的ReadView</p><p><img src="https://s2.loli.net/2023/06/18/WKuf6nidHDFogta.png" alt="image-20230618224753952"></p><p><img src="https://s2.loli.net/2023/06/18/Hdx2GNMClSyAjcV.png" alt="image-20230618225145506"></p><h6 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h6><p>RR（<code>Repeatable Read</code>）隔离级别下，仅在事务中<strong>第一次执行快照读</strong>生成的 ReadVIew，后续复用该 ReadView</p><p><img src="https://s2.loli.net/2023/06/18/rPT9qLRQGEsIZth.png" alt="image-20230618225911647"></p><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p><img src="https://s2.loli.net/2023/06/18/PAIK78pqc1kGysi.png" alt="image-20230618230143880"></p><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p><img src="https://s2.loli.net/2023/06/18/DYW8e2FHbTRBVzt.png" alt="image-20230618230542048"></p><ul><li>逻辑存储结构：表空间、段、区、页、行</li><li>架构：内存结构、磁盘结构</li><li>事务原理：<ul><li>原子性-undo log </li><li>持久性-redo log </li><li>一致性-undo log 和 redo log</li><li>隔离性-锁 + MVCC</li></ul></li><li>MVCC：记录隐藏字段、undo log 版本链、readView</li></ul><h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><blockquote><p>MySQL数据库安装完成后，自带四个数据库：<code>mysql</code>、<code>information_schema</code>，<code>performance_schema</code>，<code>sys</code>。</p></blockquote><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型以及访问权限等</td></tr><tr><td>performation_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便DBA和开发人员利用performation_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><p><img src="https://s2.loli.net/2023/02/24/wCfDX6e1vQTa2IW.png" alt="image-20230224111243084"></p><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><blockquote><p>该mysql是指客户端工具，不是指mysql服务</p></blockquote><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql [options] [database]</span><br></pre></td></tr></table></figure><h5 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-u, --user = name # 指定用户名</span><br><span class="line">-p, --password[=name] # 指定密码</span><br><span class="line">-h, --host=name # 指定服务器ip或域名</span><br><span class="line">-P, --port=port # 指定连接端口</span><br><span class="line">-e, --execute=name # 执行SQL语句并退出</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/24/VuHfcwSlKqTYjdr.png" alt="image-20230224133305558"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 123456 demo -e&quot;select * from sys_file&quot;</span><br></pre></td></tr></table></figure><h4 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h4><blockquote><p>mysqladmin是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p></blockquote><p><img src="https://s2.loli.net/2023/02/24/ZrDWtlxGjbsvoaK.png" alt="image-20230224134530365"></p><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin [OPTIONS] command command....</span><br></pre></td></tr></table></figure><h5 id="选项：-1"><a href="#选项：-1" class="headerlink" title="选项："></a>选项：</h5><p><img src="https://s2.loli.net/2023/02/24/Q5DA7qyNJfVhrGI.png" alt="image-20230224141413820"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看mysql版本</span></span><br><span class="line">mysqladmin -uroot -p123456 version</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看mysql变量</span></span><br><span class="line">mysqladmin -uroot -p123456 variables</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建mysql数据库</span></span><br><span class="line">mysqladmin -uroot -p123456 create demo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除mysql数据库</span></span><br><span class="line">mysqladmin -uroot -p123456 drop demo</span><br></pre></td></tr></table></figure><h4 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h4><blockquote><p>由于服务器生成的二进制日志文件以二进制格式保存，使用mysqlbinlog日志管理工具检查这些文本的文本格式。</p></blockquote><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [options] log-files1 log-files2...</span><br></pre></td></tr></table></figure><h5 id="选项：-2"><a href="#选项：-2" class="headerlink" title="选项："></a>选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d, --database=name # 指定数据库名称，列出指定的数据库相关操作</span><br><span class="line">-o, --offset=n # 忽略日志中的前n行命令</span><br><span class="line">-r, --result-file=name # 将输出的文本格式日志输出到指定文件</span><br><span class="line">-s, --short-form # 显示简单格式，省略一些信息</span><br><span class="line">--start-datatime=date1 --stop-datetime=date1 # 指定日期间隔内的所有日志</span><br><span class="line">--start-position=pos1 --stop-position=pos2 # 指定位置间隔内的所有日志</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/vM7sozcYWLHyJFG.png" alt="image-20230227092610027"></p><p><img src="https://s2.loli.net/2023/02/27/WsQ2hnJABb6z5eT.png" alt="image-20230227093553620"></p><h4 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h4><blockquote><p>mysqlshow客户端对象查找工具，用来很快的查找存在哪些数据库、数据库中的表、表中的列或者索引。</p></blockquote><h5 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlshow [options] [db_name[table_name[col_name]]]</span><br></pre></td></tr></table></figure><h5 id="选项：-3"><a href="#选项：-3" class="headerlink" title="选项："></a>选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- count # 显示数据库及表的统计信息（数据库、表均可以不执行）</span><br><span class="line">-i # 显示指定数据库或者指定表的状态信息</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/mJIzj2hObP9N7di.png" alt="image-20230227094124129"></p><p><img src="https://s2.loli.net/2023/02/27/VskHBGEfQ3RT5b2.png" alt="image-20230227094238391"></p><p><img src="https://s2.loli.net/2023/02/27/9LqmAnRMWv2Jjwh.png" alt="image-20230227094407557"></p><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><blockquote><p>mysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表以及插入数据的SQL语句。</p></blockquote><h5 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line">mysqldump [options] --all-databases/-A</span><br></pre></td></tr></table></figure><h5 id="连接选项："><a href="#连接选项：" class="headerlink" title="连接选项："></a>连接选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-u, --user=name # 指定用户名</span><br><span class="line">-p, --password[=name] # 指定密码</span><br><span class="line">-h, --host=name # 指定服务器ip或域名</span><br><span class="line">-P, --port=# #指定连接端口</span><br></pre></td></tr></table></figure><h5 id="输出选项："><a href="#输出选项：" class="headerlink" title="输出选项："></a>输出选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--add-drop-database # 在每个数据库创建语句前加上drop database语句</span><br><span class="line">--add-drop-table # 在每个表创建语句加上drop table语句，默认开启：不开启(--skip-add-drop-table)</span><br><span class="line">-n, --no-create-db # 不包含数据库的创建语句</span><br><span class="line">-t, --no-create-info # 不包含数据表的创建语句</span><br><span class="line">-d, --no-data # 不包含数据</span><br><span class="line">-T, --tab=name # 自动生成两个文件：一个sql文件；创建表结构的语句：一个.txt文件，数据文件</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p demo &gt; demo.sql</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/Viu45qnlSsAcxTz.png" alt="image-20230227105210025"></p><h4 id="mysqlimport-source"><a href="#mysqlimport-source" class="headerlink" title="mysqlimport/source"></a>mysqlimport/source</h4><blockquote><p>mysqlimport/source是客户端数据导入工具，mysqlimport用来导入mysqldump加-T参数后导出的文本文件，source用来导入sql文件。</p></blockquote><h5 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport [options] db_name textfile1 [testfile2...]</span><br><span class="line">source /xxx/xxx.sql</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/27/J9PSmhlT2uGcpe1.png" alt="image-20230227132655279"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://s2.loli.net/2023/02/27/VdiRONWQSPXukI1.png" alt="image-20230227133433920"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL进阶篇&quot;&gt;&lt;a href=&quot;#MySQL进阶篇&quot; class=&quot;headerlink&quot; title=&quot;MySQL进阶篇&quot;&gt;&lt;/a&gt;MySQL进阶篇&lt;/h1&gt;&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ</title>
    <link href="http://example.com/2023/02/01/rocketmq/"/>
    <id>http://example.com/2023/02/01/rocketmq/</id>
    <published>2023-01-31T16:00:00.000Z</published>
    <updated>2024-03-12T02:33:33.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="RocketMQ入门"><a href="#RocketMQ入门" class="headerlink" title="RocketMQ入门"></a>RocketMQ入门</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><blockquote><p>消息队列中间件 - Message Queue 是分布式系统中重要的组建，主要解决 应用解耦、异步消息、流量削峰 等问题。</p><p>消息队列实现了高性能、高可用、可伸缩和最终一致性架构，是大型分布式系统不可缺少的中间件。</p><p>目前主流的消息队列有 RocketMQ、Kafka、RabbitMQ、ActiveMQ等。本文将主要介绍 RocketMQ</p></blockquote><h4 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h4><ul><li>异构系统之间的调用<strong>解耦</strong></li><li>基于”发布订阅”机制的<strong>数据分发</strong></li><li><strong>异步</strong>消息处理</li><li><strong>削峰限流</strong></li></ul><h4 id="消息队列选型"><a href="#消息队列选型" class="headerlink" title="消息队列选型"></a>消息队列选型</h4><p><a href="https://kafka.apache.org/">Kafka</a></p><blockquote><p><a href="https://kafka.apache.org/">Apache Kafka</a> 是一个开源流处理平台，是一个高吞吐的分布式发布订阅消息系统</p><p>使用场景：大流量应用、对消息延迟不敏感的场景</p></blockquote><p><a href="https://www.rabbitmq.com/">RabbitMQ</a></p><blockquote><p>RabbitMQ 开源的消息队列系统，实现了高级消息队列协议（AMQP）</p><p>使用场景：企业级别内部应用，数据可靠性高，对于并发和延迟不敏感的场景</p></blockquote><p><a href="https://rocketmq.apache.org/">RocketMQ</a></p><blockquote><p>Apache RocketMQ 由阿里巴巴集团贡献的开源分布式消息中间件</p><p>适用场景：低延迟应用，瞬间大流量处理效率不如kafka</p></blockquote><h3 id="RocketMQ概述"><a href="#RocketMQ概述" class="headerlink" title="RocketMQ概述"></a>RocketMQ概述</h3><blockquote><p>Apache RocketMQ 是一款分布式消息中间件系统，它最初由阿里巴巴集团开发并开源。RocketMQ 的设计目标是提供低延迟、高可用性、高吞吐量、高可靠性以及水平可扩展的消息传递服务。</p><p>Apache RocketMQ 官方文档：<a href="https://rocketmq.apache.org/zh/docs/">https://rocketmq.apache.org/zh/docs/</a></p></blockquote><h3 id="RocketMQ特性"><a href="#RocketMQ特性" class="headerlink" title="RocketMQ特性"></a>RocketMQ特性</h3><ul><li>高可用：支持集群和水平扩容，实现负载均衡和高可用</li><li>高性能：支持过亿级别的消息处理</li><li>高可靠：支持消息持久化、失败重试、消息回溯等机制，确保消息的可靠性</li><li>功能丰富：支持异步消息、同步消息、顺序消息、事务消息等功能</li></ul><h3 id="RocketMQ基本概念"><a href="#RocketMQ基本概念" class="headerlink" title="RocketMQ基本概念"></a>RocketMQ基本概念</h3><p><img src="https://s2.loli.net/2024/01/07/zM4PdkLyVpAZYSr.png" alt="生产者"></p><h4 id="生产者和生产者组"><a href="#生产者和生产者组" class="headerlink" title="生产者和生产者组"></a>生产者和生产者组</h4><blockquote><p>生产者(Producer)是 RocketMQ 系统中用来构建并传输消息到 RocketMQ服务端 的运行实体。</p><p>生产者组(ProducerGroup) 是 区分不同业务类型生产者的逻辑概念。</p></blockquote><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><blockquote><p>主题(Topic)是消息传输和存储的<strong>顶层容器</strong>，用于标识同一类业务逻辑的消息，主题通过TopicName来做唯一标识和区分。</p></blockquote><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><blockquote><p>消息(Message)是 RocketMQ 中的最小数据传输单元。每个Message都必须指定Topic，RocketMQ 服务端将消息投递到消费端进行消费。</p></blockquote><h4 id="消息标签"><a href="#消息标签" class="headerlink" title="消息标签"></a>消息标签</h4><blockquote><p>消息标签(Message Tag)是 RocketMQ 提供的细粒度消息分类属性，可以在主题层级之下做消息类型的细分。消费者通过订阅特定的标签来实现细粒度过滤。</p></blockquote><h4 id="消息位点"><a href="#消息位点" class="headerlink" title="消息位点"></a>消息位点</h4><blockquote><p>消息按照到达 RocketMQ服务端的先后顺序进行存储在指定topic的队列中，每个消息在所在队列中都有一个唯一的long类型的坐标，用于快速查找消息的位置。</p></blockquote><h4 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h4><blockquote><p>消息队列(Message Queue)是 RocketMQ 中消息存储和传输的<strong>实际容器</strong>，也是消息的最小存储单元。</p><p>RocketMQ所有主题由多个队列组成（默认4个），以此实现队列数量的水平拆分和队列内部的流式存储。队列通过QueueId来做唯一标识和区分。队列采用 FIFO - 先进先出 的模式传输，负责向消费者 Push 推送消息，或者由消费者直接 Pull 拉取消息。</p></blockquote><h4 id="消费者和消费者组"><a href="#消费者和消费者组" class="headerlink" title="消费者和消费者组"></a>消费者和消费者组</h4><blockquote><p>消费者(Consumer)是 RocketMQ 用来接收并处理消息的运行实体。消费者通常被集成在业务系统中，从服务端获取消息并进行业务逻辑处理。</p><p>消费者组(ConsumerGroup)是 RocketMQ 系统中承载多个消费行为一致的消费者的负载均衡分组的一个逻辑概念。在消费者组中初始化多个消费者实现消费性能的水平扩展以及高可用容灾。一个消费者组可以订阅多个 topic。如果一个主题的消息被多个消费者组订阅，每个消费者组都会独立地消费该消息，即每个消费都会被不同的消费者消费一遍。</p></blockquote><h4 id="消费点位"><a href="#消费点位" class="headerlink" title="消费点位"></a>消费点位</h4><blockquote><p>消费点位（ComsumeOffset）RocketMQ 会记录每个消费者组在一个特定主题（Topic）和队列（Queue）上的消费进度，是消费者组在某个队列上已经成功消费的消息的偏移量，用于快速定位该消费者组下次消费的起点地址。    </p></blockquote><h4 id="订阅关系"><a href="#订阅关系" class="headerlink" title="订阅关系"></a>订阅关系</h4><blockquote><p>订阅关系（Subscription）是 RocketMQ 定义了消费者获取消息、处理消息的规则和状态配置。</p><p>订阅关系由消费者组<strong>动态注册</strong>到 RocketMQ服务端，并在后续的消息投递过程中，RocketMQ broker按照注册上来的订阅关系进行消息过滤匹配和消费进度的维护。</p></blockquote><h3 id="RocketMQ基本工作流程"><a href="#RocketMQ基本工作流程" class="headerlink" title="RocketMQ基本工作流程"></a>RocketMQ基本工作流程</h3><img src="https://s2.loli.net/2024/01/21/VUBXf3hucvWmb5H.png" alt="image-20240121182823616" style="zoom:50%;" /><ul><li>Name Server启动，作为路由控制中心和topic的配置信息，负责维护Broker的路由信息，提供轻量级的服务注册发现和路由功能。Producer和Consumer都需要和Name Server交互来获取路由信息。</li><li>Broker和Namesrv建立连接注册信息（包括ip、端口、所存储topic信息）到namesrv，并定时（默认30秒）发送心跳包，用于健康监控（120秒没有收到用于心跳包，则broker会被namesrv剔除）。</li><li>Topic用于消息的分类，Topic是消息发布的地址，Producer将消息发送到特定的Topic，而Consumer从Topic接收消息。Topic可以手动添加，也可以在发送消息时由RocketMQ服务端自动创建（自动创建会根据配置文件中指定的默认队列数量分配相应数量的队列，并负载均衡或者其他算法分配到不同的broker节点中）。</li><li>Producer首先会从Name Server获取Broker的路由信息，然后根据路由信息将消息发送到指定的Broker中。</li><li>Consumer首先会从Name Server获取路由信息来找到对应的Topic所在的Broker中，然后从Broker订阅消息，拉取消息进行消费。</li></ul><h3 id="RocketMQ部署"><a href="#RocketMQ部署" class="headerlink" title="RocketMQ部署"></a>RocketMQ部署</h3><img src="https://s2.loli.net/2024/01/17/cHkKf72BRnxop5b.png" alt="image-20240117222521555" style="zoom:33%;" /><p>RocketMQ拓扑结构：</p><img src="https://s2.loli.net/2024/01/14/7Q3POMTD1wUkxWH.png" alt="image-20240114190733792" style="zoom:33%;" /><p>在部署中，有三个重要的组建，分别是 namesrv、broker 和 console。它们承担着不同的角色和功能</p><ul><li>namesrv：存储和管理整个RocketMQ集群中topic的路由信息，维护了一个topic到broker的映射关系。<ul><li>在producer发送消息时或者consumer消费消息时，需要向namesrv查询路由信息，以确定消息的发送或消费的broker。</li></ul></li><li>broker：RocketMQ的消息存储和消息传递的核心组件，负责存储producer发送的消息，并且将这些消息推送给consumer。</li><li>console：RocketMQ的控制台即可视化管理界面，用于监控和管理RocketMQ集群。<ul><li>通过控制台，管理者可以查看集群的运行状态，监控息的发送和消费情况，管理topic和consumer等。</li></ul></li></ul><h4 id="单节点-RocketMQ-部署"><a href="#单节点-RocketMQ-部署" class="headerlink" title="单节点 RocketMQ 部署"></a>单节点 RocketMQ 部署</h4><blockquote><p>运行前 需要设置挂载目录读写权限 </p><p>mkdir -p /mydata/rocketmq/namesrv</p><p>chmod 777 -R /mydata/rocketmq/namesrv/*</p><p>mkdir -p /mydata/rocketmq/broker</p><p>chmod 777 -R /mydata/rocketmq/broker/*</p></blockquote><p>docker-compose.yml文件如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">rocketmq_namesrv:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq_namesrv</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/rocketmq/namesrv/logs:/home/rocketmq/logs</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;sh&quot;</span>,<span class="string">&quot;mqnamesrv&quot;</span> ]</span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPT_EXT:</span> <span class="string">&quot;-Duser.home=/home/rocketmq -Xms256m -Xmx256m -Xmn128m&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">rocketmq_broker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq_broker</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq_namesrv</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;sh&quot;</span>,<span class="string">&quot;mqbroker&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;/home/rocketmq/broker.conf&quot;</span>,<span class="string">&quot;autoCreateTopicEnable=true&quot;</span> ]</span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">NAMESRV_ADDR:</span> <span class="string">&quot;rocketmq_namesrv:9876&quot;</span></span><br><span class="line">      <span class="attr">JAVA_OPT_EXT:</span> <span class="string">&quot;-Duser.home=/home/rocketmq -server -Xms128m -Xmx128m -Xmn128m&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/rocketmq/broker/logs:/home/rocketmq/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/rocketmq/broker/store:/home/rocketmq/store</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/rocketmq/broker/conf/broker.conf:/home/rocketmq/broker.conf</span> <span class="comment"># broker.conf 配置参考: https://github.com/apache/rocketmq/blob/master/distribution/conf/broker.conf</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">  <span class="attr">rocketmq_dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apacherocketmq/rocketmq-dashboard:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq-dashboard</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq_namesrv</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPTS:</span> <span class="string">&quot;-Xmx256m -Xms256m -Xmn128m -Drocketmq.namesrv.addr=rocketmq_namesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">11880</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><p>其中 broker.conf 配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称</span><br><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line"># broker 名称</span><br><span class="line">brokerName = broker-a</span><br><span class="line"># broker IP地址</span><br><span class="line">brokerIP1=xx.xxx.xxx.xxx</span><br><span class="line"># brokerId 0为master 大于0为slave</span><br><span class="line">brokerId = 0</span><br><span class="line"># 每日凌晨4点删除过期日志</span><br><span class="line">deleteWhen = 04</span><br><span class="line"># 日志文件保留时间 默认48小时</span><br><span class="line">fileReservedTime = 48</span><br><span class="line"># broker主从复制策略（默认：ASYNC_MASTER）ASYNC_MASTER-异步复制Master SYNC_MASTER-同步双写Master</span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line"># broker刷盘策略（默认：ASYNC_FLUSH）：ASYNC_MASTER-异步刷盘（性能好，但宕机可能会导致数据丢失） ASYNC_FLUSH-同步刷盘（性能差，但不会导致数据丢失）</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line"># 是否允许 broker 在当前topic不存在时自动创建 topic (线上环境设置为 false)</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"># 是否允许 broker 自动创建订阅组（线上环境设置为 false）</span><br><span class="line"># 自动创建时读写队列数量</span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"># 开启SQL属性过滤</span><br><span class="line">enablePropertyFilter=true</span><br></pre></td></tr></table></figure><h4 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># broker主从辅助策略（默认：ASYNC_MASTER）ASYNC_MASTER-异步复制Master SYNC_MASTER-同步双写Master</span><br><span class="line">brokerRole = ASYNC_MASTER</span><br></pre></td></tr></table></figure><h5 id="同步复制（默认）"><a href="#同步复制（默认）" class="headerlink" title="同步复制（默认）"></a>同步复制（默认）</h5><ul><li><p>特点：生产者发送消息，在主节点接收到消息后，必须等待所有从节点都成功写入该消息即等待从从节点完成数据同步，主节点才会响应结果给生产者</p></li><li><p>优点：数据一致性好，从节点数据与主节点完全一致，不会产生丢失数据的风险</p></li><li><p>缺点：同步阻塞，性能相对较差</p></li><li><p>应用场景：同步复制适用于强一致性要求较高，不能容忍数据丢失的场景，例如关键业务数据变更，数据安全性要求高的。</p><img src="https://s2.loli.net/2024/01/21/rCEpIeo8Bj14OXl.png" alt="image-20240121202223163" style="zoom:50%;" /></li></ul><h5 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h5><ul><li><p>特点：生产者发送消息，在主节点接收到消息后，不需要等待从节点写入成功，直接响应结果给生产者</p></li><li><p>优点：性能较好，主节点不需要等待从节点确认，可以更快地响应结果</p></li><li><p>缺点：存在一定的数据不一致性，主从节点数据可能在一段时间内存在差异</p></li><li><p>应用场景：异步复制适用于对一致性要求较低，追求吞吐量，可以容忍一定的时间内不一致和数据丢失的风险的场景</p><img src="https://s2.loli.net/2024/01/21/pluLKwaFGqbnWdR.png" alt="image-20240121152510526" style="zoom:50%;" /></li></ul><h3 id="RocketMQ-dashboard使用"><a href="#RocketMQ-dashboard使用" class="headerlink" title="RocketMQ dashboard使用"></a>RocketMQ dashboard使用</h3><img src="https://s2.loli.net/2024/01/21/qeohU8nbELvMNWK.png" alt="image-20240121135503401" style="zoom:33%;" /><h3 id="RabbitMQ高可用方案"><a href="#RabbitMQ高可用方案" class="headerlink" title="RabbitMQ高可用方案"></a>RabbitMQ高可用方案</h3><h4 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h4><p>生产使用高可用的多主多从的拓扑结构</p><img src="https://s2.loli.net/2024/01/21/FZn8ortvmzBIuyA.png" alt="image-20240121202426604" style="zoom:50%;" /><p>多个namesrv节点可以提高系统的可用性和容错性。多主多从的broker节点，主broker节点可以处理读写请求，从broker节点只能处理读请求，从节点用于备份和提高可用性。在主从broker之间，数据通过日志 commitlog 进行同步，    </p><h4 id="高可用实现"><a href="#高可用实现" class="headerlink" title="高可用实现"></a>高可用实现</h4><ul><li><p>当一个主broker-a节点挂了则停止服务，不会接受新的消息，rocketmq默认不会自动主从切换，此时生产者无法从rocketmq中消费消息，利用重试机制切换到其从节点消费消息，已经被同步到其从节点broker-slave-a的消息可以正常被消息者消费。</p><p>在同步复制的模式下，消息数据不会丢失，而在异步复制的模式下，主节点可能还有消息没有同步，可能会导致消息数据丢失的问题。</p><p>当生产者向从broker-a节点发送消息时，broker-a无法响应，生产者触发重试机制，向另一个从broker-b发送消息，从而保证高可用。</p><p>主broker-a超过120秒没有上报信息到namesrv时，namesrv将剔除主broker-a的信息。</p></li><li><p>当主从集群 broker-a 和 broker-slave-a 同时挂掉，服务无法响应读写请求，无法接受也无法消费消息，但是数据化持久化，消息不会丢失。新消息会被发到其他节点上。</p></li><li><p>当 namesrv-a节点挂掉，生产者和消费者无法获取broker的路由信息，会轮询尝试到另一个namesrv节点获取。</p></li><li><p>当 broker-a主从集群和 namesrv-a之间的网络阻塞的请求，导致 namesrv节点之间数据不一致，此时一个消费者从namesrv-a中获取路由信息，会导致broker-a主从集群产生的消息无法消费，持续挤压，解决方案只有调试网络或者动态不停机的修改消费者配置。</p></li></ul><h3 id="Java应用接入RocketMQ"><a href="#Java应用接入RocketMQ" class="headerlink" title="Java应用接入RocketMQ"></a>Java应用接入RocketMQ</h3><h4 id="引入-RocketMQ-客户端"><a href="#引入-RocketMQ-客户端" class="headerlink" title="引入 RocketMQ 客户端"></a>引入 RocketMQ 客户端</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- rocketmq --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="新建测试类发送消息"><a href="#新建测试类发送消息" class="headerlink" title="新建测试类发送消息"></a>新建测试类发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RocketMQApp.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 生产者为 producerGroup1 的 DefaultMQProducer 消息生产者对象</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">defaultMQProducer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;producerGroup1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 消息生产者对象 的 namesrv 地址 （多个节点间用分号分割）</span></span><br><span class="line">        defaultMQProducer.setNamesrvAddr(<span class="string">&quot;xx.xxx.xxx.xxx:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生产者启动，与 namesrv 建立长连接查询路由，与 topic 所处的 broker 建立长连接用于发送消息</span></span><br><span class="line">            defaultMQProducer.start();</span><br><span class="line">            <span class="comment">// 创建 message</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span> (<span class="string">&quot;simple&quot;</span>, <span class="string">&quot;hello wolrd!&quot;</span>.getBytes());</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> defaultMQProducer.send(message);</span><br><span class="line">            logger.info(<span class="string">&quot;send message：&#123;&#125;&quot;</span>, sendResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 关闭长连接</span></span><br><span class="line">                defaultMQProducer.shutdown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 防止 start 建立连接失败</span></span><br><span class="line">                logger.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testComsume</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">defaultMQPushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;comsumerGroup1&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;xx.xxx.xxx.xxx:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 消息订阅 subExpression * 表示 所有 tags</span></span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;simple&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="comment">// 注册消息的监听器 - 监听 broker 推送的消息并处理</span></span><br><span class="line">            defaultMQPushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> msgs msgs.size() &gt;= 1&lt;br&gt; DefaultMQPushConsumer.consumeMessageBatchMaxSize=1,you can modify here</span></span><br><span class="line"><span class="comment">                 *             消息批量推送 提高消息消费的吞吐量</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">                        logger.info(<span class="string">&quot;consume message：&#123;&#125;&quot;</span>, content);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 返回接收成功标识</span></span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 消费者启动，与namesrv建立长连接查询路由，与 topic 所处的 broker 建立长连接，开启监听消息的推送</span></span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="RocketMQ功能特性"><a href="#RocketMQ功能特性" class="headerlink" title="RocketMQ功能特性"></a>RocketMQ功能特性</h2><h3 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h3><blockquote><p>普通消息为 Apache RocketMQ 中最基础的消息，本章将介绍普通消息的应用场景、功能原理、使用方法和使用建议。</p></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote><p>普通消息一般应用于微服务解耦、事件驱动、数据集成等场景。这些场景要求消息的可靠性，但是对消息的处理时机、处理顺序没有特别要求。</p></blockquote><ul><li><p>异步解耦</p><p><img src="https://s2.loli.net/2024/01/07/onVuci6WHhU14Jb.png" alt="在线消息处理"></p><p>上游系统将一个一个业务事件封装成独立的普通消息并发送至 RocketMQ服务端，下游按需订阅 RocketMQ服务端 消息，拉取到消息后按照本地消费逻辑处理下游任务。</p></li><li><p>数据集成</p><p><img src="https://s2.loli.net/2024/01/07/8fOZ3vdeT7cpSFL.png" alt="数据传输"></p><p>以日志收集场景为例，日志信息转发到 RocketMQ，每条消息即是一段日志数据，RocketMQ 不用不做任何处理，将日志数据可靠的投递到下游的存储系统和分析系统等，后续由不同系统处理即可。</p></li></ul><h4 id="功能原理"><a href="#功能原理" class="headerlink" title="功能原理"></a>功能原理</h4><blockquote><p>普通消息是 rocketmq 的基本功能，支持生产者和消费者的异步解耦通信</p></blockquote><h4 id="普通消息生命周期"><a href="#普通消息生命周期" class="headerlink" title="普通消息生命周期"></a>普通消息生命周期</h4><p><img src="https://s2.loli.net/2024/01/07/ehcEBjkVlyY2SPi.png" alt="生命周期"></p><ul><li>初始化 - Initialized：消息被生产者构建并完成初始化，待发送到RocketMQ服务端的状态</li><li>待消费 - Ready：消息被发送到RocketMQ服务端，等待消费者消费的状态</li><li>消费中 - Inflight：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程<ul><li>此过程RocketMQ服务端会等待消费者完成消费并提交消费结果至RocketMQ服务端</li><li>如果一定时间后没有收到消费者响应，RocketMQ会对消息进行重试处理</li></ul></li><li>消息确认：消费者完成消费处理，并向RocketMQ服务端提交消费结果，服务端标记当前消息的处理状态（包括消费成功和失败）<ul><li>RocketMQ 默认持久化所有消息，被消费的消息不会立即删除，而是进行逻辑标记消费状态</li><li>当消息在保存时间到期或者存储空间不足被删除前，消费者支持回溯消息来重新消费</li></ul></li><li>消息删除：RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li></ul><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RocketMQApp.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// DefaultMQProducer 用于发送非事务消息</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">defaultMQProducer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;producer-group-normal&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 namesrv 地址</span></span><br><span class="line">        defaultMQProducer.setNamesrvAddr(<span class="string">&quot;xx.xxx.xxx.xxx:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 异步发送失败后重试2次 消息高可靠性的处理方式</span></span><br><span class="line">        defaultMQProducer.setRetryTimesWhenSendAsyncFailed(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生产者启动</span></span><br><span class="line">            defaultMQProducer.start();</span><br><span class="line">            <span class="comment">// 创建 message</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span> (<span class="string">&quot;simple&quot;</span>, <span class="string">&quot;default-tag&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;hello wolrd!&quot;</span>.getBytes());</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> defaultMQProducer.send(message);</span><br><span class="line">            logger.info(<span class="string">&quot;send message：&#123;&#125;&quot;</span>, sendResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 关闭长连接</span></span><br><span class="line">                defaultMQProducer.shutdown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 防止 start 建立连接失败</span></span><br><span class="line">                logger.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testComsume</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">defaultMQPushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;producer-group-normal&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;xx.xxx.xxx.xxx:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 消息订阅 subExpression * 表示 所有 tags</span></span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;simple&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="comment">// 注册消息的监听器 - 监听 broker 推送的消息并处理</span></span><br><span class="line">            defaultMQPushConsumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">                    logger.info(<span class="string">&quot;consume message：&#123;&#125;&quot;</span>, content);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回接收成功标识</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 消费者启动，与namesrv建立长连接查询路由，与 topic 所处的 broker 建立长连接，开启监听消息的推送</span></span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><p>设置全局唯一业务key，方便问题追踪和定位</p><img src="https://s2.loli.net/2024/01/25/P12gbz4TAvZOINo.png" alt="image-20240125200801026" style="zoom:50%;" /><h3 id="定时-延迟消息"><a href="#定时-延迟消息" class="headerlink" title="定时/延迟消息"></a>定时/延迟消息</h3><blockquote><p>定时/延时消息是 Apache RocketMQ 中的高级特性消息，是生产者将消息发送给broker后，broker不会立即将消息投递给具体的消费者，而是在一定的时间后或者指定的某个时间点再进行消息的投递</p><p>定时和延时的本质是一样的，服务端都是根据消息设置的定时时间<strong>在某一个固定的时刻</strong>将消息投递给消费者消费。</p></blockquote><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>定时/延迟消息可以应用于分布式定时调度、任务超时处理等场景。</p><ul><li><input disabled="" type="checkbox"> rocketmq5.x 支持任意时间的消息 怎么没有</li></ul><h4 id="功能原理-1"><a href="#功能原理-1" class="headerlink" title="功能原理"></a>功能原理</h4><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><h4 id="使用建议-1"><a href="#使用建议-1" class="headerlink" title="使用建议"></a>使用建议</h4><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>在有序事件处理，例如订单消息处理，订单需要严格按照 “订单创建-&gt;财务结算-&gt;物流消息” 等环节的顺序，以避免混乱或错误的处理。</p><p>当使用普通消息时，消息发送到不同的队列中，不同队列的消息积压或者其他因素会导致消息被投递到消费者消费的时机不同，这时就会导致消费没有按照顺序执行。</p><img src="https://s2.loli.net/2024/01/24/Eya5gzpmRikVCLG.png" alt="image-20240124132737720" style="zoom:50%;" /><h4 id="功能原理-2"><a href="#功能原理-2" class="headerlink" title="功能原理"></a>功能原理</h4><blockquote><p>顺序消息是 RocketMQ 提供的一种高级消息类型，支持消费者按照生产者发送消息的先后顺序获取消息，从而实现业务场景中的顺序处理。 </p></blockquote><ul><li><input disabled="" type="checkbox"> 分区有序消息和全局有序消息  消息组 </li></ul><h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><blockquote><p>RocketMQ的事务消息支持在分布式场景下保障<strong>消息生产</strong>和<strong>本地事务</strong>的最终一致性。</p></blockquote><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>分布式事务需要保证核心业务和多个下游业务的执行结果的完全一致。</p><img src="https://s2.loli.net/2024/01/26/2petH7PvruAVQS4.png" alt="事务消息诉求" style="zoom:50%;" /><p>基于普通消息方案，本地事务和消息的生产无法保证一致性</p><ul><li>先执行本地事务，再生产消息<ul><li>过程：执行本地事务，再生产消息，通过消息生产回执来判断消息生产的状态，成功则提交事务，失败则回滚事务</li><li>问题 - 阻塞：当出现网络问题时，消息生产回执响应太慢，保证本地事务无法提交，方法响应时间长。在大并发的场景下，数据库连接池被耗尽，大量请求积压连接池等待，请求向前积压到tomcat连接池，网关等，导致雪崩，整个系统不可用</li></ul></li><li>先生产消息：再执行本地事务：<ul><li>过程：先发送消息，消息发送成功后，再进行本地事务的执行和提交。</li><li>问题 - 回滚：当本地事务的执行失败并回滚时，则已经发送的消息需要被撤销，但普通消息无法撤销消息。</li></ul></li></ul><blockquote><p>RocketMQ 提供的分布式事务消息可以保证应用<strong>本地事务</strong>和<strong>消息生产</strong>的<strong>最终一致性</strong>。</p></blockquote><p>上述普通消息无法保证一致性的本质原因是 普通消息无法具备提交、回滚和统一协调的能力。</p><p>而基于 RocketMQ 的分布式事务消息，将 本地消息和本地事务 绑定，实现全局提交结果的一致性。</p><img src="https://s2.loli.net/2024/01/26/ISKA8jmERNlPrs2.png" alt="image-20240126091647924" style="zoom: 33%;" /><h4 id="功能原理-3"><a href="#功能原理-3" class="headerlink" title="功能原理"></a>功能原理</h4><h5 id="事务消息流程"><a href="#事务消息流程" class="headerlink" title="事务消息流程"></a>事务消息流程</h5><p><img src="https://s2.loli.net/2024/01/25/BRlL9sYAokf7CNx.png" alt="事务消息"></p><ol><li>生产者将消息发送至RocketMQ服务器</li><li>RocketMQ服务将消息持久化成功后，向生产者返回ACK确认消息已经发送成功，但是此时消息被标记为半事务消息 - half message，在这种状态下消息”暂时不能投递”</li><li>生产者收到ACK确认消息后，开始执行本地事务</li><li>生产者向RocketMQ服务器提交本地事务的执行结果（commit|rollback），RocketMQ服务器根据执行结果做出不同的处理<ul><li>当提交的本地事务执行结果为 <strong>commit</strong>，RocketMQ 服务器将消息从<strong>半事务</strong>状态标记为<strong>可投递</strong>状态，并投递给消费者</li><li>当提交的本地事务执行结果为 <strong>rollback</strong>，RocketMQ 服务器将不会对应事务的半事务消息投递给消费者</li></ul></li><li>在断网或者生产者应用重启等特殊情况下，若 RocketMQ服务器没有收到生产者的本地事务的执行结果 或者 收到的结果为 UNKNOWN -未知状态。经过固定时间后，RocketMQ服务器对消息生产者集群的任一实例发起消息进行<strong>回查</strong>（回查的时间间隔和最大回查次数可以配置）。</li><li>任一生产者实例收到回查后，检查对应消息的本地事务的执行的最终结果。并将检查到的本地事务的最终状态再次提交，rocketMQ服务器按照步骤4对于半事务消息进行处理。</li></ol><h5 id="事务消息生命周期"><a href="#事务消息生命周期" class="headerlink" title="事务消息生命周期"></a>事务消息生命周期</h5><img src="https://s2.loli.net/2024/01/30/lykL7WxQOIYjnuG.png" alt="image-20240126101352640" style="zoom:50%;" /><p>相比于，事务消息的生命周期多了事务待提交和消息回滚的周期，</p><ul><li>半事务消息在发送到RocketMQ服务器中时，不会直接被持久化到服务端，而是会被单独存储在事务存储系统中，此时消息对消费者不可见，等待二阶段本地事务执行后再返回结果。</li><li>消息回滚，在本地事务执行结果为rollback时，RocketMQ会将半事务消息回滚，该事务消息流程终止。</li></ul><h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTest</span> <span class="keyword">extends</span> <span class="title class_">CommonTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构建事务消息生产者 TransactionMQProducer</span></span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">transactionMQProducer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;produce_group_transaction&quot;</span>);</span><br><span class="line">        transactionMQProducer.setNamesrvAddr(<span class="string">&quot;xx.xxx.xxx.xx:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cachedThreadPool 用于本地事务回查</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool(r -&gt; &#123;</span><br><span class="line">            <span class="comment">// 重写线程工厂的构造方法 定义线程名称</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            thread.setName(<span class="string">&quot;check-transaction-thread&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 设置 本地事务连接池 用于回查</span></span><br><span class="line">        transactionMQProducer.setExecutorService(cachedThreadPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 本地事务监听器 同于执行代码</span></span><br><span class="line">        transactionMQProducer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">DemoTransactionListener</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transactionMQProducer.start();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;transaction&quot;</span>, <span class="string">&quot;transaction-1001&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;1001&quot;</span>, <span class="string">&quot;transaction json message 1001&quot;</span>.getBytes());</span><br><span class="line">            logger.info(<span class="string">&quot;发送事务消息...&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用 sendMessageInTransaction 发送事务消息</span></span><br><span class="line">            transactionMQProducer.sendMessageInTransaction(message, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 关闭长连接</span></span><br><span class="line">                transactionMQProducer.shutdown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 防止 start 建立连接失败</span></span><br><span class="line">                logger.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">defaultMQPushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;producer-group-transaction&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;xx.xxx.xxx.xxx:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 消息订阅 subExpression * 表示 所有 tags</span></span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;transaction&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="comment">// 注册消息的监听器 - 监听 broker 推送的消息并处理</span></span><br><span class="line">            defaultMQPushConsumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">                    logger.info(<span class="string">&quot;consume message：&#123;&#125;&quot;</span>, content);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回接收成功标识</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 消费者启动，与namesrv建立长连接查询路由，与 topic 所处的 broker 建立长连接，开启监听消息的推送</span></span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoTransactionListener</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DemoTransactionListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isSucc</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行本地事务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg Half(prepare) message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg Custom business parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;正在执行本地事务...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟本地事务执行状态</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            // ...</span></span><br><span class="line">        <span class="comment">// 本地事务执行成功</span></span><br><span class="line"><span class="comment">//            connection.commit();</span></span><br><span class="line"><span class="comment">//            return LocalTransactionState.COMMIT_MESSAGE;</span></span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            // 发生异常本地事务回滚</span></span><br><span class="line"><span class="comment">//            connection.rollback();</span></span><br><span class="line"><span class="comment">//            return LocalTransactionState.ROLLBACK_MESSAGE;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟随机结果</span></span><br><span class="line">        isSucc = <span class="keyword">new</span> <span class="title class_">Random</span>().nextBoolean();</span><br><span class="line">        logger.info(<span class="string">&quot;正在执行本地事务结果:&#123;&#125;&quot;</span>, isSucc);</span><br><span class="line">        <span class="keyword">return</span> isSucc ?</span><br><span class="line">                LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回查本地事务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg Check message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;正在执行本地事务回查&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        String msgId = msg.getMsgId();</span></span><br><span class="line"><span class="comment">//        logger.info(&quot;回查检查本地事务key:&#123;&#125;状态&quot;, msgId);</span></span><br><span class="line"><span class="comment">//        XX xx = xxDao.selectById(msgId);</span></span><br><span class="line"><span class="comment">//        return xx != null ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSucc ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RocketMQ高级"><a href="#RocketMQ高级" class="headerlink" title="RocketMQ高级"></a>RocketMQ高级</h2><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>消费者(Consumer)：RocketMQ 用来接收并处理消息的运行实体。消费者通常被集成在业务系统中，从服务端获取消息并进行业务逻辑处理。</li></ul><ul><li>消费者组(ConsumerGroup)：RocketMQ 系统中承载多个消费行为一致的消费者的负载均衡分组的一个逻辑概念。在消费者组中初始化多个消费者实现消费性能的水平扩展以及高可用容灾。一个消费者组可以订阅多个 topic。</li><li>订阅关系(Subscription)：订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。</li></ul><h4 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h4><p><img src="https://s2.loli.net/2024/01/30/NxAtMBlgPZfzTLi.png" alt="消费方式"></p><h5 id="集群消费模式"><a href="#集群消费模式" class="headerlink" title="集群消费模式"></a>集群消费模式</h5><blockquote><p>在集群消费模式中，一个消费者组中的每个消费者实例共同消费相同topic的消息。</p><p>每个消息只会被消费者组中的一个消费者实例消费，具体消费的策略可以配置，默认是负载均衡。</p><p>集群消费模式是默认的消费模式，它的消费进度保存在broker服务端。</p></blockquote><h6 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为消费模式为集群消费模式 默认为集群消费模式</span></span><br><span class="line">defaultMQPushConsumer.setMessageModel(MessageModel.CLUSTERING);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClusterTest</span> <span class="keyword">extends</span> <span class="title class_">CommonTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">defaultMQProducer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group-consume-cluster&quot;</span>);</span><br><span class="line">        defaultMQProducer.setNamesrvAddr(<span class="string">&quot;110.42.239.193:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQProducer.start();</span><br><span class="line">            logger.info(<span class="string">&quot;producer start&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span>  <span class="string">&quot;这是第&quot;</span> + i + <span class="string">&quot;条消息&quot;</span>;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic-consume-cluster&quot;</span>, <span class="string">&quot;test&quot;</span>, String.valueOf(i),content.getBytes());</span><br><span class="line">                <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> defaultMQProducer.send(message);</span><br><span class="line">                logger.info(<span class="string">&quot;sendResult:&#123;&#125;&quot;</span>, sendResult);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                defaultMQProducer.shutdown();</span><br><span class="line">                logger.info(<span class="string">&quot;producer shutdown&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">defaultMQPushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group-consume-cluster&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;110.42.239.193:9876&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;topic-consume-cluster&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">            defaultMQPushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">                                                                ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                    msgs.forEach(messageExt -&gt; logger.info(<span class="string">&quot;consume:&#123;&#125;&quot;</span>, messageExt.getKeys()));</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">启动两个消费者实例：</span><br><span class="line">  实例<span class="number">1</span>:</span><br><span class="line"> consume:<span class="number">0</span></span><br><span class="line"> consume:<span class="number">3</span></span><br><span class="line"> consume:<span class="number">4</span></span><br><span class="line"> consume:<span class="number">7</span></span><br><span class="line"> consume:<span class="number">8</span></span><br><span class="line">  实例<span class="number">2</span>:</span><br><span class="line"> consume:<span class="number">1</span></span><br><span class="line"> consume:<span class="number">2</span></span><br><span class="line"> consume:<span class="number">5</span></span><br><span class="line"> consume:<span class="number">6</span></span><br><span class="line"> consume:<span class="number">9</span></span><br></pre></td></tr></table></figure><h5 id="广播消费模式"><a href="#广播消费模式" class="headerlink" title="广播消费模式"></a>广播消费模式</h5><blockquote><p>在广播消费模式中，一个消费者组中的每个消费者实例都会消费相同主题的所有消息。</p><p>每个消息会被消费者组中的每个消费者实例都处理一次。</p><p>广播消息的消费进度被保存在每个消费者实例本地，而不是broker服务端中。</p></blockquote><h6 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置消费模式 广播消费模式</span></span><br><span class="line">defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">每个实例都会消费 <span class="number">10</span>条消息</span><br></pre></td></tr></table></figure><h4 id="消费重试"><a href="#消费重试" class="headerlink" title="消费重试"></a>消费重试</h4><blockquote><p>消费重试是值消费者出现异常或者消费某条消息失败时，RocketMQ 会根据消费重试策略重新投递该消息进行故障恢复，如果超过一定的次数还没有成功，则消息不再继续重试，而是直接被发送到死信队列中。</p><p>在这个过程被RocketMQ分为了3个阶段，分别是 正常消费，重试消费和死信，对应主题为 正常原始topic、重试topic和死信topic</p></blockquote><img src="https://s2.loli.net/2024/01/29/3H9BehnI7GMorCJ.png" alt="image-20240129232123639" style="zoom: 50%;" /><ul><li><p>正常消费：生产者正常消费消息并返回确认给broker，无需做任何处理</p></li><li><p>重试消息：当网络原因或者其他因素导致消费者消费消息失败时，消息会自动自动保存到重试topic中，格式为”%RETRY%消费者组”，在重试时消费者会自动订阅该重试topic，重新尝试处理消息</p><ul><li><p>重试一共会进行16次，每次会按照固定的时间间隔进行，每次重试时间间隔不一样</p><img src="https://s2.loli.net/2024/01/29/fyThmloXBdC7Jxu.png" alt="image-20240129233807693" style="zoom:50%;" /></li></ul></li><li><p>死信：重试次数耗尽，消息仍然没有消费成功，消息会被保存到死信topic中，死信topic的格式”%DLQ%消费者组名”，进入死信topic的消息不会被再次消费，需要人工介入处理问题</p></li></ul><h4 id="消息获取方式"><a href="#消息获取方式" class="headerlink" title="消息获取方式"></a>消息获取方式</h4><h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><blockquote><p>push 推送模式：broker主动向消费者推送最新的消息。</p><p>push 模式，消费位点由broker管理，使用简单</p><img src="https://s2.loli.net/2024/02/03/oZCVK9YphTdUjBW.png" alt="image-20240203140109107" style="zoom: 33%;" /><p>push 模式使用的消费者类为 DefaultMQPushConsumer。</p></blockquote><h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><blockquote><p>pull 拉取模式：消费者主动从broker中拉取消息，提交消费位点。</p><p>pull 模式，消费者自主管理消费位点，可以灵活把握消费进度和消费速度，适合流计算和耗时等特殊消费场景。</p><img src="https://s2.loli.net/2024/02/03/eGF5Hf2SPijZXkb.png" alt="image-20240203140230182" style="zoom:33%;" /><p>拉取模式是指由消费者定时向broker发起队列查询请求，broker收到请求后将没有消费的消息返回给消费者进行消费，消费后会发送确认应答给broker。</p><p>pull 模式使用的消费者类为 DefaultLitePullConsumer。</p></blockquote><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><img src="https://s2.loli.net/2024/01/30/KDRlrAkVzQNZS18.png" alt="image-20240129235856435" style="zoom:50%;" /><h3 id="消费过滤"><a href="#消费过滤" class="headerlink" title="消费过滤"></a>消费过滤</h3><blockquote><p>消费者订阅了某个主题后，RocketMQ 会将该主题中的所有消息投递给消费者。若消费者只需要关注部分消息，可通过设置过滤条件在 RocketMQ 消费者端进行过滤，只获取到需要关注的消息子集，避免接收到大量无效的消息。</p></blockquote><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>在实际业务场景中，同一个主题下的消息往往会被多个不同的下游业务方处理，各下游的处理逻辑不同，只关注自身逻辑需要的消息子集。</p><p>RocketMQ 主要解决的单个业务域即同一个主题内不同消息子集的过滤问题，一般是基于同一业务下更具体的分类进行过滤匹配。如果是对不同业务域的消息拆分，应该使用不同的主题进行区分处理。</p><h4 id="功能原理-4"><a href="#功能原理-4" class="headerlink" title="功能原理"></a>功能原理</h4><p>消息过滤的含义指的是将<strong>在RocketMQ Broker端将符合条件的消息投递给消费者</strong>，而不是在生产者端将匹配到的消息过滤掉。具体而言就是，RocketMQ 服务端根据生产者和消费者定义的过滤条件（属性或者标签）进行筛选匹配，将符合条件的消息投递给消费者进行消费。</p><img src="https://s2.loli.net/2024/01/30/AwSCt6pgNYXIG82.png" alt="消息过滤" style="zoom:50%;" /><p>流程：</p><ul><li><p>生产者：生产者在初始化消息时预先为消息设置一些属性和标签，用于后续消费时指定过滤目标</p></li><li><p>消费者：消费者在初始化及后续消费流程中通过<strong>调用订阅关系注册接口</strong>，<strong>向服务端上报</strong>需要订阅指定主题的目标消息，即<strong>过滤条件</strong></p></li><li><p>服务端：消费者获取消息时会触发服务端的动态过滤计算，<strong>RocketMQ 服务端根据消费者上报的过滤条件</strong>的表达式进行<strong>匹配</strong>，并将符合条件的消息<strong>投递</strong>给消费者。</p></li></ul><h4 id="订阅关系一致性"><a href="#订阅关系一致性" class="headerlink" title="订阅关系一致性"></a>订阅关系一致性</h4><p>过滤表达式属于订阅关系，RocketMQ 的领域模型规定，同一消费者分组内的多个消费者的订阅关系的过滤表达式必须保持一致，否则可能会导致部分消息消费不到。</p><h4 id="过滤分类"><a href="#过滤分类" class="headerlink" title="过滤分类"></a>过滤分类</h4><p>RocketMQ 提供了两种过滤方式：Tag标签过滤 和 SQL标签过滤</p><img src="https://s2.loli.net/2024/01/30/eaVOKyR2xYZ3IJm.png" alt="image-20240130101608721" style="zoom:50%;" /><h5 id="tag-过滤"><a href="#tag-过滤" class="headerlink" title="tag 过滤"></a>tag 过滤</h5><blockquote><p>消息标签是 RocketMQ 提供的细粒度消息分类属性，可以在主题层级之下做消息类型的细分。消费者通过订阅特定的标签来实现细粒度过滤。</p></blockquote><h6 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h6><p>生产者在发送消息时，设置消息的Tag标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.common.message.Message#Message(java.lang.String topic, java.lang.String tags, java.lang.String keys, <span class="type">byte</span>[] body) </span><br></pre></td></tr></table></figure><p>消费者通过 tag 标签过滤表达式需要指定已有的Tag标签来进行匹配订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#subscribe(java.lang.String topic, java.lang.String subExpression)</span><br></pre></td></tr></table></figure><h6 id="tag标签设置"><a href="#tag标签设置" class="headerlink" title="tag标签设置"></a>tag标签设置</h6><ul><li>tag 由生产者发送消息时为消息设置，每条消息只能有一个tag标签</li></ul><h6 id="tag-标签过滤表达式"><a href="#tag-标签过滤表达式" class="headerlink" title="tag 标签过滤表达式"></a>tag 标签过滤表达式</h6><p>Tag标签过滤为精准字符串匹配，过滤规则 subExpression 设置格式如下：</p><ul><li>单Tag匹配 - “tag1”：过滤表达式为目标Tag。表示只有消息标签为指定目标Tag的消息符合匹配条件，会被发送给消费者。</li><li>多Tag匹配 - “tag1||tag2||tag3”：多个Tag之间为或的关系，不同Tag间使用两个竖线（||）隔开。例如，Tag1||Tag2||Tag3，表示标签为Tag1或Tag2或Tag3的消息都满足匹配条件，都会被发送给消费者进行消费。</li><li>全部匹配 - “<em>“：使用星号（</em>）作为全匹配表达式。表示主题下的所有消息都将被发送给消费者进行消费。</li></ul><h5 id="SQL-属性过滤"><a href="#SQL-属性过滤" class="headerlink" title="SQL 属性过滤"></a>SQL 属性过滤</h5><blockquote><p>SQL 属性过滤是 RocketMQ 提供的高级消息过滤方式。生产者为消息设置多个属性（每个属性都是一对自定义的键值对Key-Value），消费者订阅时可设置SQL语法的过滤表达式过滤多个属性。</p></blockquote><p>生产者设置消息的自定义属性，通过 message.putUserProperty 方法设置，每个消息可以设置多个属性</p><p>消费者设置sql过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultMQPushConsumer.subscribe(<span class="string">&quot;topic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;SQL属性过滤表达式&quot;</span>));</span><br></pre></td></tr></table></figure><p>SQL 属性过滤<a href="https://rocketmq.apache.org/zh/docs/featureBehavior/07messagefilter">表达式</a>：IS NULL、IS NOT NULL、*&gt;* &gt;= <em>&lt;</em> &lt;=、BETWEEN xxx AND xxx、IN (xxx, xxx)等</p><blockquote><p>消费者端设置过滤规则，注册订阅关系到服务器端，服务端根据过滤规则进行动态过滤计算，将符号条件的消息投递给消费者。</p><p>在消息处理时，出现异常情况、空值情况、数值类型不符的都会被过滤掉，不会投递给消费者。</p></blockquote><h4 id="使用建议-2"><a href="#使用建议-2" class="headerlink" title="使用建议"></a>使用建议</h4><p>topic和tag的合理划分和选择：不同业务类型的消息使用topic进行拆分，相同业务不同属性或者类型使用tag区分</p><h3 id="Rebalance-机制"><a href="#Rebalance-机制" class="headerlink" title="Rebalance 机制"></a>Rebalance 机制</h3><blockquote><p>当外部环境发生变化时，例如broker发生掉线，topic扩缩容，消费者扩缩容等，RocketMQ 会自动感知并调整自身的消费，尽量减少消息没有消费</p></blockquote><h3 id="消息存储和清理"><a href="#消息存储和清理" class="headerlink" title="消息存储和清理"></a>消息存储和清理</h3><img src="https://s2.loli.net/2024/01/29/URbzNP4ilrKvL9E.png" alt="image-20240128150629985" style="zoom:50%;" /><h4 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h4><p>RocketMQ 采用<strong>文件</strong>的方式来做持久化，持久化的模式有两种：同步刷盘和异步刷盘。</p><h4 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h4><p>RabbitMQ 的消息存储采用 <strong>顺序写、随机读</strong>，保证了消息存储的速度。</p><p><img src="https://s2.loli.net/2024/01/28/iXvTxeNlqHwzbM1.png" alt="image-20240128151352481"></p><h5 id="存储文件结构"><a href="#存储文件结构" class="headerlink" title="存储文件结构"></a>存储文件结构</h5><p>RocketMQ 消息默认存储在本地磁盘文件，RocketMQ broker 的存储文件结构如下：</p><p><img src="https://rocketmq.apache.org/zh/assets/images/store-2eb2d519dd4030480ca3ea63f2dc1b70.jpg" alt="消息存储"></p><ul><li>commitlog：存储消息物理文件<ul><li>文件名长度为20，由文件保存消息的最小物理偏移量offset的基础上高位补0组成</li><li>文件大小一般最大为1g，可以通过 mapedFileSizeCommitLog 进行配置</li></ul></li><li>comsumeQueue：存储逻辑队列索引</li><li>index：存储消息唯一标识-message key的索引信息 </li><li>config：保存了当前broker的topic、订阅关系等配置元数据信息。<ul><li>broker 会定时将配置信息从内存持久化到该目录中，用于宕机后到快速恢复</li></ul></li></ul><h5 id="消息构成"><a href="#消息构成" class="headerlink" title="消息构成"></a>消息构成</h5><p><img src="https://s2.loli.net/2024/01/30/akfH2t5Px7Uj6AJ.png" alt="image-20240128164256846"></p><p>commitlog 目录</p><p>commitlog 目录下，可以有多个commitlog文件，但是逻辑上是一个文件，只是为了方便检索和读写将文件物理拆分成多个子文件（默认最大大小为1g），子文件之间通过其保存的第一个物理点位和上一个文件的最后一个物理点位进行连接。</p><img src="https://s2.loli.net/2024/01/30/nd6mtXM39ijqvxL.png" alt="image-20240128165134974" style="zoom: 33%;" /><p>RocketMQ 的CommitLog文件是按照消息的时间顺序和物理offset的顺序来写入的，以保证消息的顺序性和持久性，在执行写入操作时会加锁，以保证多线程访问的安全性。当一个子文件写满后，将会创建一个新的 commitlog，在上一个文件的 offset 的基础上继续写操作。因此所有 commitlog 文件都是连续的，被写入的总是最后一个子文件。</p><h4 id="消息检索"><a href="#消息检索" class="headerlink" title="消息检索"></a>消息检索</h4><img src="https://s2.loli.net/2024/01/28/JHuzUneGldIV6AT.png" alt="image-20240128231201092" style="zoom:33%;" /><ul><li><p>利用 MessageID 查询消息</p><p>MessageID 是由生产者向broker发送消息成功，由broker自动生成的消息编号，这个编号由ip + port + offset 组成，所以通过它本身就快速查找和操作特定的消息。</p></li><li><p>实现 tag 过滤查询消息</p><p>基于 comsumeQueue 的消息索引实现 tag 过滤查询消息。</p><p>comsumeQueue 是一个用于存储消息偏移量信息的数据结构，它可以帮助快速定位消息在 commitlog 文件中的位置。comsumeQueue 的索引条目与消息的偏移量相关联。</p><p>comsumeQueue 文件目录结构：comsumeQueue文件夹-&gt;topic目录-&gt;队列编号目录（0｜1｜2｜4）-&gt;consumeQueue文件，其中consumeQueue文件中的数据结构为 物理位点（offset-8字节） + 消息体size大小（4字节） + tag的hashcode值（8字节）。</p><p>流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 对于指定的 tag 进行 hash 运算得到对应的 hashcode</span><br><span class="line"><span class="number">2.</span> 从consumeQueue文件中查找对应hashcode的数据</span><br><span class="line"><span class="number">3.</span> 根据这些的数据的物理位置offset从commitlog中提取这些消息</span><br><span class="line"><span class="number">4.</span> 由于哈希冲突即有不同的tag会有相同的hashcode值的情况，因此要对于从commitlog获取的这些offset的数据进行根据具体的tag进行过滤</span><br><span class="line"><span class="number">5.</span> 将过滤过的消息提取出来并封装为 message 进行返回</span><br></pre></td></tr></table></figure></li><li><p>通过 key 查询消息</p><p>key 是生产者赋予消息的业务唯一标识，RocketMQ的底层存储结构的IndexFile提供了基于key或者时间的索引功能。</p><p>IndexFile 是提供的基于 message key 和 时间 的索引文件</p></li></ul><h4 id="消息清理"><a href="#消息清理" class="headerlink" title="消息清理"></a>消息清理</h4><blockquote><p>RocketMQ Broker的消息存储文件CommitLog和其他索引文件都是通过顺序写的方式存储在磁盘上，磁盘的空间是有限的，数据不可能无限制追加。</p><p>RocketMQ Broker引入了过期文件清理机制。</p></blockquote><h5 id="CommitLog文件的清理"><a href="#CommitLog文件的清理" class="headerlink" title="CommitLog文件的清理"></a>CommitLog文件的清理</h5><p>Broker 任务调度每隔10秒对当前的commitlog文件进行一次扫描，检查出当前满足删除条件。</p><h6 id="删除条件"><a href="#删除条件" class="headerlink" title="删除条件"></a>删除条件</h6><blockquote><p>删除72小时内没有产生消费的commitlog文件</p></blockquote><ul><li>默认（可配置）明日凌晨4点</li><li>磁盘使用空间超过默认的85%，执行删除</li></ul><p>删除commitlog的执行过程</p><ol><li>扫描并根据系统配置的文件保留时间来确定 commitlog 文件的过期状态</li><li>对于过期的commitlog文件，首先会进行预删除检查（是否有进程正在使用这些文件，内存引用等）</li><li>执行删除操作</li><li>处理删除失败的情况（文件正在被使用等），会间隔120秒再次尝试执行重试删除直到文件删除</li></ol><p>删除索引文件的执行过程</p><p>遍历每一个consumeQueue文件，删除过期的消费队列文件以及更新消费队列的最小偏移量，在遍历删除的过程中，每删除一个consumeQueue文件，都会休眠一段时间，再对下一个comsumeQueue文件进行检查和删除操作。indexfile文件同理。</p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>RocketMQ 采用零拷贝技术，提高性能，降低延迟。</p><p>零拷贝：在网络请求和数据返回处理的过程中，避免了数据在用户空间和内核空间之间的多次复制，从而减少拷贝操作，提高数据传输速度。</p><p><img src="https://s2.loli.net/2024/01/28/y3hPNSdI1gl8AjO.png" alt="image-20240128152707430"></p><p>RocketMQ 使用 MappedByteBuffer类（ Java NIO提供的类，该类提供了内存映射文件的方式即在用户空间创建内核空间文件的内存映射区域，这里的内存映射是指地址映射，而不是整个文件 ）将文件直接映射到用户空间的内存地址空间中，对于文件的操作直接在用户空间对应文件映射的内存区域中进行，避免了数据在内核空间和用户空间的相互拷贝过程。</p><h3 id="同步刷盘和异步刷盘"><a href="#同步刷盘和异步刷盘" class="headerlink" title="同步刷盘和异步刷盘"></a>同步刷盘和异步刷盘</h3><p>RocketMQ 处理消息是在内存中进行，但会被持久化到磁盘的 commitlog 文件中以便消息存储和故障恢复。</p><p>RocketMQ 提供了两种消息存储到 commitlog 时数据写入磁盘的不同机制：同步刷盘（Synchronous Flush）和异步刷盘（Asynchronous Flush）</p><img src="https://s2.loli.net/2024/01/28/JHj1WLXlMgoCfrv.png" alt="image-20240128232339508" style="zoom:50%;" /><h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>生产者发送的消息，broker接收消息，消息先存储在内存中，然后 broker 会立即将这些数据同步写入磁盘，消息被持久化到磁盘后，生产者才会收到写入成功的确认。</p><p>特点：提供了更高的数据安全性，服务宕机不会丢失数据</p><h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>生产者发送的消息，broker接收消息，消息先存储在内存中， broker 不会立即进行磁盘同步操作，生产者直接收到写入成功的确认，消息会在定时或者适当的时机批量的写入到磁盘中。</p><p>特点：提高消息的响应速度和系统的吞吐量，服务宕机可能会丢失数据</p><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flushDiskType=SYNC_FLUSH # 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH # 异步刷盘</span><br></pre></td></tr></table></figure><h3 id="冥等性保障"><a href="#冥等性保障" class="headerlink" title="冥等性保障"></a>冥等性保障</h3><h4 id="冥等性"><a href="#冥等性" class="headerlink" title="冥等性"></a>冥等性</h4><blockquote><p>幂等性（Idempotency）是指无论一个操作执行多少次，都会得到相同的结果。</p><p>在 RocketMQ 中，保证幂等性主要是为了确保即使同一消息被重复消费（例如，在消息重新投递或系统故障后），也不会对业务产生重复的影响。</p></blockquote><p>RocketMQ 导致消息重复的原因：</p><ul><li>发送时的消息重复：早期生产者发送消息到broker，broker完成了数据的持久化后，在响应应答给生产者时网络异常等，导致broker对于生产者应答失败，此时生产者重新发送消息，消费者此时会收到两条完全一样的消息。在现在的版本中，这个问题已经被解决，broker对于相同的messageID进行去重，不会再存储两条相同的消息，而是直接返回成功的响应给生产者。</li><li>投递时的消息重复：<ul><li>消息已经投递到消费者并完成业务处理，在消费者响应应答给消费者时，网络出现抖动异常或者broker重启或者消费者重启等，broker 没有接收到应答，为了保证消息至少被消费一次，会重试再次投递相同的消息，消费者此时可能处理两次相同的消息。</li><li>当RocketMQ 发生重启、因为扩缩容导致的Rebalance也可能会导致重复投递消息。</li></ul></li></ul><p>因此处理消息的冥等性非常的重要</p><h4 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h4><p>处理消息冥等性问题最常见的做法就是在 业务层实现冥等性，为每一条消息设置业务唯一标识（例如：订单号、事务ID等，建议不要使用MessageID作为处理依据，因为MessageId存在重复的情况），然后在消费者的业务逻辑中检查该标识符。在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生产者</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">message.setKey(<span class="string">&quot;order_1234&quot;</span>);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 消费者</span><br><span class="line">consumer.subscribe(<span class="string">&quot;demo_topic&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">  <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获取分布式锁 保证线程安全</span></span><br><span class="line">    lock.tryLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey();</span><br><span class="line">    <span class="comment">// 查询数据库获取指定key订单状态</span></span><br><span class="line">     <span class="keyword">if</span>(订单状态为<span class="string">&quot;等待支付&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理扣款</span></span><br><span class="line">      <span class="comment">// 返回支付成功响应</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(订单状态为<span class="string">&quot;已支付&quot;</span>) &#123;</span><br><span class="line">       <span class="comment">// 直接返回支付成功响应</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="SpringBoot接入RocketMQ"><a href="#SpringBoot接入RocketMQ" class="headerlink" title="SpringBoot接入RocketMQ"></a>SpringBoot接入RocketMQ</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RocketMQ&quot;&gt;&lt;a href=&quot;#RocketMQ&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ&quot;&gt;&lt;/a&gt;RocketMQ&lt;/h1&gt;&lt;h2 id=&quot;RocketMQ入门&quot;&gt;&lt;a href=&quot;#RocketMQ入门&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>JUC 并发编程 (二) JMM</title>
    <link href="http://example.com/2023/01/26/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/"/>
    <id>http://example.com/2023/01/26/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/</id>
    <published>2023-01-25T16:00:00.000Z</published>
    <updated>2024-03-12T02:31:19.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-并发编程"><a href="#JUC-并发编程" class="headerlink" title="JUC 并发编程"></a>JUC 并发编程</h1><h2 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h2><h3 id="共享模型"><a href="#共享模型" class="headerlink" title="共享模型"></a>共享模型</h3><h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><blockquote><p>多线程在访问共享变量时，需要考虑临界区执行的原子性、资源的可见性和指令的有序性问题。</p><p>JMM - Java Memory Model javan内存模型即是一个抽象的概念。它规定了在多线程环境下，不同线程之间如何访问共享内存中的变量以及这些访问的可见性、有序性等方面的规则。</p><p>JMM 将内存分为了 <strong>主内存</strong> 和 <strong>工作内存</strong>。主内存是所有线程共享的内存区域，工作内存是每一个线程私有的内存，用于存储该线程使用到的变量的拷贝（在运行时，JIT编译器不断优化会将主内存的值拷贝到线程的工作内存中，减少对主内存的访问，提高效率）。</p></blockquote><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><blockquote><p>原子性 - atomicity 是指在一次操作中，要么所有的步骤都被执行，要么都不被执行，不会出现部分执行的情况。</p><p>原子性保证了指令的执行不会受到线程上下文切换的影响。</p><p>在多线程环境中，这意味着对共享变量的指令操作要么是完全执行，要么完全不执行。</p></blockquote><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><blockquote><p>可见性 - visibility 是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。在没有适当同步的多线程程序中，一个线程对共享变量的修改可能对其他线程不可见。</p><p>可见性问题的由来是由于 jvm 的优化和硬件的缓存机制，一个线程对共享变量的修改可能被缓存在线程的工作内存中，导致其他线程不可见。</p><p>可见性保证了线程对于共享资源访问和操作都是可见的，不受线程的工作内存的影响。</p></blockquote><p>volatile 保证可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// volatile 保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isRun</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 start...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isRun) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        isRun = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">  t1 start...</span><br><span class="line">  结束</span><br></pre></td></tr></table></figure><p>synchronized 同步代码块保证可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isRun</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 start...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!isRun) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            isRun = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">  t1 start...</span><br><span class="line">  结束</span><br></pre></td></tr></table></figure><p>上述实例说明：volatile 保证了可见性，对于变量的读写操作都是在主内存中操作；</p><p>​        synchronized 可以保证同步代码块内变量的可见性来实现可见性，但是加锁的操作会让对象关联monitor监视器，效率比较低</p><blockquote><p>可见性不能保证原子性：</p><ul><li>可见性保证的是 多个线程中，一个线程的写操作对于其他线程是可见的，其他线程读取到的都是最新值</li><li>可见性不能避免多线程场景下，字节码指令交错执行的情况</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i++和i--的字节码：</span><br><span class="line"><span class="number">0</span> getstatic #<span class="number">2</span>   <span class="comment">// 读取静态变量</span></span><br><span class="line"><span class="number">3</span> iconst_1       <span class="comment">// 将整数常量1推送到栈顶</span></span><br><span class="line"><span class="number">4</span> iadd           <span class="comment">// 相加并将结果推送到栈顶</span></span><br><span class="line"><span class="number">5</span> putstatic #<span class="number">2</span>   <span class="comment">// 将栈顶的值存储到静态变量</span></span><br><span class="line">  </span><br><span class="line"><span class="number">0</span> getstatic #<span class="number">2</span> </span><br><span class="line"><span class="number">3</span> iconst_1</span><br><span class="line"><span class="number">4</span> isub</span><br><span class="line"><span class="number">5</span> putstatic #<span class="number">2</span></span><br><span class="line">多线程的场景下，<span class="keyword">volatile</span>不能避免指令的交错执行 比如两个线程同时执行了getstatic，导致两个修改是相等的值<span class="number">0</span>，最终写入的结果是<span class="number">1</span>或者-<span class="number">1</span>（取决于指令的执行速度），导致结果不如预期<span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>因此 volatile 适用于  一个线程写 多个线程读 的场景</p></blockquote><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><blockquote><p>有序性 - ordering 是指程序代码的执行顺序。有序性保证了指令执行顺序不会受cpu指令并行优化的影响。</p></blockquote><h6 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h6><blockquote><p>在不改变程序语义的前提下，为了优化并行性能并充分利用现代处理器的特性，JIT编译器可能会对指令进行重排序，让操作的执行顺序与代码指令顺序不一致。提高指令集的并行度（同一时间内执行多个指令或操作的能力），不能提高单条指令的执行时间，但是可以提高系统整体的性能和吞吐量。</p><p><img src="https://s2.loli.net/2024/01/26/h46kIz5CMxRFWov.png" alt="image-20240126113355995"></p><p><img src="https://s2.loli.net/2024/01/26/5Q2FNiLYuHqJ1Tm.png" alt="image-20240126113411771"></p><p>指令重排在单线程的环境下没有问题，但是在多线程的场景下，由于多线程执行交错执行，指令重排可能会影响正确性。 </p></blockquote><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><blockquote><p>volatile是用来修饰成员变量和静态成员变量（注意：局部变量是线程私有）的修饰符，它可以保证可见性和有序性</p><ul><li>保证可见性：保证线程操作 volatile 变量都是直接操作主内存中的。当一个线程修改被 volatile 修饰的变变量的值时，该变化对所有其他线程都是可见的。<ul><li>写操作立即刷新到主存中，读操作从主存中获取值</li></ul></li><li>保证有序性：禁止指令重排序</li></ul></blockquote><h5 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h5><p>volatile的底层原理是 <strong>内存屏障</strong> - memory barrier </p><ul><li><p><strong>写屏障</strong>：<strong>写指令后</strong>加入写屏障</p><ul><li>确保写屏障之前的所有共享变量的执行变化同步到主存中<ul><li>确保其他线程可以读取到最新变化的数据 </li></ul></li><li>不会将写屏障之前的代码排在写屏障后执行 即 确保了对于该共享变量写操作之前的代码不被重排序到写操作之后</li></ul></li><li><p><strong>读屏障</strong>：<strong>读指令前</strong>加入读屏障</p><ul><li>确保读屏障之前的所有共享变量的读取加载主存中的数据 <ul><li>确保线程读取到的是最新的数据，而不是工作内存的旧数据</li></ul></li><li> 不会将读屏障之后的代码排在读屏障前执行 即 确保了对于该共享变量读操作之后的代码不被重排序到读操作之前</li></ul></li></ul><p>不能保证原子性，不能解决多线程的指令交错（由 “cpu分时片” 决定）问题，而 synchronized 可以保证原子性和可见性（注意不能保证指令重排，只是防止共享变量在同步代码块中不会存在有序性问题，对象在代码块外也可能有问题）</p><h5 id="double-check-lock"><a href="#double-check-lock" class="headerlink" title="double-check lock"></a>double-check lock</h5><h6 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h6><ul><li><p>懒汉式单例模式</p><ul><li>懒惰实例化</li><li>每次使用 getInstance 获取单例实例都需要添加 synchronized 锁，性能较低</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双重校验锁</p><p>基于上述获取锁的才能获取单例实例的问题，双重校验锁在此基础上进行了优化，防止了单例对象被创建后，仍然尝试获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 当 single 没有被创建并赋值时，才会获取 synchronized 锁去创建对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 getInstance方法 的字节码文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> getstatic #<span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> ifnonnull <span class="number">37</span> (+<span class="number">34</span>)</span><br><span class="line"> <span class="number">6</span> ldc #<span class="number">3</span> <span class="comment">// 将锁前获取类对象</span></span><br><span class="line"> <span class="number">8</span> dup    <span class="comment">// 将类对象的引用指针复制</span></span><br><span class="line"> <span class="number">9</span> astore_0 <span class="comment">// 类对象的引用指针副本存储在本地变量表第0位 用于解锁</span></span><br><span class="line"><span class="number">10</span> monitorenter <span class="comment">// 加锁</span></span><br><span class="line"><span class="number">11</span> getstatic #<span class="number">2</span></span><br><span class="line"><span class="number">14</span> ifnonnull <span class="number">27</span> (+<span class="number">13</span>)</span><br><span class="line"><span class="number">17</span> <span class="keyword">new</span> #<span class="number">3</span>  <span class="comment">// 构建一个新的对象</span></span><br><span class="line"><span class="number">20</span> dup     <span class="comment">// 复制引用</span></span><br><span class="line"><span class="number">21</span> invokespecial #<span class="number">4</span>  <span class="comment">// 调用构造方法</span></span><br><span class="line"><span class="number">24</span> putstatic #<span class="number">2</span>  <span class="comment">// 栈顶的数据存储到类的静态变量中</span></span><br><span class="line"><span class="number">27</span> aload_0</span><br><span class="line"><span class="number">28</span> monitorexit</span><br><span class="line"><span class="number">29</span> goto <span class="number">37</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">32</span> astore_1</span><br><span class="line"><span class="number">33</span> aload_0</span><br><span class="line"><span class="number">34</span> monitorexit</span><br><span class="line"><span class="number">35</span> aload_1</span><br><span class="line"><span class="number">36</span> athrow</span><br><span class="line"><span class="number">37</span> getstatic #<span class="number">2</span></span><br><span class="line"><span class="number">40</span> areturn</span><br></pre></td></tr></table></figure><p>在上述代码不断执行的过程中，JIT对于上述代码进行了指令重排序，将24赋值和21调用构造方法的指令交换执行顺序，从而导致了线程安全问题的出现。</p><img src="https://s2.loli.net/2024/01/26/nAzCWRruxQakKUt.png" alt="image-20240126140231361" style="zoom:33%;" /><p>从上述时序图可以看出，JIT的指令重排，导致先赋值引用再调用构造函数进行初始化，导致另一个线程在线程赋值进入判断 单例对象是否为空，才是被赋值引用的对象不为空，因此直接返回，而此时返回的是 没有调用构造函数而未被完全初始化的对象。</p><p>解决方案：使用 volatile 修饰 静态的单例 single 可以防止单例问题 - volatile 阻止指令重排序 写操作之前的代码不会重排序到读操作之后，保证了 invokespecial 不会重排序重排序到 putstatic 后面执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 当 single 没有被创建并赋值时，才会获取 synchronized 锁去创建对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><blockquote><p>happens-before规则 定义了一种内存可见性保证，即保证 <strong>对一个共享变量的写操作的结果对其他线程读操作可见</strong>。在这种保证下，多线程之间的操作不会产生意料之外的结果。</p><p>happens-before为开发者提供了一种方式，用来推断和保证在并发环境中不同线程对共享数据的操作是如何被看到的。</p></blockquote><p>常见happens-before规则</p><ul><li>synchronized</li><li>volatile 读写屏障</li><li>thread start 之前执行写操作</li><li>thread start 和 join 保证读写的可见性</li><li>t1 在 interrupt t2 前执行写操作</li><li>基础变量默认值</li></ul><h3 id="无锁并发"><a href="#无锁并发" class="headerlink" title="无锁并发"></a>无锁并发</h3><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><blockquote><p>CAS - compare and swap|set 是乐观锁的机制，用于实现多线程环境下的并发控制，它操作系统层面的原子性操作。CAS操作包括了三个参数：内存位置（通常是一个变量的内存地址相对于结构的偏移量）、期望值和新值。</p><p>操作：只有当内存位置的当前值等于期望值时，才会将内存位置的值更新为新值；否则，不进行任何操作。</p></blockquote><p>CAS 底层实现依赖于硬件的原子性操作指令，在X86架构上，这个指令是 cmxchg 指令</p><blockquote><p>乐观锁  <strong>CAS</strong> 必须配合 <strong>volatile</strong> 实现非阻塞的无锁并发：cas 需要 volatile 修饰提供可见性，获取共享变量的最新值进行比较</p></blockquote><h5 id="CAS和Synchronized的性能比较"><a href="#CAS和Synchronized的性能比较" class="headerlink" title="CAS和Synchronized的性能比较"></a>CAS和Synchronized的性能比较</h5><p>使用 CAS 加 while(true) 实现无锁并发的效率 在并发程度不是特别高时，比加悲观锁Synchronized的效率要高：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger value;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">(Integer size)</span> &#123;</span><br><span class="line">    <span class="comment">// 不断CAS尝试递增操作直到成功</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> value.get();</span><br><span class="line">      <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev + size;</span><br><span class="line">      <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：CAS 加 while(true) 失败重试 实现无锁并发时，线程不会停下来即不会阻塞，线程的上下文切换少（它的线程上下文切换只取决于CPU时间片的分配），而使用 synchronized 时，当线程未竞争到锁会阻塞，会进行线程的上下文切换，频繁的上下文切换会到来性能的消耗。但是在高度竞争的情况下，频繁的CAS操作会导致性能下降，多个线程可能因为更新失败而不断的重试更新</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>cas 结合 volatile 支持实现无锁并发，使用于线程少，多核cpu的场景下 - 无锁无阻塞并发</p><ul><li>CAS 基于乐观锁的思想，当别的线程修改共享变量时，则该线程CAS修改共享变量失败，进入while(true)的下一次循环重试，不会阻塞，直到修改成功。</li><li>sychronized 是悲观锁，只有一个线程可以操作共享变量，防止其他线程修改共享变量，造成线程安全问题</li></ul><h5 id="CAS-ABA问题"><a href="#CAS-ABA问题" class="headerlink" title="CAS ABA问题"></a>CAS ABA问题</h5><p>CAS的<strong>ABA</strong>问题是在使用CAS时可能遇到的一个特殊问题。这个问题的出现是因为CAS只检查内存中的值是否与预期的值相同，而不检查在此期间该值是否被修改过。</p><p>实例：如果一个变量原始值是A，后来被另一个线程改成了B，然后又改回了A，那么进行CAS操作的线程将无法知晓这中间的变化，它只会看到值仍然是A，并且匹配其预期值，因此会错误地认为没有其他线程修改过这个变量。</p><p>解决方案：使用<strong>版本号</strong>和<strong>时间戳</strong>，每次操作值时更新版本号或者时间戳，cas操作不仅会检查变量的值是否和预期相符，还会检查版本号或者时间戳是否一致。</p><h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><h5 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h5><p>常见的原子整数包括 AtomicBoolean、AtomicInteger、AtomicLong等</p><p>以 AtomicInteger 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">  <span class="comment">// 内部维护了一个volatile修饰的int变量  所有的操作都是对这个值进行的cas操作</span></span><br><span class="line">  <span class="comment">// volatile保证可见性 对于这个value的操作使用cas保证线程安全</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 比较期望值 相等代替新值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetInt(<span class="built_in">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ++i 自增并获取  CAS 不断重试</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// i++ 先获取再自增 </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 函数式接口 (x -&gt; x*3)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> &#123;</span><br><span class="line">        <span class="type">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.applyAsInt(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关注 getAndIncrement 方法的实现</span></span><br></pre></td></tr></table></figure><h5 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h5><blockquote><p>当我们需要保护的数据类型不是基本类型时，就可以使用原子引用类型</p><p>常见原子引用的类型：AtomicReference、AtomicMarkableReference、AtomicStampedReference</p></blockquote><h6 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10&quot;</span>));</span><br></pre></td></tr></table></figure><h6 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h6><p>AtomicStampedReference 可以防止ABA问题，它包含了两个部分的信息，一个是对象的引用，一个是一个整数值，用于标记引用的版本号    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：值 版本号</span></span><br><span class="line">AtomicStampedReference&lt;String&gt; atomicStampedReference =  <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp(); <span class="comment">// 获取版本号</span></span><br><span class="line">atomicStampedReference.compareAndSet(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, stamp, stamp + <span class="number">1</span>); <span class="comment">// 更新时同时检查版本号</span></span><br></pre></td></tr></table></figure><h6 id="AutomicMarkabledRefence"><a href="#AutomicMarkabledRefence" class="headerlink" title="AutomicMarkabledRefence"></a>AutomicMarkabledRefence</h6><p>AtomicMarkableReference 可以防止ABA问题，它包含了两个部分的信息，一个是对象的引用，一个是布尔值（用于标记引用是否被修改过或者有特定的状态，用这个布尔类型描述对象是否被修改了）。AtomicMarkableReference 不关心值更新了多少次，只关心值是否被修改过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicMarkableReference&lt;Integer&gt; atomicMarkableReference = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">atomicMarkableReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h5 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h5><p>原子数组用于<strong>保证原子数组中的元素的线程安全</strong></p><p>常见的原子数组 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicIntegerArray</span> <span class="variable">atomicIntegerArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">5</span>);</span><br><span class="line">atomicIntegerArray.getAndIncrement(<span class="number">1</span>);</span><br><span class="line"># 输出 [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h6 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h6><p>字段更新器用于保护某个对象的属性或者成员变量的线程安全性</p><p>常见的字段更新器：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>注意：对象中的字段或属性必须加上volatile修饰保证可见性，否则会保存 IllegalArgumentException: Must be volatile type 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 参数：类 字段类型 字段名称</span></span><br><span class="line">        <span class="type">AtomicReferenceFieldUpdater</span> <span class="variable">updater</span> <span class="operator">=</span></span><br><span class="line">                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="comment">// 参数：类实例对象 属性期望值（旧值） 新值</span></span><br><span class="line">        updater.compareAndSet(stu, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h5><p>原子累加器专用于<strong>高并发场景下的累加操作</strong>，但是性能比AtomicInteger进行累加好很多。常见的原子累加器 长整型LongAdder、双精度浮点型DoubleAdder。</p><p>累加性能高的原因：分段累加</p><p>性能提升原因与原子累加器的底层实现有关</p><p>AtomicInteger的getAndIncrement方法是底层是通过 while 循环不断尝试CAS操作，往一个共享变量进行累加，当线程之间竞争比较激烈的情况下，尝试的次数也会变多，导致性能下降。</p><p>而原子累加器在存在竞争时，设置了<strong>多个累加单元Cell</strong>(累加单元个数一般不会超过CPU的核心数)，对多个累加单元进行操作，最后将结果汇总，<strong>减少</strong>了对一个共享变量CAS操作失败的重<strong>试次数</strong>，提高了性能。</p><h6 id="LongAddr原理"><a href="#LongAddr原理" class="headerlink" title="LongAddr原理"></a>LongAddr原理</h6><ul><li><input disabled="" type="checkbox"> p177-183 LongAddr</li></ul><h4 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h4><blockquote><p>Unsafe 是位于 sun.misc 包中的被称为 不安全的类，提供了一些底层操作，允许开发者绕过 Java语言的一些安全检查和限制，直接进行内存操作、对象实例化等。它提供了一些直接访问内存和其他执行低级操作的方法，这些方法提高了性能。</p><p>Unsafe 绕过了 Java 内存模型和访问权限，因此 Unsafe 类的使用是受限的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//        Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line">        <span class="comment">// 无法直接获取Unsafe的静态单例对象 theUnsafe - Exception in thread &quot;main&quot; java.lang.SecurityException: Unsafe</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 反射获取</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) theUnsafe.get(Unsafe.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Unsafe-CAS"><a href="#Unsafe-CAS" class="headerlink" title="Unsafe CAS"></a>Unsafe CAS</h5><blockquote><p>Unsafe 提供了 CAS 原子性操作的支持，这是一种多线程并发控制的机制。CAS是一种乐观锁定的方式，能够在不使用锁的情况下实现对共享变量的原子操作。</p><p>Unsafe 底层根据内存偏移量来定位对象的内存位置，在内存位获取据值进行比较和交换的操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 反射获取</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) theUnsafe.get(Unsafe.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">0</span>, <span class="string">&quot;coder&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取对象属性相对于对象地址的偏移量（注意：不是内存地址，而是对象属性相对于对象确始位置的偏移量是固定的）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(Student.class.getDeclaredField(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(Student.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// CAS 操作</span></span><br><span class="line">        unsafe.compareAndSwapInt(student, idOffset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        unsafe.compareAndSwapObject(student, nameOffset, <span class="string">&quot;coder&quot;</span>, <span class="string">&quot;yuanjianwei&quot;</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出 Student&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;yuanjianwei&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>重点理解 Unsafe 的 objectFieldOffset 和 compareAndSwapInt 方法 </p><p>偏移量是属性地址相对于对象实例起始地址的偏移量，每个实例对象都一样</p><p>简单实现 AtomicInteger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAtomicInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(Unsafe.class);</span><br><span class="line"></span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAtomicInteger</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> oldValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, oldValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = UNSAFE.getIntVolatile(<span class="built_in">this</span>, valueOffset);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, v, v + delta));</span><br><span class="line">        <span class="keyword">return</span> value + delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyAtomicInteger</span> <span class="variable">myAtomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">      <span class="comment">// 1000个线程执行累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myAtomicInteger.incrementAndGet(<span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threads.forEach(thread -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(myAtomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 输出 <span class="number">1000</span></span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><blockquote><p>不可变类是指在创建后其实例的状态不能被修改的类。一旦不可变类的对象被创建，其内部的状态（属性的值）将保持不变，不能被更改。</p><p>不可变类是线程安全的，它们的状态不会发生变化，不会受到多线程并发访问的影响。</p></blockquote><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><blockquote><p>String 是不可变的，一旦创建了String对象，它的内容将不会被改变，因此不可变类是线程安全的类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 是如何保证性能安全的？</p><ul><li>String 底层使用 private final char value[] 数组来存储字符串的内容，使用 private 确保是私有的，final 确保引用不能改变，因此只有构造时才能对它进行赋值，后续只读。</li><li>String 类上加上了 final 修饰符，所以此类不能被继承，防止任何子类重写覆盖 String 的方法，破环 String 的不可变性。</li><li>String 类中没有提供用于修改字符串的方法，所有对于 String 的操作都是通过返回一个新的String对象完成。</li><li>String 类采用了采用了拷贝性保护的思想，避免传入的引用共享。</li></ul><h4 id="拷贝性保护"><a href="#拷贝性保护" class="headerlink" title="拷贝性保护"></a>拷贝性保护</h4><blockquote><p>拷贝性保护（Defensive Copy）是一种编程技术，在处理可变对象时创建它们的副本，而不是直接使用原始对象的引用，以避免引用共享，防止外部对对象的意外修改来保证不可变性。</p><p>String 采用了拷贝性保护的思想，避免引用共享，保证了不可变性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">  <span class="comment">// 通过拷贝一个新的字符数组作为副本来保证不可变性 不与传入的数组共享引用（防止传入的数组被改变）</span></span><br><span class="line">    <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>享元模式（Flyweight Pattern）是一种设计模式，共享相同值的对象以减少内存使用和提高性能。</p><p>对于基本数据类型的包装类（如 Integer、Double 等），为了提高内存利用率和性能，采用了享元模式的概念。</p><p>包装类维护了一个常量池，其中包含了一定范围内的常用数值的对象实例。当你创建一个新的包装类对象时，系统首先检查常量池中是否已存在相同数值的对象，如果存在，则返回常量池中的对象引用，而不是创建一个新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LongCache</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">LongCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> <span class="title class_">Long</span>[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">           cache[i] = <span class="keyword">new</span> <span class="title class_">Long</span>(i - <span class="number">128</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Byte、Long、Short: -128～127</li><li>Character：0~127 </li><li>Integer: -128~127 最小值不能改变 最大值可以通过虚拟机参数 java.lang.Integer.IntegerCache.high 调整</li><li>Boolean：TRUE FALSE</li></ul><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><h4 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h4><h5 id="设置final原理"><a href="#设置final原理" class="headerlink" title="设置final原理"></a>设置final原理</h5><p>如果一个成员被final所修饰时，在进行赋值时，在赋值指令之后加入写屏障。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> aload_0</span><br><span class="line"><span class="number">1</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt; : ()V&gt; </span><br><span class="line"><span class="number">4</span> aload_0</span><br><span class="line"><span class="number">5</span> iconst_0</span><br><span class="line"><span class="number">6</span> putfield #<span class="number">7</span>  # 将操作数栈上的整数常量<span class="number">0</span>存储到对象的在常量池中的索引为<span class="number">7</span>字段a中</span><br><span class="line">  ---&gt; 写屏障</span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>写屏障</p><ul><li>保证写屏障之前的所有共享变量的变化同步主存 </li><li>保证写屏障之前的指令不会被重排序到写屏障之后</li></ul><h3 id="无状态类"><a href="#无状态类" class="headerlink" title="无状态类"></a>无状态类</h3><p>当一个 Java 类没有任何成员变量并且该类的方法中没有对外部状态的依赖时，则该类是无状态的，该类的实例也就是线程安全的，多个线程可以同时调用该类的方法而不会相互干扰。</p><p>在无状态的类中，方法的执行结果只取决于传入的参数，而不受实例内部属性或者状态的影响，从而避免导致线程安全问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JUC-并发编程&quot;&gt;&lt;a href=&quot;#JUC-并发编程&quot; class=&quot;headerlink&quot; title=&quot;JUC 并发编程&quot;&gt;&lt;/a&gt;JUC 并发编程&lt;/h1&gt;&lt;h2 id=&quot;并发基础&quot;&gt;&lt;a href=&quot;#并发基础&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>jvm 高级</title>
    <link href="http://example.com/2023/01/26/jvm-4-%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/01/26/jvm-4-%E5%8E%9F%E7%90%86/</id>
    <published>2023-01-25T16:00:00.000Z</published>
    <updated>2024-02-18T02:49:17.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm-原理"><a href="#jvm-原理" class="headerlink" title="jvm 原理"></a>jvm 原理</h1><h2 id="jvm-数据存储"><a href="#jvm-数据存储" class="headerlink" title="jvm 数据存储"></a>jvm 数据存储</h2><h3 id="栈的数据存储"><a href="#栈的数据存储" class="headerlink" title="栈的数据存储"></a>栈的数据存储</h3><h4 id="局部变量表-slot"><a href="#局部变量表-slot" class="headerlink" title="局部变量表 slot"></a>局部变量表 slot</h4><p>java 提供了8个基本数据类型 byte-1,short-2,integer-4,long-8,float-4,double-8,char-2,boolean-1 每个基本数据类型内存占用的字节数不同，注意这里的内存占用指的是：堆上或数组中内存分配的空间大小，栈上的内存分配实现不同。</p><img src="https://s2.loli.net/2024/01/26/72qp8fgIoLhmate.png" alt="image-20240126153922430" style="zoom:33%;" /><p>jvm的栈中的局部变量表用于存储方法的局部变量，局部变量表中的每个槽位（Slot）都有固定的大小，一般为32位，可以容纳一个基本数据类型的值或者一个对象的引用。byte, char, short, boolean, int, float，对象引用占用一个槽位即32位，float，double占用两个槽位。</p><p>jvm的栈中的操作数栈用于存储方法执行过程中的操作数，基本数据类型或者对象引用在操作数栈的存储大小与局部变量表中的存储大小。</p><img src="https://s2.loli.net/2024/01/31/wEOpdax2XqsMK5G.png" alt="image-20240126160335764" style="zoom: 33%;" /><p>我们发现 byte、char、short 和 boolean 类型在局部变量表中占用一个槽位即32位，这样的设计是为权衡性能和存储的考虑：</p><ul><li>性能：利用硬件数据对齐（避免数据类型判断）和处理优势，提高运行时性能</li><li>一致性：保证跨平台的一致性，保证在不同硬件平台的运行</li></ul><h4 id="整数类型转换"><a href="#整数类型转换" class="headerlink" title="整数类型转换"></a>整数类型转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 源代码</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"># 字节码</span><br><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">5</span> iconst_1</span><br><span class="line"> <span class="number">6</span> istore_3</span><br><span class="line"> <span class="number">7</span> iconst_1</span><br><span class="line"> <span class="number">8</span> istore <span class="number">4</span></span><br></pre></td></tr></table></figure><p>上述代码我们发现，boolean、short、boolean 在栈的局部变量表中被当成 int 来处理。这种优化是为了简化指令集和提高性能，避免引入专门的布尔操作指令以简化虚拟机的设计实现，也确保硬件层面执行整数操作更加高效的原则。</p><h4 id="栈和堆的数据加载"><a href="#栈和堆的数据加载" class="headerlink" title="栈和堆的数据加载"></a>栈和堆的数据加载</h4><ul><li>堆上的数据加载到栈上：栈上的占用空间大于等于堆上的占用空间<ul><li>无符号位 boolean char：低位复制，高位补0</li><li>有符号位 byte short：底位复制，高位非负补0，负数补1</li></ul></li><li>栈上的数据加载到堆上：堆上的占用空间小于栈上的占用空间<ul><li>高位清除，低位复制（boolean 只复制最后一位）</li></ul></li></ul><h3 id="堆的数据存储"><a href="#堆的数据存储" class="headerlink" title="堆的数据存储"></a>堆的数据存储</h3><p>使用new关键字创建对象时，创建的对象都存储在jvm堆内存中，下面将介绍一下对象在堆内存中的结构和占用大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;     <span class="comment">// 基本类型long占用8字节</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 基本类型int占用4字节</span></span><br><span class="line">  <span class="keyword">private</span> String name; <span class="comment">// 引用数据类型 一个指针存储对象地址 64位虚拟机占用8字节 32位占用4字节</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Student 对象实例</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.in.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类的属性占用 20字节，但是使用visualvm采样 (Sampler-&gt;Memory) 内存直方图时，发现Student实例实际占用了32字节 </p><p><img src="https://s2.loli.net/2024/01/31/UYRSfAlPpzDvc8M.png" alt="image-20240131135247049"></p><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>对象在堆中的<strong>内存布局</strong>：对象在堆中存放时的各个组成部分和存储结构。</p><p>对象分为普通对象和数组对象，存储结构图如下：</p><img src="https://s2.loli.net/2024/01/27/alEwxVcdYsKbriT.png" alt="image-20240127152803178" style="zoom: 33%;" /><h5 id="对象的组成部分"><a href="#对象的组成部分" class="headerlink" title="对象的组成部分"></a>对象的组成部分</h5><ul><li><p>对象头 - Object Header：存放标记字段 Mark Word 和元信息指针 Kclass pointer</p><ul><li><p>标记字段 Mark Word：存储垃圾收集和锁定机制的关键基本信息，64位虚拟机里占用8字节（区分是否开启压缩指针），32位虚拟机占用4字节</p><ul><li><p>标记字段在不同的对象状态（锁状态和垃圾回收状态）下存放的内存不同</p><img src="https://s2.loli.net/2024/01/31/ZudBgs3RpqmMi9E.png" alt="image-20240131142630210" style="zoom:33%;" /></li></ul></li><li><p>元数据指针 Kclass pointer：指向方法区的InstanceKlass对象，用于运行时查看对象的类型信息，以便于方法调用和字段访问等操作。指针占用64位占用8字节</p><img src="https://s2.loli.net/2024/01/31/TkfxX3MacysVrwj.png" alt="image-20240131151003774" style="zoom: 33%;" /></li></ul></li></ul><ul><li>对象数据：存放对象包含其字段（成员变量）的实际数据</li><li>对齐填充 padding：内存大小向上取整添加一些额外的字节对象的末尾，用于内存对齐<ul><li>填充字节通常不包含实际数据，只是为了确保对象在内存中的地址是按照特定的规则对齐的</li></ul></li></ul><p>如果是数组对象，对象的对象头中还包含了一个数组长度：</p><ul><li>数组长度：用于快速获取数组的长度</li></ul><p>了解对象的内存布局后，发现student实例的大小应该是 8 + 8 + 20 = 36 &gt; 32，这是由于<strong>压缩指针</strong>的造成的。</p><h5 id="JOL查看内存布局"><a href="#JOL查看内存布局" class="headerlink" title="JOL查看内存布局"></a>JOL查看内存布局</h5><blockquote><p>JOL 是用于分析JVM中对象内存布局的工具，它使用了UNSAFE、JVMTI和Serviceability Agent等虚拟机技术分析对象在堆内存中的布局。</p></blockquote><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打印内存布局</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// 调用hashcode方法 hashcode的结果将会被保存到对象头中mark word中</span></span><br><span class="line">System.out.println(Integer.toBinaryString(student.hashCode()));</span><br><span class="line">System.out.println(ClassLayout.parseInstance(student).toPrintable());</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/01/31/FZ1XUycYKANnxCQ.png" alt="image-20240131144502349" style="zoom:33%;" /><p>可以看到对象头的大小为8+4=12字节，这是因为JDK8默认开启了指针压缩</p><p>添加参数虚拟机参数 -XX:-UseCompressedOops 关闭压缩指针</p><img src="https://s2.loli.net/2024/01/31/DHAwN2osixSgjLu.png" alt="image-20240131150416992" style="zoom:33%;" /><p>关闭指针压缩后，对象头大小为16字节</p><h5 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h5><p>在64位虚拟机中引用指针占用 8字节，因为8字节可以寻址的范围是2的64次方，由于大多数应用程序不会接近使用接近2^64个不同的对象地址即使用大小为16777216 TB，这意味着许多位在实际应用中是浪费的， jvm为了减少这部分的内存使用量。jvm 使用了指针压缩技术，将引用指针从 8个字节的 压缩成 4个字节，此功能默认开启，可以使用 -XX:-UseCompressedOops 关闭压缩指针。</p><img src="https://s2.loli.net/2024/01/31/4WlT91y3RsuNfqX.png" alt="image-20240131152154281" style="zoom:33%;" /><h6 id="指针压缩实现"><a href="#指针压缩实现" class="headerlink" title="指针压缩实现"></a>指针压缩实现</h6><p>指针压缩的思想就是将寻址的单位放大。在不使用指针压缩的情况下，64位系统上的每个指针都可以直接寻址到1字节的精度 即 每个指针都能够独立指向内存中的每个字节。当启用指针压缩时，一个指针不再是直接寻址到单个字节，而是寻址到一个更大的单位，例如8个字节，这些较大的单位看作是内存中的“槽”，每个槽位的大小为8字节，从0开始进行编号，指针将存储这些编号，此时对象的真实地址等于编号*8。</p><img src="https://s2.loli.net/2024/01/31/v8wrcHIQkWXognd.png" alt="image-20240131153412785" style="zoom:25%;" /><h6 id="指针压缩的问题"><a href="#指针压缩的问题" class="headerlink" title="指针压缩的问题"></a>指针压缩的问题</h6><p>指针压缩将指针的占用的大小变小，但是有带来了两个问题：</p><ul><li><p>不足“槽”内存大小的对象需要进行内存对齐填充</p><p>将对象的填充至8字节的倍数，存在部分空间浪费（但是对于Hotspot虚拟机，即使不开启指针压缩，对象也需要进行内存对齐）。</p></li><li><p>寻址大小最多支持2的35次方即内存大小最大为32GB（如果堆内存超过32GB时，指针压缩将会自动关闭）</p><p>不开启指针压缩，寻址范围可以达到2的64次方；当使用指针压缩时，每个“槽”占用8字节，此时内存的最大大小为 2的32次方 * 8 = 2的35次方位即32gb</p></li></ul><h5 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h5><p>在对比开启指针压缩和未开启指针压缩的两种情况下， 我们发现：在对象数据中都发生了内存填充 </p><blockquote><p>内存对齐主要目的是 为了解决并发情况下，cpu缓存失效的问题。</p></blockquote><p>计算机引入了cpu缓存，加快了数据读取速度，cpu缓存由缓存行组成，64位虚拟机每个缓存行的大小为8字节，int 默认占用的内存大小为 4字节，一个缓存行可以存放两个int，此时，假设一个缓存行里存放了两个int类型的值：A对象的int和B对象的int，此时A对象的int数据发生了变化，需要对这个数据所在缓存行进行剔除，重新从内存中的加载，这时会发生B对象缓存失效的问题，也需要重新从内存中进行加载。导致这类的问题的核心原因是，两个数据在同一个缓存行中存放，导致A的写操作导致B数据的读操作效率降低。</p><img src="https://s2.loli.net/2024/02/01/bgU7l5AFWtGMiPy.png" alt="image-20240201113438038" style="zoom:33%;" /><p>引入内存对齐后，避免了同一个缓存行的存放两个不同对象的情况，这样当一个对象的缓存行失效后，不会影响其他对象，优化cpu缓存行的性能。</p><img src="https://s2.loli.net/2024/02/01/EbhPgeGNxTAutJX.png" alt="image-20240201114302456" style="zoom:33%;" /><p> 因此内存对齐要求最终内存占用的字节数量需要被8整除。</p><h5 id="字段重排列"><a href="#字段重排列" class="headerlink" title="字段重排列"></a>字段重排列</h5><blockquote><p>字段重排序是编译器为了优化数据结构，改变字段在内存中的排列顺序，以确保每个属性的偏移量offset为字段长度的四倍，以确保字段之间的对齐，减少由于内存对齐导致的填充。</p></blockquote><img src="https://s2.loli.net/2024/02/01/Et1veNzPTirISFc.png" alt="image-20240201151046424" style="zoom:33%;" /><p>上图中，int类型属性排到了long类型属性的后面，这样int类型被存储在和 kclass pointer 一样的缓存行中，避免了 long 类型分配在两个不同的缓存行中，提高了读取和写入缓存行的效率。</p><p><img src="https://s2.loli.net/2024/02/01/4D3TdJeSpO2t9xW.png" alt="image-20240201151237394"></p><p>但是需要注意的是，jvm 默认对象类型的整数即对象引用的地址，必须存储在基本数据类型之后，这时候无法使用字段重排序优化时，只能尝试内存对齐。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>默认开启指针压缩，指针被压缩成了4字节</p></li><li><p>字段重排序要求每个属性的offset要被字段类型占用大小整除，内存对齐要求求最终内存占用的字节数量需要被8整除，提高cpu缓存行的效率</p></li><li><p>子类继承父类的属性，子类在堆内存中会先被布局，属性的顺序和偏移量和父类的内存布局完全一致，然后再会处理自己字段的内存布局</p></li></ul><h2 id="jvm-执行原理"><a href="#jvm-执行原理" class="headerlink" title="jvm 执行原理"></a>jvm 执行原理</h2><h3 id="方法调用原理"><a href="#方法调用原理" class="headerlink" title="方法调用原理"></a>方法调用原理</h3><p>java 方法调用的本质是解释和执行字节码，在方法调用之前会先创建一个栈，栈中的栈帧对应方法调用，栈帧用于存放局部变量表和操作数栈等。</p><p>在 jvm 中，一共有五个字节码指令可以执行方法调用：</p><blockquote><p> invoke 方法的核心作用是 获取方法的字节码指令并执行方法调用</p></blockquote><ul><li>invokestatic：调用静态方法 【静态绑定】</li><li>invokespecial：调用对象的构造方法、私有方法以及其父类实例方法，构造方法以及接口的默认方法 【静态绑定】</li><li>invokevirtual：调用对象的非private方法 【动态绑定】</li><li>invokeinterface：调用接口对象方法 【动态绑定】</li><li>invokedynamic：调用动态方法，主要应用于 Lambda 表达式等</li></ul><p>invoke指令获取的方法字节码指令存放在 方法区中的 instanceKlass 中，实现方法定位的方式有两种：静态绑定和动态绑定</p><h4 id="方法定位"><a href="#方法定位" class="headerlink" title="方法定位"></a>方法定位</h4><h5 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h5><p>在编译期间，invoke指令会携带一个 <strong>参数符号引用</strong>，它引用到方法区中常量池中的方法定义，方法定义中包含了 类名、方法名、方法值、参数。这个 参数符号引用指向方法区中的常量池方法定义信息，但是我们需要找到的是 方法区中 instanceKlass 的方法字节码。因此在方法第一次调用时，会将符号引用替换为内存地址的直接引用，此过程就是静态绑定。</p><p>静态绑定无法处理方法多态的情况，它只适用于处理静态方法，私有方法或者final修饰的方法，所以 invokestatic、invokespecial、final修饰的invokevirtual 都是通过静态绑定让程序执行指令时，直接获取到在方法区instanceKlass的方法地址获取字节码并执行。</p><img src="https://s2.loli.net/2024/02/01/Dk1KU7u5sBpPy8L.png" alt="image-20240201155538748" style="zoom:50%;" /><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p>对于存在子类重写可能的方法，例如 非static、非private、非final 等方法，就需要通过 <strong>动态绑定</strong> 来完成方法地址的绑定，以实现多态。</p><h6 id="动态绑定的实现"><a href="#动态绑定的实现" class="headerlink" title="动态绑定的实现"></a>动态绑定的实现</h6><blockquote><p>动态绑定是基于 方法表 完成，invokevirtual使用了虚方法表（vtable），invokeinterface使用了接口方法表 (itable)，整体思路一致。</p></blockquote><p>每个类都有一个虚方法表，本质上是一个数组，数组中存储了指针，记录了方法的地址。子类方法表中包含父类方法表中的所有方法；子类如果重写了父类方法，则使用子类自己类中方法的地址进行<strong>替换</strong>。</p><img src="https://s2.loli.net/2024/02/02/Uvu5cklDMV6Egr9.png" alt="image-20240202111224527" style="zoom:33%;" /><p>invokevirtual调用时，会先根据对象头中的类型指针Klass pointer找到方法区中的instanceClass对象，从中找到虚方法表，从虚方法表中获取对应的方法地址并获取字节码执行。</p><img src="https://s2.loli.net/2024/02/02/LBNndt7ZWVka1J3.png" alt="image-20240202111321646" style="zoom:33%;" /><h3 id="异常捕获原理"><a href="#异常捕获原理" class="headerlink" title="异常捕获原理"></a>异常捕获原理</h3><blockquote><p>在java中，程序遇到异常时会向外抛出，此时可以使用 try-catch 捕获异常的方式将异常捕获并继续让程序指定累计运行。</p><p>jvm 实现的 try-catch 的异常捕获机制需要实现亮点：识别异常（异常类型）和处理异常（跳转异常处理指令）</p></blockquote><p>异常捕获机制实现，需要借助编译时生产的 <strong>异常表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//... </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h4><p>异常表在编译期生成，存放是代码中异常的处理信息，包括了异常捕获的<strong>生效范围</strong>以及异常发生后跳转的<strong>异常处理</strong>字节码<strong>指令位置</strong>，用于处理方法中可能抛出的异常。</p><h5 id="异常表的组成"><a href="#异常表的组成" class="headerlink" title="异常表的组成"></a>异常表的组成</h5><blockquote><p>异常表是一个数组</p></blockquote><ul><li>number：数组下标</li><li>start/end pc：异常捕获生效的字节码起点/结束位置-try代码块的指令</li><li>handler pc：异常捕获后跳转的处理异常字节码的位置</li><li>catch_type：捕获的异常类型</li></ul><img src="https://s2.loli.net/2024/02/02/HOGgMoZB1xcj5bR.png" alt="image-20240202160745959" style="zoom:33%;" /><h5 id="异常捕获的原理"><a href="#异常捕获的原理" class="headerlink" title="异常捕获的原理"></a>异常捕获的原理</h5><h6 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h6><blockquote><p>当程序运行过程中触发异常时，jvm 会从上到下遍历异常表的中的所有数组，当捕获的异常在字节码的索引值在异常表中的数组的生效范围内，则jvm会判断所捕获的异常是否和方法表中的异常一致（包括属于其子类）：</p><ul><li>如果一致，跳转到 handler pc 所对应的字节码的位置</li><li>如果不一致，则继续遍历数组，如果没有发现匹配的，则说明异常无法在当前方法执行后被捕获，方法栈帧直接弹出，尝试在上一次方法的栈帧中进行异常处理即交给方法的调用方法处理。</li></ul></blockquote><p>多catch分支处理或者catch中有多个异常（multi-catch）的情况下：异常表会有多个数组，数组中异常的顺序和声明的顺序一致。</p><p>如下示例中，先匹配RuntimeException 再匹配IOException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException | IOException e) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/02/02/VNUvZd6iXF3qnYK.png" alt="image-20240202161945452" style="zoom:50%;" /><h6 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h6><p>finally 代码块中的字节码指令是 <strong>一定会被执行</strong> 的，它的处理方式分为以下几步：</p><ul><li><p>finally 代码块中的字节码指令会插入到 try 和 catch 代码块中，以保证在 try 和 catch 之后一定会执行 finally 中的代码</p></li><li><p>在上述基础上，如果捕获的异常不在异常表中或者catch代码块中又发生了异常，只依靠上述情况无法做到让finally代码块中的内容必须执行。因此异常表添加了两个数组，分别以try和catch代码块的字节码为生效范围，any作为捕获异常的类型，any代表所有异常，handler pc跳转的指令为 执行finally方法指令并继续将异常往上抛出。</p><img src="https://s2.loli.net/2024/02/02/yElgO1CumdfYo5i.png" alt="image-20240202163452698" style="zoom:33%;" /></li></ul><h2 id="JIT-即时编译器"><a href="#JIT-即时编译器" class="headerlink" title="JIT 即时编译器"></a>JIT 即时编译器</h2><blockquote><p>jvm 运行java程序的过程：将java的源代码文件编译成字节码文件，然后通过类加载器加字节码指令加载到内存中，再通过 jvm 的解释器将字节码指令解释成对应平台的机器码交给计算机执行。</p><p>在上述过程中，解释器需要一定的时间将字节码文件解释成机器码，这会影响java程序执行的性能。</p><p>JIT 即时编译器会将执行频率较高的代码（经常执行的循环或是频繁调用的方法）标记为热点代码，热点代码将字节码编译成针对特定硬件平台<strong>优化</strong>的机器码并<strong>保存在内存</strong>中。当下次执行到热点代码时，jvm 将直接执行这些优化后的机器码，而不是再次解释执行字节码。</p><p>JIT 的主要作用：标识热点代码并保存其字节码到内存中；优化热点代码</p></blockquote><h3 id="JIT-即时编译器类型"><a href="#JIT-即时编译器类型" class="headerlink" title="JIT 即时编译器类型"></a>JIT 即时编译器类型</h3><p>在 Hotspot 虚拟机中，有三款即时编译器：C1、C2 和 Graal（Graal在GraalVM上）</p><p>C1 编译效率比 C2 快，但是优化效果不如 C2，C1 适合优化执行代码较短的代码，C2 适用于服务端长期执行的代码。</p><p>目前 Hotspot 虚拟机中，C1 和 C2 会协同工作，如下图（注意：jvm 发现优化并保存的字节码执行效率不如之前的话，会对于之前字节码进行取消优化）：</p><img src="https://s2.loli.net/2024/02/02/eaSBFiZT2I49dkM.png" alt="image-20240202170448285" style="zoom: 25%;" /><h3 id="JIT-分层编译"><a href="#JIT-分层编译" class="headerlink" title="JIT 分层编译"></a>JIT 分层编译</h3><p>JDK7后，jvm 采用了分层编译的方式，让c1和c2会协同发挥作用，分层编译让程序的优化级别分为了5个等级</p><p>在jvm执行字节码的执行过程中，会处于其中的某一个等级，满足一些特定情况下，会从一个等级跳转到另外一个等级。</p><img src="https://s2.loli.net/2024/02/02/6vEAHZPhqabuzT1.png" alt="image-20240202170838166" style="zoom: 25%;" /><p>即时编译采用独立的线程处理（不会占用用户线程），jvm内部会保存一个队列用于存放需要编译优化的任务（当方法或者循环调用次数达到一定次数后，这些字节码指令会被当成编译任务放入到队列中），编译任务完成后会将编译优化的机器码放入到内存中。</p><img src="https://s2.loli.net/2024/02/03/BXTcaZ3e2nKkr1L.png" alt="image-20240202172427877" style="zoom:33%;" /><h4 id="编译器协同工作"><a href="#编译器协同工作" class="headerlink" title="编译器协同工作"></a>编译器协同工作</h4><blockquote><p>JIT 即时编译器是 递进和互补的关系。</p></blockquote><ul><li><p>正常情况，初始由解释器进行解释，优化等级为0；随后交由 C1 编译器进行优化，优化等级为3 ，C1 执行过程中，手机运行信息（例如方法执行次数，循环执行次数，分支执行次数等）。然后等待执行次数达到阈值时，进入 C2 编译器进行深层次的优化，优化等级为4</p><p><img src="https://s2.loli.net/2024/02/03/nxNosV8zDjFkmMf.png" alt="image-20240203093523188"></p></li><li><p>如果方法中的字节码较少，jvm 收集信息并判断c1和c2优化性能相差无几，则直接由C1进行优化，避免信息收集带来的性能损耗</p><p><img src="https://s2.loli.net/2024/02/03/O1dz8lUJ3Bw6oFu.png" alt="image-20240203093739957"></p></li><li><p>C1 线程都在忙碌的情况下，会直接交给C2进行优化</p><p><img src="https://s2.loli.net/2024/02/03/t7uRpryhs8ob4YL.png" alt="image-20240203093816581"></p></li><li><p>C2 线程都在忙碌的情况下，会先让2级C1编译收集信息，多运行一会儿，然后再交由3级C1处理，等待C2线程不忙碌后，交给C2优化。（注意：3级C1的处理效率不高，所以在等待C2的过程中，会来回在3级和2级C1的转换）</p><p><img src="https://s2.loli.net/2024/02/03/GDprxhsdMm9wabg.png" alt="image-20240203094126497"></p></li></ul><h3 id="JIT-编译器优化方式"><a href="#JIT-编译器优化方式" class="headerlink" title="JIT 编译器优化方式"></a>JIT 编译器优化方式</h3><blockquote><p>JIT 即时编译器的优化手段有 <strong>方法内联</strong> 和 <strong>逃逸分析</strong></p></blockquote><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><blockquote><p>方法内联 - method inline：将一个方法的调用的字节码指令直接复制到调用方的字节码指令，减少方法调用的开销（包括管理栈帧的开销、参数传递和返回值处理等）。</p></blockquote><img src="https://s2.loli.net/2024/02/03/eAb9GZqDp6yB745.png" alt="image-20240203095424757" style="zoom:33%;" /><h5 id="方法内联限制"><a href="#方法内联限制" class="headerlink" title="方法内联限制"></a>方法内联限制</h5><p>方法内联需要一定的条件</p><ul><li>方法编译后的字节码指令总大小 &lt; 35 字节（通过-XX:MaxInlineSize=值 控制），可以直接内联</li><li>方法编译后的字节码指令总大小 &lt; 325 字节（通过-XX:FreqInlineSize=值 控制） 并且是一个热点方法 </li><li>方法编译生成的机器码 &lt;= 1000 字节（通过-XX:InlineSmallCode=值 控制）</li><li>一个接口实现必须 &lt;= 3 如果 &gt;3 则不会发生内联</li></ul><p>所以代码编写尽可能要简单，尽量让方法内联生效，提高程序性能。</p><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><blockquote><p>逃逸分析 - escape analysis：JIT 即时编译阶段，分析对象的作用域和生命周期，保证对象只在方法内被使用，不会被外部对象引用。逃逸分析的两个重要的应用：锁消除和标量替换。</p></blockquote><h5 id="逃逸分析应用"><a href="#逃逸分析应用" class="headerlink" title="逃逸分析应用"></a>逃逸分析应用</h5><h6 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h6><p>逃逸分析确定某个对象的访问是线程局部的即对象不会逃逸到方法或线程之外时，它不会存在竞争的条件，对于这个对象的同步（synchronized blocks）操作实际上是不必要的，在这种情况下，jvm 可以安全的消除这些同步操作，从而减少同步带来的开销。</p><h6 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h6><p>标量替换的思想是指将一个聚合类型（如对象）分解为若干个独立的标量类型（如基本类型字段）。如果方法中的对象不会逃逸，那 jvm 可以不在堆上分配这个对象的内存，而是将对象的各个字段作为独立的局部变量在栈上分配。这样可以堆内存的分配和回收压力，并且提高访问的效率。</p><h4 id="JIT-优化建议"><a href="#JIT-优化建议" class="headerlink" title="JIT 优化建议"></a>JIT 优化建议</h4><p>根据JIT即时编译器优化代码的特性，编写代码需要注意以下几个事项，让代码更好的被JIT即时编译优化：</p><ul><li>代码编写尽可能要越简单越小，尽量让方法内联生效</li><li>减少接口的实现数量，尽量不超过3个，否则影响内联的处理</li><li>高频调用的方法创建对象临时使用，尽量保证不要让对象逃逸，让JIT优化为标量替换</li></ul><h2 id="垃圾回收原理"><a href="#垃圾回收原理" class="headerlink" title="垃圾回收原理"></a>垃圾回收原理</h2><h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p>G1 垃圾回收器将整个堆内存划分为相同大小的region区域，这些区域根据需求可以作为不同的分代空间，可以被划分为年轻代（Young Generation）、老年代（Old Generation）以及用于存放大对象的特殊区域（Humongous Regions）。G1采用 分代垃圾回收机制，垃圾回收有两种方式：young gc 和 mixed gc(所有年轻代和部分老年代)</p><ul><li>major gc：<ul><li>时机：当年轻代区域不足（年轻代区域的默认最大大小为总内存的60%）无法分配对象时，则需要执行young gc</li><li>过程：标记年轻代区域（eden和survivor区中的存活对象），根据配置的最大暂停时间选择部分区域的存活对象复制到一个新的survivor区中并且年龄加一，清空这部分区域。</li></ul></li><li>mixed gc：当整个堆的占有率达到了阈值时(默认45%，配置-XX:InitalingHeapOccupancyPercent)触发混合回收mixed gc，回收所有年轻代和部分老年代（包括humongous区），采用复制算法。回收部分老年代的目标是 保证最大暂停时间。</li></ul><img src="https://s2.loli.net/2024/02/03/ZFe5UkVf9GIj4Tn.png" alt="image-20240203104445459" style="zoom:33%;" /><p>流程如下可见基础篇</p><h4 id="G1-垃圾回收器的核心技术"><a href="#G1-垃圾回收器的核心技术" class="headerlink" title="G1 垃圾回收器的核心技术"></a>G1 垃圾回收器的核心技术</h4><h5 id="年轻代回收"><a href="#年轻代回收" class="headerlink" title="年轻代回收"></a>年轻代回收</h5><p>年轻代回收需要扫描和标记出年轻代区域（eden + survivor）的存活对象，但是如果只扫描GC Root到年轻代对象的引用链，此时 老年代中存在对象引用年轻代中的部分对象，而这些对象不能被回收。如果扫描GC Root到所有的对象的引用链，遍历引用链的所有对象，可以精确的标记出所有存活的对象，但是会增加大量的对象扫描和标记的时间，效率较低。</p><img src="https://s2.loli.net/2024/02/03/e4OTC8cLFhbvIU7.png" alt="image-20240203133154875" style="zoom:25%;" /><p>因此jvm需要对此进行优化，优化方案为维护一个详细的表，记录哪一部分的对象被老年代引用，这些对象不能进行回收。</p><img src="https://s2.loli.net/2024/02/03/gBhJsAOrCQFVbNq.png" alt="image-20240203133435047" style="zoom:25%;" /><p>但是如果存在eden区存在大量对象被老年代所引用，这个详情引用表的数据将会变得非常大，同时也存在一定的问题，比如上图中，年轻代对象F虽然被老年代对象A引用，但是对象A已经不在GC Root上了，此时F对象依旧在引用详情表上，在年轻代垃圾回收时，年轻代对象F不能被回收。</p><h6 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h6><p>上述方案进行一次优化，引用详情表放置到每个region中，记录非收集区域对象（这里是 Old区）引用了收集区域对象（这里是 Eden区或Survior区）的数据结构（如下图所示），这样结构节省了被引用的收集区域对象的地址的空间。</p><p>在扫描时，将记忆集中的对象加入到GC Root中进行扫描，就可以根据引用链判断收集区域的对象是否被非收集区域引用。</p><img src="https://s2.loli.net/2024/02/03/pWDGRUir7taIjoV.png" alt="image-20240203134651210" style="zoom: 25%;" /><p>这样的引用记录表被称之为 记忆集 - RememberedSet(简称 RS)，它记录了每个region中的引用了该区域的非收集区域的对象集合。</p><p>在扫描标记时，将记忆集中的对象加入到GC Root中，扫描它们的引用链时，判断收集区域对象是存活的。</p><p>在此基础上，可以将所有的区域按照一定的大小划分为很多块，对于每个块进行编号，将记忆表中的地址使用编号进行替换，节省内存开销。</p><h6 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h6><p>再次进行优化，将所有区域中的内存按照一定的大小划分为很多的块并且每个块进行编号，其中每个块可以存放多个对象。此时，记忆集中只记录对块的引用关系。如果一个块中有多个对象，则只需要引用一次，从而减少了内存开销。</p><p><img src="https://s2.loli.net/2024/02/17/TuGFabDsyvNzMjU.png" alt="image-20240217204540869"></p><p>块的实现是通过卡表 - Card Table来实现，每个region都有一个卡表，它的底层数据结构就是一个字节数组。将整个堆内存空间划分成每512个字节为一个小块（被称之为Card Page)后，每个区域的卡表使用一个字节标记映射的块中是否存在对象引用了该region区域中的对象。如下图，对象A引用对象F，对象F位于Region1年轻代中，对象A位于Region2老年代中，此时产生了跨代引用 - 老年代引用年轻代，此时region1的卡表的对应位置的字节内容则进行修改为0，表示被引用，称之为 脏卡。</p><p><img src="https://s2.loli.net/2024/02/18/obxisz6Nt7ZThmF.png" alt="image-20240218082902449"></p><p>这样可以标记出当前region被老年代中的哪些部分引用，只需要遍历卡表，找到所有脏卡并添加到记忆集中，更易于生成记忆集。通过卡表构建的记忆集，保存的数据比较少，节省了很大的内存空间。</p><p><img src="https://s2.loli.net/2024/02/18/qguwh4iAUeFc6pv.png" alt="image-20240218083953884"></p><p>在年轻代进行垃圾回收时，会将记忆集中的对象也加入到GC Root对象中，进行扫描并标记其引用链上的对象。</p><h6 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h6><p>在跨代引用时，需要将对应卡表的位置标记为脏卡，jvm采用写屏障（write barrier）技术，使用该技术在执行引用关系建立的代码时，在该代码执行之前或者之后插入一段指令，从而维护卡表。</p><p>被插入的指令用于判断是否发生跨代的引用关系建立，如果是则修改对应卡表的位置为脏卡。</p><p><img src="https://s2.loli.net/2024/02/18/s2KjQAmdihxHyv7.png" alt="image-20240218084644395"></p><h6 id="记忆集合生成流程"><a href="#记忆集合生成流程" class="headerlink" title="记忆集合生成流程"></a>记忆集合生成流程</h6><p>记忆集的生成流程如下：</p><ul><li>通过写屏障判断引用关系变更的信息并标记到卡表中</li><li>如果标记为脏卡则记录到一个脏卡队列中，由jvm提供的单独的refinement线程定期从脏卡队列中获取数据并生成记忆集</li></ul><img src="https://s2.loli.net/2024/02/18/P6ZhyKIR49xqueL.png" alt="image-20240218085417416" style="zoom:33%;" /><p>不直接写入的记忆集而采用队列异步的原因：避免过多用户线程并发访问记忆集，从而对于共享资源加锁的操作造成性能消耗，导致用户线程阻塞。</p><h6 id="年轻代回收流程"><a href="#年轻代回收流程" class="headerlink" title="年轻代回收流程"></a>年轻代回收流程</h6><p>g1 年轻代垃圾回收的整个过程是 STW 的。</p><ul><li>将所有的静态变量和局部变量加入到GC Root中</li><li>使用GC线程协助处理脏卡队列中的信息，更新记忆集，生产最终的记忆集</li><li>将记忆集中的对象加入到GC Root中，扫描GC Root引用链并标记存活对象</li><li>根据设置的最大停顿时间，选择收集部分区域（称之为回收集合-Collection Set）</li><li>复制存活对象并将对象的年龄加一，如果对象的年龄达到15则晋升为老年代，之前的空间直接清空</li><li>处理软、弱、虚、终结器引用以及JNI中的弱引用</li></ul><h6 id="年轻代回收核心技术总结"><a href="#年轻代回收核心技术总结" class="headerlink" title="年轻代回收核心技术总结"></a>年轻代回收核心技术总结</h6><ul><li>卡表 - Card Table</li></ul><p>每个region区域都有自己对应的卡表，卡表本质上是一个字节数组，如果对象引用关系发生了跨代引用，则卡表上引用对象所在位置字节内容进行修改为0即标记为脏卡。卡表的主要作用是用于 生成记忆集，让记忆集占用更少的内存空间。</p><p>卡表会占用一定的内存空间，堆大小为1g时，卡表的大小为 1g/512 = 2mb </p><ul><li>记忆集 - RememberedSet (简称为 RS)</li></ul><p>每个region区域都有自己的记忆集，如果产生了跨代引用，记忆集会记录引用对象所在卡表的位置即卡表数组的下标。在标记阶段，记忆集中的对象加入到GC Root集合中一起扫描和标记</p><ul><li>写屏障 - Write Barrier </li></ul><p>g1 采用写屏障技术，在引用关系建立执行的代码之前或者之后加入一段指令用于完成卡表的维护工作，此过程会带来一部分的性能开销，大约在5%-10%之间</p><h5 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h5><p>在总堆的占用率达到了阈值（默认为45%）时会触发混合回收 mixed gc。</p><p>混合回收会在年轻代回收之后或者大对象分配之后触发，混合回收会回收 整个年轻代和部分老年代（包括humongous区域）。</p><p>由于老年代中会有大量的对象，标记所有的存活对象耗时较长，在整个标记过程要尽量保证垃圾回收线程和用户线程并行执行。</p><h6 id="混合回收的步骤"><a href="#混合回收的步骤" class="headerlink" title="混合回收的步骤"></a>混合回收的步骤</h6><ul><li>初始标记：STW 采用三色标记法标记 GC Root 直达的对象</li><li>并发标记：并发执行，扫描GC Root引用链，对存活的对象进行标记 - 从灰色队列中取出被标记为灰色的对象继续往下标记，可能出现错标的情况，将引用断开并且在存在于初始快照的对象放入到 SATB 的队列中。</li><li>最终标记：STW 处理 SATB 相关的对象标记 - 将 SATB队列中的对象全部标记为存活并往下继续扫描和标记</li><li>清理：STW 清空没有任何存活对象的区域</li><li>复制：将存活对象复制到新的区域并重新建立它们的引用关系</li></ul><h6 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h6><p>初始标记会暂停所有用户线程，只标记GC Root可直达的对象，停顿时间较短。</p><p>标记过程采用三色标记法进行，三色标记法在原有双色标记（黑色为1代表存活，白色为0代表可回收）的基础上增加了一种灰色，灰色的对象会被添加到特殊的灰色队列中进行处理：</p><ul><li>黑色 - 存活：当前对象在GC Root引用链上，同时它引用的其他对象已经被标记完成</li><li>灰色 - 待处理：当前对象在GC Root引用链上，它引用的其他对象还没有标记完成</li><li>白色 - 可回收：不在GC Root引用链上</li></ul><p>注意：每一个对象的初始颜色都是白色</p><p><img src="https://s2.loli.net/2024/02/18/yoEaDFspA8TOPtg.png" alt="image-20240218100131599"></p><p>三色标记法中，灰色采用一个队列进行保存，而黑色和白色采用bitmap位图的方式来实现，比如每8个字节使用1bit来标识标记的内容，黑色为1，白色为0，如果对象超过8字节，则使用bit位的第一位标记。灰色不会体现在位图上，而是会放入单独的一个队列中进行维护。</p><p><img src="https://s2.loli.net/2024/02/18/9uoNskGnLygI4i7.png" alt="image-20240218100638713"></p><h6 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h6><p>并发标记阶段，垃圾回收线程和用户线程并发执行。从灰色队列中获取尚未完成标记的对象，继续进行扫描和标记。</p><p><img src="https://s2.loli.net/2024/02/18/dWbSIuflzX7sjpm.png"></p><p>但是三色标记法标记过程中，存在一个问题，由于用户线程同时执行时，可能会修改对象的引用关系，导致出现错标的情况。</p><p><img src="https://s2.loli.net/2024/02/18/neAdktS1IKDgMWz.png" alt="image-20240218101108862"></p><p>上述情况下，对象b被继续弹出队列进行处理，处理完成标记为黑色，而对象c被对象a引用，对象a为黑色不需要处理，对象c发生了错标的情况，会导致对象c可能被回收掉。</p><blockquote><p>g1 垃圾回收器采用了SATB - Shapshot at the beginning 初始快照技术解决这种问题</p><ul><li>标记开始前创建一个快照，记录当前所有对象</li><li>标记过程中新创建的对象直接标记为黑色</li><li>采用前置写屏障技术，在对象引用赋值前，判断对象是否存在于初始快照中，如果存在则该将之前引用的对象放入到SATB待处理队列中，SATB队列每个线程都有一个，但在最终标记阶段会被合并到一个合并SATB队列中</li></ul></blockquote><h6 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h6><p>最终标记阶段暂停所有用户线程，主要处理SATB相关的对象标记。</p><p>在这个过程中，所有线程的SATB队列中剩余的数据会被合并到总的SATB队列中处理，SATB队列中的对象，默认按照存活处理，同时需要处理它们的引用对象。</p><p>SATB技术保证 标记前初始快照存在的对象，在标记阶段引用链被断开，这个对象也能在这一轮垃圾回收不被回收，同时新创建的对象也不会在这一轮被回收。</p><p>SATB的优点是效率非常高，只需要将队列中的对象标记为存活并继续往下标记即可，缺点是在该轮处理时，有可能将不存活的对象标记为存活对象，产生浮动垃圾，需要等待下一轮处理才能回收。</p><h6 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h6><ul><li>根据最终标记的结果，计算出每个区域垃圾对象占用内存的大小，结合停顿时间，选择转移效率最高（垃圾最多的区域）的部分区域进行转移和回收</li><li>首先先复制GC Root直接引用的对象，然后再复制其他对象，并重新建立引用关系</li><li>清空掉之前的区域</li></ul><h3 id="ZGC垃圾回收器"><a href="#ZGC垃圾回收器" class="headerlink" title="ZGC垃圾回收器"></a>ZGC垃圾回收器</h3><h3 id="ShenandoahGC垃圾回收器"><a href="#ShenandoahGC垃圾回收器" class="headerlink" title="ShenandoahGC垃圾回收器"></a>ShenandoahGC垃圾回收器</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm-原理&quot;&gt;&lt;a href=&quot;#jvm-原理&quot; class=&quot;headerlink&quot; title=&quot;jvm 原理&quot;&gt;&lt;/a&gt;jvm 原理&lt;/h1&gt;&lt;h2 id=&quot;jvm-数据存储&quot;&gt;&lt;a href=&quot;#jvm-数据存储&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JUC 并发编程 (一) 基础</title>
    <link href="http://example.com/2023/01/26/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/01/26/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/</id>
    <published>2023-01-25T16:00:00.000Z</published>
    <updated>2024-03-12T02:31:33.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-并发编程"><a href="#JUC-并发编程" class="headerlink" title="JUC 并发编程"></a>JUC 并发编程</h1><h2 id="多线程的引入"><a href="#多线程的引入" class="headerlink" title="多线程的引入"></a>多线程的引入</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>进程（process）是计算机中运行的程序一个实例。进程之间有相互独立的内存空间，每个进程有自己的地址空间、指令、数据、系统资源等。</p><p>线程（thread）是进程中的一个执行单元，一个进程中包括了多个线程，它们共享了相同的内存空间和系统资源。</p><p>现代操作系统将进程作为资源分配和保护的基本单位，将线程作为调度和执行基本单位。</p></blockquote><h4 id="内存和资源"><a href="#内存和资源" class="headerlink" title="内存和资源"></a>内存和资源</h4><blockquote><p>各个进程之间拥有独立的内存空间，同一进程内的线程共享相同的内存空间和资源。</p></blockquote><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><blockquote><p>进程之间的通信需要使用特定的机制，用一台计算机的进程通信称为IPC(Inter-process communication)，不同计算机的之间通信需要通过网络并遵守相应的协议。</p><p>线程之间通信可以通过共享内存进行直接通信，也可以通过java提供的线程间通信机制（wait、notify等）实现通信</p></blockquote><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><blockquote><p>进程的上下文切换的开销要比线程的上下文切换的大很多，因此线程更加轻量。</p></blockquote><h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h4><blockquote><p>进程的创建和销毁开销相对较大，因为每个进程都要分配自己独立的内存空间和资源；</p><p>线程的创建和销毁开销相对较小，因为线程之间共享相同的内存空间和系统资源。</p></blockquote><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>早期单核CPU的运行环境下，线程感观是”同时执行”，但本质上是串行执行的，这是由于操作系统有一个组件叫任务调度器，任务调度器会轮流给每个任务分配执行时间，将cpu的时间片分给不同的线程使用使之交替执行，这些时间片的时间非常短，感观是”同时执行”，本质上是分时执行，简而言之就是：微观串行，宏观并行。</p><blockquote><p>并发 - concurrency：同一时间间隔内交替执行多个任务，这些任务并不是同时进行的，而是在同一个处理多元单元通过快速的切换来实现。</p></blockquote><img src="https://s2.loli.net/2024/01/10/cwgmj5oX7SfaU3V.png" alt="image-20240110140123570" style="zoom:33%;" /><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><blockquote><p>并行 - parallelism：在同一时刻发生多个任务或操作，在多个处理单元上同时执行。</p></blockquote><img src="https://s2.loli.net/2024/01/10/XKwIm4x6TQhVysa.png" alt="image-20240110140156661" style="zoom:33%;" /><p>引用rob pike的一段描述：</p><ul><li>并发是同一时间应对多件事情，而并行同一时间做多件事情</li></ul><h3 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h3><blockquote><p>同步 - asychronous：任务按照顺序依次执行，一个任务的执行需要等待上一个任务的完成</p><p>异步 - synchronous：任务不按照顺序依次执行，任务的完成并不影响接下来的任务立即执行</p></blockquote><h3 id="为什么引入多线程"><a href="#为什么引入多线程" class="headerlink" title="为什么引入多线程"></a>为什么引入多线程</h3><p>在多核处理器流行的当下，多线程可以有效的提升程序的运行效率，多核cpu并行执行多个线程，充分地利用硬件资源。</p><p>注意在单核cpu的机器上，多线程不能实际提高程序的运行效率，反而可能会影响执行效率，因为线程的上下文切换会带来一些性能的损耗。但是单核cpu的多线程，让单核机器有了宏观上应对多个任务的能力。</p><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><blockquote><p>创建Thread对象，重写 run() 方法，然后通过Thread调用 start() 方法来启动线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象 - 匿名内部类 实质上的创建的是线程的子类</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;myThread&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// 覆盖 run 方法，方法里是执行的任务</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程- 线程放入就绪队列中等待任务调度器分配时间片执行，调度时会执行线程中的run方法</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><p>另一种非匿名内部类写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5><blockquote><p> 实现 runnable 接口需要实现其中的 run() 方法，然后通过Thread对象调用 start() 方法来启动线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable, <span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种非匿名内部类写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable, <span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5><blockquote><p>与 Runnable 相比，Callable 可以有返回值，返回值使用 futureTask 进行封装</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    Callable&lt;String&gt; stringCallable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">// 构造 FutureTask 对象，传入 Callable 对象参数</span></span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(stringCallable);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">    myThread.start();</span><br><span class="line">  <span class="comment">// 阻塞等待返回值</span></span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Runnable和Thread源码分析"><a href="#Runnable和Thread源码分析" class="headerlink" title="Runnable和Thread源码分析"></a>Runnable和Thread源码分析</h4><p>Thread类实现了 Runnable 接口, 重写了 run() 方法，</p><p>实现Runnable接口方法：当调用构造函数创建 Thread 对象，传入参数 Runnable 对象，该 Runnable 对象会赋值到 Thread 对象 的 Runnable target 的属性中，当调用 Thread 对象 的 start() 方法时，会执行 target.run()</p><p>继承Thread类方法：当调用构造函数创建 Thread 对象，未传入参数 Runnable 对象，创建的 Thread 对象重写 run() 方法，当调用 Thread 对象 的 start() 方法时，会调用 Thread 对象重写的 run() 方法</p><p>可以简单把 Thread 理解为 线程对象，Runnable 为 任务对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Runnable</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Thread</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Runnable target;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>建议使用实现Runnable接口的方式创建线程：</p><ul><li>将线程对象和任务对象分开，使得任务对象可以更好的组合以及与一些线程池等高级API配合</li><li>任务对象可执行即可，而线程对象整个类的创建的开销比较大</li><li>java不支持多继承，但是支持多接口实现，因此使用实现Runnable接口的方式，可以更好的扩展</li></ul></blockquote><h3 id="jvm-线程原理"><a href="#jvm-线程原理" class="headerlink" title="jvm 线程原理"></a>jvm 线程原理</h3><blockquote><p>jvm 运行时数据区由 堆、方法区、虚拟机栈、本地方法栈和程序计数器组成，栈内存其实就是对应线程所持有的，每个线程启动后，都会为其分配一个对应的栈内存，栈内存是线程私有的，相互独立，互不干扰。每个栈由多个栈帧组成，每个栈帧对应了一次方法调用，每个线程同一时刻只有一个活动栈帧，对应着正在执行的方法。</p></blockquote><img src="https://s2.loli.net/2024/01/10/ZufGw6vNgiLtCme.png" alt="image-20240110165743707" style="zoom: 50%;" /><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><blockquote><p>线程的上下文切换是指CPU从一个线程切换到另一个线程执行的过程，具体而言就是指多线程环境中，操作系统将当前运行的线程上下文保存起来，然后切换到另一个线程的上下文并开始执行。在 jvm 中由程序计数器来记录当前线程下一条字节码指令的地址。</p></blockquote><ul><li>该线程的cpu时间片用完</li><li>线程优先级调度：线程优先级的提高可能导致线程上下文切换。</li><li>等待阻塞：当一个线程因为等待某个事件（如I/O操作、锁、信号量等）而被阻塞</li></ul><blockquote><p>注意：频繁的线程上下文切换会带来性能上的开销</p></blockquote><h3 id="线程常见的方法"><a href="#线程常见的方法" class="headerlink" title="线程常见的方法"></a>线程常见的方法</h3><h4 id="start和run方法"><a href="#start和run方法" class="headerlink" title="start和run方法"></a>start和run方法</h4><ul><li>start()</li></ul><blockquote><p>start 方法用于启动一个新的线程，并在新的线程中调用 run 方法。</p><p>start 方法会创建一个新的线程并使之进入就绪状态，等待操作系统分配CPU时间片这个线程执行 run 方法。</p><p>注意：如果对同一个线程对象多次调用 start 方法，会导致 IllegalThreadStateException 异常。</p></blockquote><ul><li>run()</li></ul><blockquote><p>run 方法是 Thread 类中定义的一个普通方法，它包含了线程执行的代码。</p><p>当直接调用 run 方法时，它会在当前线程中执行，不会创建新的线程，即 run 方法被视为普通方法被调用，不会启动新的线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;current thread 1:&quot;</span> + currentThread());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t1.start();</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;current thread 2:&quot;</span> + currentThread());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t2.run();</span><br><span class="line">  &#125;</span><br><span class="line">  执行结果：</span><br><span class="line">  current thread <span class="number">1</span>:Thread[t1,<span class="number">5</span>,main]</span><br><span class="line">current thread <span class="number">2</span>:Thread[main,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure><h4 id="sleep和yield方法"><a href="#sleep和yield方法" class="headerlink" title="sleep和yield方法"></a>sleep和yield方法</h4><ul><li>sleep</li></ul><blockquote><p>sleep方法是Thread类的静态方法，调用Thread类的sleep方法会让当前线程休眠一段时间，此时线程的状态从 运行状态 切换到 TIMEWAITING-限期等待，线程释放占用的CPU资源并在该时间内不再竞争CPU执行权，让其他线程有机会执行。当休眠时间结束后，线程会重新进入就绪状态，等待分配CPU时间片即不会立即执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 参数为long millis， 表示休眠时间的毫秒数</span></span><br><span class="line">         Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：当一个线程处于睡眠状态（即在 sleep 方法中）时，如果另一个线程调用了被睡眠线程的 interrupt 方法，被睡眠线程会被唤醒，并且会抛出 InterruptedException，该线程会提前结束并进入抛出异常的状态。</p><p>建议：用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>应用：使用while(true)方法连续执行任务时，引入适当的休眠或等待机制，可以防止cpu占用过度。因为该循环会一直执行，不会主动放弃时间片，这种情况被称为”忙等”(Busy Waiting)。注意：具体的休眠时间需要根据应用程序的需求来调整。太短的休眠时间可能导致频繁切换，而太长的休眠时间可能导致响应时间延迟。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行一些任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待一段时间，避免过度占用CPU</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>yield</li></ul><blockquote><p>yield 方法是 Thread 类的实例方法，用于提示调度器当前线程愿意放弃当前对CPU的使用，让其他线程有机会执行。它会让线程从 运行状态 进入 RUNNABLE 就绪状态（不是进入阻塞状态），等待重新分配CPU时间片。</p><p>注意：yield 方法并不保证当前线程会让步，只是向调度器发出一个提示，，其他线程是否能获得执行机会取决于底层操作系统的调度策略。</p><p>yield 通常用于在多个线程执行相同优先级任务，协调线程执行顺序，提高程序的执行效率。</p></blockquote><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><blockquote><p>join 方法时是 Thread 类提供的一个方法，用于当前线程等待调用该方法的线程执行完毕。</p><p>调用目标线程的join()方法，会让当前线程阻塞（放弃占用cpu时间片），直到目标线程结束。</p><p>它是一种线程同步机制，用于协调多个线程的执行顺序。</p><p>当调用 join(long millis) 方法表示等待目标线程执行结束，但最多等待millis毫秒</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(<span class="string">&quot;t1 finish&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line">    <span class="comment">// 当前线程main阻塞等待t1执行结束</span></span><br><span class="line">      t1.join();</span><br><span class="line">      System.out.println(<span class="string">&quot;main stop&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"># 输出结果：</span><br><span class="line">    t1 start</span><br><span class="line">    t1 finish</span><br><span class="line">    main stop</span><br></pre></td></tr></table></figure><h4 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h4><blockquote><p>thread.interrupt()方法用于中断一个线程的执行。调用目标线程的 interrupt方法 不会立即中断线程，而是设置线程的中断状态，线程自己检查中断标志并采取相应的行为。</p><p>使用 Thread.interrupted() 静态方法来检查当前线程的中断状态并清理中断状态。这个方法会返回当前中断状态，并在调用后将中断状态重新设置为 false。thread.isInterrupted 也可以检查当前线程的中断状态但是不会对中断状态进行清除。</p></blockquote><ul><li><p>打断RUNNABLE的线程</p><p>调用线程的 <code>interrupt()</code> 方法时，将线程的中断状态设置为 <code>true</code></p><p>应用：实现通知线程停止执行，线程可以在适当检查中断状态，如果发现被中断，可以选择优雅的退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 is running&quot;</span>);</span><br><span class="line">          <span class="comment">// 目标线程自己检查中断标记，自己优雅的退出</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">              <span class="comment">// 优雅的退出：执行退出前的工作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;t1 is break&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    t1.start();</span><br><span class="line">  <span class="comment">// 运行一秒 打断标记</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打断休眠或者阻塞的线程</p><p>如果线程被某些阻塞操作（如 <code>Object</code> 类的 <code>wait()</code>、<code>Thread.sleep()</code>、<code>join()</code> 方法等）所阻塞，调用 <code>interrupt()</code> 方法可以使线程抛出 <code>InterruptedException</code>，从而提前结束阻塞状态。</p><p>注意这些情况的 <code>isInterrupted()</code> 会返回 <code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      Thread.sleep(<span class="number">1</span>);</span><br><span class="line">      t1.interrupt();</span><br><span class="line">      System.out.println(<span class="string">&quot;打断标记：&quot;</span> + t1.isInterrupted());</span><br><span class="line">  &#125;</span><br><span class="line"># 输出</span><br><span class="line">       Exception in thread <span class="string">&quot;t1&quot;</span> java.lang.RuntimeException: java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at com.example.demo.concurrency.BlockingInterruptDemo.lambda$main$<span class="number">0</span>(BlockingInterruptDemo.java:<span class="number">16</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br><span class="line">  Caused by: java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at com.example.demo.concurrency.BlockingInterruptDemo.lambda$main$<span class="number">0</span>(BlockingInterruptDemo.java:<span class="number">14</span>)</span><br><span class="line">    ... <span class="number">1</span> more</span><br><span class="line">  打断标记：<span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>打断LockSupport.park的线程</p><p>LockSupport.park 是 阻塞线程的一种方式，用于实现线程之间的协作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">           LockSupport.park();</span><br><span class="line"> System.out.println(<span class="string">&quot;unpark..thread isInterrupted - &quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">       t1.start();</span><br><span class="line">       TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">       t1.interrupt();</span><br><span class="line">   &#125;</span><br><span class="line">输出结果：</span><br><span class="line"> park...</span><br><span class="line">unpark..thread isInterrupted - <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在上述的例子中，子线程启动执行 LockSupport.park(), 主线程等待一段时间后调用 thread.interrupt() 打断子线程，此时线程的停止中断，此时的线程打断标记为 true</p><p>注意：如果打断标记为 true, 此时线程如果在执行 LockSupport.park() 是无法阻塞的</p></li></ul><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><blockquote><p>线程的优先级是一个用于指定线程调度顺序的概念。java 中线程优先级是通过整数表示的，范围从<code>Thread.MIN_PRIORITY</code>（1）到<code>Thread.MAX_PRIORITY</code>（10），其中<code>Thread.NORM_PRIORITY</code>（5）是默认的优先级。</p><p>线程的优先级越高，任务调度器在选择下一个要执行的线程时，更有可能选择优先级较高的线程。注意：线程优先级并不是硬性规定，而是一个调度提示，在某些情况下影响线程的执行顺序，但不应该过度依赖它来实现程序的正确性。</p></blockquote><h3 id="主线程和守护线程"><a href="#主线程和守护线程" class="headerlink" title="主线程和守护线程"></a>主线程和守护线程</h3><blockquote><p>主线程（main thread）和 守护线程（daemon thread） 是 java 中线程的两种不同的类型。</p><p>默认情况下，整个 java 进程需要等待所有的线程运行结束才会结束。</p><p>而守护线程是一种在程序运行时在后台提供服务的线程，他的不影响程序的执行，也不阻止程序的终止。当所有的非守护线程结束时，进程会结束，守护线程也会被强制终止，即使它们还在执行任务。守护线程通常用于提供一些后台服务或周期性任务，如垃圾回收。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">      <span class="comment">// 将 t1 线程设置为 守护线程</span></span><br><span class="line">      t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;主线程执行结束！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"># 输出结构</span><br><span class="line">   开始运行...</span><br><span class="line">主线程执行结束！</span><br></pre></td></tr></table></figure><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h4 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h4><img src="https://s2.loli.net/2024/01/13/AXTdEzWKMgOhnLY.png" alt="image-20240112162416523" style="zoom:33%;" /><ul><li><p>初始 状态：仅仅在语言层面上创建了对象</p></li><li><p>可运行 状态：线程已经创建完毕，等待cpu调度执行</p></li><li><p>运行 状态：线程占用cpu资源，正在执行其指令</p><p>可运行状态和运行状态可以相互转换，这是由由操作系统的任务调度器（Scheduler）决定，当任务调度器给线程获取cpu时间片，线程切换为运行状态执行并消耗cpu时间片的时间，当分配的cpu时间片用完了，则线程切换为可运行状态</p></li><li><p>阻塞 状态：线程进入阻塞状态表示该线程暂时无法执行。这可能是因为线程在等待某个资源（如锁）的释放，或者在等待某个条件的满足。在阻塞状态下，线程不会占用 CPU 时间片，任务调度器不会考虑调度该线程。当阻塞状态结束后，线程会进入可运行状态</p></li><li><p>终止状态：线程的指令执行完毕，线程的整个生命周期结束</p></li></ul><h4 id="JDK-层面"><a href="#JDK-层面" class="headerlink" title="JDK 层面"></a>JDK 层面</h4><img src="https://s2.loli.net/2024/01/18/3jy8UpSDIhF52qB.png" alt="image-20240112162226284" style="zoom:33%;" /><blockquote><p>java 将线程的状态划分为 6 种</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/01/13/BUnl2KqOcZoT8rI.png" alt="image" style="zoom: 67%;" /><ul><li><p>新建 - NEW：线程创建后尚未启动 即 线程创建，但是还没有调用 start 方法</p></li><li><p>可运行状态 - RUNNABLE：可能是操作系统层面的运行状态，也可能是可运行状态，也可能是IO阻塞等导致的阻塞状态</p></li><li><p>阻塞状态 - BLOCKING：线程等待获取一个排它锁，如果其线程释放了锁就会结束此状态</p></li><li><p>无限期等待 - WAITING：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片</p><table><thead><tr><th>无限期等待进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置时间的 Object.wait()</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join()</td><td>目标线程执行完毕</td></tr><tr><td>LockSupport.park()</td><td>其他线程调用 LockSupport.unpark(目标thread) 或者 调用 目标thread.interrupt()</td></tr></tbody></table></li><li><p>限期等待 - TIME WAITING：无需等待其它线程显式地唤醒，在一定时间之后会被自动唤醒</p><table><thead><tr><th>限期等待进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep()</td><td>时间结束</td></tr><tr><td>设置时间的 Object.wait()</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置超时时间 Timeout 参数的 Thread.join()</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos(long nanos) / LockSupport.parkUntil(long deadline)</td><td>其他线程调用 LockSupport.unpark(目标thread) 或者 调用目标thread.interrupt()</td></tr></tbody></table></li><li><p>死亡 - TERMINATED：线程结束任务之后自己结束，或者产生异常而结束</p></li></ul><h3 id="查看进程和线程的方式"><a href="#查看进程和线程的方式" class="headerlink" title="查看进程和线程的方式"></a>查看进程和线程的方式</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><blockquote><p>ps -ef # 查看所有进程</p><p>ps -ef | grep java  或者 jps -l  # 查看java进程     </p><p>top # 显示进程动态列表</p><p>kill <pid> # 查看进程</p></blockquote><h4 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h4><blockquote><p>ps -fT -p <PID> # 查看某个进程的所有线程</p><p>top -H -p <PID> #  进程中的动态线程列表</p><p>jstack <PID> # 进程中的线程快照详细信息</p></blockquote><p>java 图形化线程监控工具 - jconsole</p><p>在控制台输入 jconsole 命令</p><img src="https://s2.loli.net/2024/01/10/CyRzEMfg8dQ7rxn.png" alt="image-20240110161406048" style="zoom:33%;" /><p>在jconsole进行远程监控时，需要jar包启动时，添加部分配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=&#123;host_ip&#125; \</span><br><span class="line">-Dcom.sun.management.jmxremote \ # 启用JMX远程访问</span><br><span class="line">-Dcom.sun.management.jmxremote.port=&#123;port_number&#125; \ # 指定了JMX远程连接的端口（与接口访问接口不同）</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false \ # 禁用SSL和身份验证</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false \  </span><br><span class="line">-jar xxx.jar</span><br></pre></td></tr></table></figure><h3 id="线程应用"><a href="#线程应用" class="headerlink" title="线程应用"></a>线程应用</h3><ul><li>异步调用</li><li>并行计算</li><li>同步等待</li><li>协同规划</li></ul><h2 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h2><h3 id="共享模型"><a href="#共享模型" class="headerlink" title="共享模型"></a>共享模型</h3><h4 id="共享问题"><a href="#共享问题" class="headerlink" title="共享问题"></a>共享问题</h4><p>简单示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出结果</span><br><span class="line">  <span class="number">1616</span></span><br></pre></td></tr></table></figure><p>上述代码中，对于代码中，使用了多线程对于一个静态变量（共享变量）分别执行了5000次自增和5000次自减操作，但是最后的结果并不是0，这是由多线程的共享问题导致的线程不安全问题。</p><p>从字节码的角度分析 静态变量的 cnt++ 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> getstatic # 获取静态变量cnt的值</span><br><span class="line"><span class="number">3</span> iconst_1  # 将整数常量值 <span class="number">1</span> 推送到堆栈上                                        </span><br><span class="line"><span class="number">4</span> iadd# 将堆栈上的两个值相加</span><br><span class="line"><span class="number">5</span> putstatic # 将相加的结果存回静态变量 cnt</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>由于 java 的 cpu 的分时复用技术，上述指令出现了 交错执行 的情况</p><p><img src="https://s2.loli.net/2024/01/13/dxGRFDIMz3XUbJi.png" alt="image-20240113123606339"></p><p>程序使用多线程执行本身没有问题，但是问题出现在对于共享资源的多线程的读写操作上，这块代码被称做 <strong>临界区</strong></p><p>当多个线程试图同时访问和修改共享数据，最终结果依赖于线程执行的具体顺序，这种情况被称之为 <strong>竞态条件</strong></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>为了避免在临界区发生竞态条件，java 提供了很多方案</p><ul><li>阻塞式：synchronized lock</li><li>非阻塞式：atomic原子类</li></ul><h4 id="变量线程安全分析"><a href="#变量线程安全分析" class="headerlink" title="变量线程安全分析"></a>变量线程安全分析</h4><p>成员变量和静态变量如果没有共享，则线程安全；如果处于共享状态（不同的线程都可以访问和操作），但只有读取操作，线程也是安全的，当有读写操作时，则需要考线程安全问题。</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><blockquote><p>synchronzed （对象锁）是 java 中用于实现同步的关键字。它提供了一种机制，确保在多个线程访问共享资源时，只有一个线程能够进入关键代码段（临界区），从而避免竞态条件和数据不一致性的问题。</p><p>它采用 互斥 的方式让同一时刻只有一个线程可以持有对象锁，其他线程会被阻塞，因此可以保证获取对象锁的线程安全的执行临界区的代码，在此期间不会发生线程的上下文切换。</p><p>当锁被释放后，等待该锁的线程会被唤醒，被唤醒的线程会从阻塞状态进入就绪状态，等待操作系统的调度器重新分配 CPU 时间片，从而执行。</p></blockquote><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ul><li>线程A获得对象锁并进入临界区执行</li><li>线程B尝试访问相同的对象锁，线程B被阻塞，从可运行状态进入阻塞状态</li><li>线程A释放锁时，线程B会被唤醒，并进入就绪状态</li><li>任务调度器将CPU时间分配给线程B，线程B开始执行临界区</li></ul><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用在 代码块 上</span></span><br><span class="line"><span class="keyword">synchronized</span> (对象) &#123; <span class="comment">// 该对象可以是任何对象（可以是 类的 Class 对象），用于作为锁</span></span><br><span class="line">  临界区</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用在 方法 上 相当于 synchronized(this) &#123;&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; <span class="comment">// 整个方法体都会受到同步保护，对于非静态方法，锁是 当前对象实例</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用在 静态方法 上相当于 synchronized(xx.Class) &#123;&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123; <span class="comment">// 对于静态方法，锁是当前类的 Class 对象。</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><blockquote><p>synchronized 实际上是使用 <strong>对象锁</strong> 保证了临界区代码的<strong>原子性</strong>。因此，需要保护共享资源，必须对于<strong>同一个对象加锁</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                counter.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(counter.getCnt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于 两个线程 执行是并行还是互斥，关键是看 synchronized 锁的是不是同一个对象。</p><p>synchronized 关键字的互斥性质是由同步锁的对象来决定的。不同的锁对象可能导致并行执行，相同的锁对象则会引起互斥执行。</p></blockquote><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>因为 synchronized被称为 对象锁，所以需要理解 synchronized 的底层，首先要了解 java 对象</p><blockquote><p>java 对象在内存中的结构由三个部分组成：对象头（object header）、实例数据（instance data）和填充（Padding）。</p><ul><li>对象头：包含一些用于管理对象的元信息，如标记字、类型指针等</li><li>实例数据：数据的实际数据，包括字段和方法等</li><li>填充：为满足特定的内存对齐要求，可能在实例数据之后添加一些填充字节 </li></ul></blockquote><h6 id="对象头-object-header"><a href="#对象头-object-header" class="headerlink" title="对象头 - object header"></a>对象头 - object header</h6><p>对象头位于 每个对象的开头部分，它包含了用于管理对象的元信息。它包括了标记字、类型指针以及数组长度（如果对象是数组类型则有）。</p><ul><li>标记字：一般占用32个位即4字节</li><li>类型指针：指向对象所属的元数据，用于确定对象的类型</li></ul><img src="https://s2.loli.net/2024/01/13/fDPtmcbGRNKJdWv.png" alt="image-20240113214427176" style="zoom: 50%;" /><h6 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h6><p>其中，每个对象都有一个与之关联的监视器 - Monitor，它是多线程实现同步的机制的关键，负责管理对象的同步操作，监视器和对象是一对一的关系。当有对象被synchronized锁住，该对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针。</p><p>monitor的结构：</p><ul><li><p>锁持有者 - owner：持有锁的线程</p></li><li><p>等待锁 - waitset：调用对象 wait 方法进入的对象等待集</p></li><li><p>通知队列 - entrylist：存放因为等待锁释放而被阻塞的线程的队列</p><img src="https://s2.loli.net/2024/01/14/QblBCeJip4cEGHx.png" alt="image-20240114130236719" style="zoom: 50%;" /></li></ul><p>monitor底层原理</p><p>当线程1成功获取到锁，此时锁住的对象的对象头的mark word前30位用于存储monitor的指针 - ptr_to_heavyweight_monitor，monitor 的 owner 指向线程1，线程1成为锁的拥有者（owner），并且对象头的加锁状态从01变为10（即正常状态到加锁状态），；在线程1执行临界区指令的过程中，此时线程2尝试获取锁，由于对象头中的状态为加锁状态并且关联的monitor的owner指向线程1，此时 线程2加入到 entrylist 等待队列 中，并且状态2的状态变为 阻塞状态 - BLOCKED；当线程1执行完临界区的指令后，此时 owner 置为空，并且由线程1调用 Object.notifyAll() 唤醒等待队列中的线程，这些线程在竞争（非公平的）尝试获取锁，执行临界区的指令</p><p><img src="https://s2.loli.net/2024/01/14/6Y7B39aqldHg5oJ.png" alt="image-20240114140247979"></p><p>分析字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> getstatic #<span class="number">2</span> # 从索引为<span class="number">2</span>的静态字段获取值并推送到操作数栈中 （这里索引为<span class="number">2</span>的静态变量的值即是obj锁对象的引用）</span><br><span class="line"> <span class="number">3</span> dup          # 复制栈顶的obj锁对象的引用并放入到栈顶</span><br><span class="line"> <span class="number">4</span> astore_1     # 将栈顶的obj锁对象的引用弹出存储到局部变量表位置<span class="number">1</span> 用于后续的解锁和确保异常处理可以正确的释放锁</span><br><span class="line"> <span class="number">5</span> monitorenter # 进入对象的监视器，即获取锁。获取锁成功则 对象头的mark word存储指向monito的指针来与一个monitor对象关联</span><br><span class="line"> <span class="number">6</span> getstatic #<span class="number">3</span> # 从索引为<span class="number">3</span>的静态字段获取值 cnt 并推送到</span><br><span class="line"> <span class="number">9</span> iconst_1     # 将整数<span class="number">1</span>推送到栈顶</span><br><span class="line"><span class="number">10</span> iadd         # 执行整数相加操作</span><br><span class="line"><span class="number">11</span> putstatic #<span class="number">3</span> # 将自增的结构存入到索引为<span class="number">3</span>的静态字段cnt中</span><br><span class="line"><span class="number">14</span> aload_1      # 加载局部变量表位置<span class="number">1</span>的即之前复制的object对象</span><br><span class="line"><span class="number">15</span> monitorexit  # 退出对象的监视器，即释放锁</span><br><span class="line"><span class="number">16</span> goto <span class="number">24</span> (+<span class="number">8</span>) # 正常执行完毕 跳转到字节码指令索引为<span class="number">24</span>的位置</span><br><span class="line"><span class="number">19</span> astore_2     # 将栈顶的引用类型值存储到局部变量表位置<span class="number">2</span>，此时栈顶的引用为异常的引用</span><br><span class="line"><span class="number">20</span> aload_1      # 将局部变量表中索引为<span class="number">1</span>的obj锁对象引用加载到栈顶</span><br><span class="line"><span class="number">21</span> monitorexit  # 退出对象的监视器，即释放锁</span><br><span class="line"><span class="number">22</span> aload_2      # 将在局部变量表中的位置<span class="number">2</span>的信息即异常信息引用</span><br><span class="line"><span class="number">23</span> athrow       # 抛出异常</span><br><span class="line"><span class="number">24</span> <span class="keyword">return</span>       # 从当前方法返回</span><br></pre></td></tr></table></figure><p>从上述代码，可以看出，即使执行同步代码块时，发生了异常，锁也在抛出异常前，进行释放。</p><p>复制锁对象的引用存放到 局部变量表的位置1 的目的是 确保锁对象的引用在同步块内的后续操作中仍然位于固定位置，以便于后续的存储和使用</p><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><blockquote><p>jvm 底层对于 synchronized 进行了优化，在不同竞争程度下，采用了不同的锁的类型来优化性能开销，其中包括了 偏向锁、轻量级锁、重量级锁。这样做的目的在于提高获取锁和释放锁的效率以提高多线程并发操作的性能。</p><p>这四种状态是随着竞争情况而升级（即锁的膨胀）的，锁可以升级但是不可以降级（即锁的膨胀是不可逆的），锁的膨胀方向：偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁。</p><p>这种优化策略依赖于具体应用场景和线程行为，jvm在运行时会根据运行情况动态的自动选择合适的锁类型，因此无需开发者显式低关心锁的细节，jvm 会在背后自动的进行优化，使用最适合的锁策略。</p></blockquote><h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><ul><li><p>适用场景：多线程<strong>交替</strong>访问同步代码块（这里的交替指的是”访问的时间是错开的”，没有产生竞争）</p></li><li><p>流程：</p><ul><li><p>当线程尝试获取锁时，首先会在线程的栈帧中，创建一个<strong>锁记录</strong>的对象（锁记录在JVM层面），锁记录对象包含两部分，一部分用来存储 将要锁住对象的对象指针的空间，另一部分存储 锁记录地址以及轻量级锁标识00</p><img src="https://s2.loli.net/2024/01/18/HYULh3WCzgOkvVT.png" alt="image-20240116143157172" style="zoom:50%;" /><p><img src="https://s2.loli.net/2024/01/16/bZ7X6cv2AdmzLNi.png" alt="image-20240116095137152"></p></li><li><p>当线程尝试获取锁时，会尝试通过<strong>CAS</strong>操作将对象的对象头的Mark Word和锁记录中的地址和轻量级锁标识进行互换</p><ul><li><p>如果CAS操作成功，则线程栈帧中的锁记录中的对象指针指向锁对象，标识线程获取锁成功</p><p><img src="https://s2.loli.net/2024/01/16/wM956Lcb8jZNTSn.png" alt="image-20240116090743477"></p></li><li><p>如果CAS操作失败，会有两种情况</p><ul><li><p>如果锁对象的对象头中Mark Word中的锁标识为00，但锁记录指针指向当前线程的其他锁记录，则发生了锁重入的情况，则只在线程的栈帧加上一个锁记录用于锁重入的计数，锁记录取值为 Null</p><p><img src="https://s2.loli.net/2024/01/16/7KVluGgXtfIsnJe.png" alt="image-20240116093852460"></p></li><li><p>如果锁对象的对象头中Mark Word中的锁标识为01，并且锁记录指针指向其他线程的锁记录，代表其他线程持有了这把对象锁，此时发生同一时刻有多个线程竞争同一个对象锁的情况发生了锁竞争，轻量级锁会升级成重量级锁，进入重量级的流程</p></li></ul></li></ul></li><li><p>执行完同步代码块的内容后，开始释放锁时，</p><ul><li><p>当栈帧弹出锁记录为Null时，则代表这是重入锁的锁记录，则直接弹出，此时重入次数也会减一；</p></li><li><p>当锁记录不为Null时，则通过CAS操作将对象的对象头的Mark Word和锁记录中存储之前的无锁状态的对象头信息（hashcode gc age 偏向锁标识 锁状态）进行互换即将原先对象头Mark Word进行恢复。</p><ul><li>CAS恢复成功，则解锁成功</li><li>CAS恢复失败，则说明轻量级锁已经发生锁膨胀升级为了重量级锁，此时将进入重量级锁解锁的流程</li></ul></li></ul></li></ul></li></ul><h6 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h6><blockquote><p>锁膨胀：在上述情况下，在线程尝试获取轻量级锁的过程中，CAS替换对象锁时，因为当前对象状态为01并且锁记录指针指向其他线程的锁记录时，此时表示 轻量级锁发生了竞争，这时候就需要锁膨胀，将轻量级锁升级为重量级锁。</p></blockquote><p><img src="https://s2.loli.net/2024/01/16/pjyBisJ1O3z5cmI.png" alt="image-20240116100637988"></p><p>当有线程持有了轻量级锁，其他线程获取锁失败，进入锁膨胀流程：</p><ul><li><p>为锁对象申请Monitor监视器，让对象的对象头的Mark Word的锁状态变为10，指针指向Monitor监视器，Monitor监视器的owner指向当前持有轻量级锁的线程，其他线程进入Monitor的阻塞队列中，并且变为阻塞状态</p></li><li><p>当之前持有轻量级锁的线程执行完同步代码块后尝试释放锁，通过CAS将之前存储在线程栈帧锁记录中的对象的Mark Word交换恢复给对象，此时由于对象对象头中的Mark Word存储的是Monitor地址和10重量级锁标识，因此进入重量级锁的锁释放流程，根据对象头的Monitor的指针找到Monitor监视器，将Owner置为Null，并且使用之前的持有锁线程唤醒entrylist的阻塞线程</p><p><img src="https://s2.loli.net/2024/01/16/QPNRKVDLAfzCI42.png" alt="image-20240116103407802"></p></li></ul><h6 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h6><blockquote><p>自旋优化 - spin lock</p><p>在线程尝试获取锁，如果锁已经被其他线程占用，该线程不会立即阻塞，而是会循环自旋一段时间，防止线程阻塞而减少上下文切换的开销，这针对于短暂的锁占用和低竞争情况的一种优化策略。</p><p>注意：自旋会占用一定的CPU资源，节省了上下文切换的时间，这也是为什么它用于短暂的锁占用和低竞争情况的原因。此外，它会进行一定时间或次数的自旋（JDK1.6引入了自适应自旋锁Adaptive Spinning - 自旋的时间由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定），如果自旋超过了限定的时间或次数，则会进入阻塞状态，等待被唤醒。</p></blockquote><h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><ul><li><p>使用场景：同一个代码块由同一个线程多次执行的场景；执行的同步代码块大多数场景下是单线程访问同步块的场景，使用偏向锁可以减少CAS操作和monitor对象的开销</p></li><li><p>机制：当线程第一次进入获取对象锁时，线程获取锁成功，将该线程的ID直接存储在对象头中并将标记对象为启用偏向锁状态（即表示该对象归属于该线程），之后该线程重复获取锁，无需竞争，直接获取锁，后续锁释放，依旧会在对象头中保持这个线程ID</p><img src="https://s2.loli.net/2024/01/18/ADOPXFYURhN5C7j.png" alt="image-20240116142559410" style="zoom:50%;" /><blockquote><p>对象默认开启了偏向锁即创建的对象最后3位为101(添加参数 -XX:-UseBiasedLocking 禁用偏向锁)，但是偏向锁是默认延迟的，对象创建后不是立即处于启用偏向状态，而是有一个默认的延迟时间，延迟时间后启用偏向状态即最后3位为101，这个延迟时间的目的是为了让应用程序在启动时有足够的时间执行一些初始化操作，避免在初始化阶段执行一些初始化操作。（可以添加 VM 参数：-XX:BiasedLockingStartupDelay=0来禁用延迟）</p></blockquote></li><li><p>偏向锁的撤销：撤销对于对象的偏向 将101状态修改为001</p><ul><li>调用对象的 hashcode 方法（对象头的hashcode占用对象头mark word的一部分空间）</li><li>当出现其他线程尝试获取偏向锁对象，会将偏向锁升级为轻量级锁</li><li>调用对象的 wait/notify 方法</li></ul></li><li><p>批量重偏向：当对象的偏向锁的撤销但并多个线程并没有没有出现竞争时，而其中一个线程获取锁的次数达到了阈值（默认20），虚拟机可能会重新偏向其中的一个线程。但是如果该类的实例对象偏向锁撤销的次数越来越多，达到阈值（默认40），会将整个类标记为不可偏向，新建的该类的实例对象也无法偏向。</p></li></ul><h6 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h6><blockquote><p>锁消除机制是jvm即时编译器的优化手段，用于消除代码中不必要的同步操作，从而减少加锁和释放锁带来的性能开销。编译器通过静态分析代码，判断对象锁在特定情况下不会发生竞争。</p><p>锁消除的常见情况</p><ul><li>逃逸分析：分析对象的引用是否会逃逸出当前方法的作用域，如果没有，则说明对象的生命周期仅限于当前方法的执行过程，不会被其他方法引用。即时编译器判断在方法内部，对象锁不会发生竞争，此时可以消除锁操作</li><li>线程局部存储：对象的作用域为所属线程，此时也不会发生线程锁的竞争，因此可以安全的消除锁操作</li></ul><p>jvm 默认开启锁消除机制</p></blockquote><h4 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h4><blockquote><p>wait 是 Object 类的实例方法用于 线程之间的协作：线程为了等待某个条件满足，阻塞等待，让出锁其他的线程获取 锁执行</p><p>该方法只能在同步代码块或同步方法中调用，否则会运行时抛出 IllegalMonitorStateException。</p><p>调用 wait() 方法使得线程挂起，等待某个条件满足，此时线程会被挂起，这个期间会释放对象锁，当其他线程的运行使得这个条件满足时，其他线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程</p></blockquote><p><img src="https://s2.loli.net/2024/01/16/P4dN3nqDEzj56fV.png" alt="image-20240116215737327"></p><p>当线程获取锁后进入同步代码块中后，调用wait方法，释放对象的锁，线程从RUNNABLE状态变为WAITING状态（不会占用CPU资源），并加入到monitor对象的WaitSet等待集合中，其他线程调用 notify() 或者 notifyAll() 来唤醒WaitSet中的线程，被唤醒的线程重新尝试获取锁。</p><h5 id="相关API方法"><a href="#相关API方法" class="headerlink" title="相关API方法"></a>相关API方法</h5><ul><li>obj.wait()：让当前持有对象锁的线程到monitor监视器的WaitSet中等待，无限期等待直到其他线程获取该对象锁并调用notify()或者notifyAll()唤醒它  </li><li>obj.wait(long timeout)：同样是线程进入到monitor的WaitSet中等待，只不过是限期等待，等待超过时间会自动唤醒</li><li>obj.notify()：在同步代码中唤醒对象monitor监视器的WaitSet中的一个线程</li><li>obj.notifyAll()：在同步代码中唤醒对象monitor监视器的WaitSet中的全部线程</li></ul><blockquote><p>notify和notifyAll方法必须在同步代码块中执行，是为了保证线程安全性、避免数据竞争和死锁，并确保线程间正确的通信</p></blockquote><p>这些方法主要用于线程之间的协作，都是所有Object对象方法，所有方法的调用只能在获取锁的前提下即在同步代码块或者同步方法中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置final修饰变量 保证对象引用不可变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait(); <span class="comment">// t1 进入 WaitSet</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();  <span class="comment">// t2 进入 WaitSet</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// notify 唤醒WaitSet其中一个线程 notifyAll 唤醒WaitSet所有线程</span></span><br><span class="line">            obj.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">  t1 start</span><br><span class="line">  t2 start</span><br><span class="line">  t1 end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h5><ul><li>sleep 是 Thread 类的一个静态方法，wait 是 Object 类的方法</li><li>wait 必须在同步代码块中调用即调用的该方法的线程必须要持有这把对象锁，而 sleep 则不需要</li><li>sleep 休眠时无论是否持有锁都不会释放持有的锁，而 wait 会在等待时会释放对象锁</li><li>wait 没有设置休眠时间时，会进入无限期等待，直到其他线程获取锁后，调用notify()或者notifyAll()方法唤醒锁</li><li>sleep 方法用于 定时任务或者简单的时间控制，而 wait 方法用于线程之间的协作</li></ul><h5 id="正确实例"><a href="#正确实例" class="headerlink" title="正确实例"></a>正确实例</h5><p>在线程需要等待某个条件的场景下，可以使用wait方法来让线程阻塞，释放锁对象，让其他线程先执行，等待条件满足后，再由其他线程获取锁对象调用notifyAll 唤醒线程。</p><ul><li>这种方式，相比于 sleep 方法而言，效率更好，因为 sleep 在执行同步代码块时，不会释放锁对象。</li><li>使用 notifyAll 的原因是 notify方法只会从对象的monitor监视器的 WaitSet 中挑一个执行，当有个多个线程执行wait方法时即 WaitSet 中有多个对象时，notify 不一定会唤醒该线程， 而notifyAll 会唤醒 WaitSet中的所有集合。</li><li>线程被notifyAll唤醒后，此时的线程所需要等待的条件可能没有成立，此时，线程直接往下执行，不会执行某个条件成立的代码。因此需要使用 while 让没有成立条件的方法继续进入等待状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 使用 final 修饰的变量 不可变（引用关系）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立) &#123;</span><br><span class="line">      lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h5 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h5><blockquote><p>保护性暂停 - Guarded Suspension，用于 一个线程等待另一个线程的执行结果。</p><p>其核心是一个受保护的方法，该方法在执行其所需要真正执行的操作时需要满足特定的条件，当条件状态不满足时，执行受保护方法的线程挂起并进入等待状态，直到条件状态满足该线程才能继续执行。</p><p>应用场景：JDK中，join底层实现，Future类的底层实现。</p></blockquote><img src="https://s2.loli.net/2024/01/18/dzbG3pSchgHJPyW.png" alt="image-20240118140420491" style="zoom:50%;" /><h6 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 条件不满足 阻塞 释放锁</span></span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置等待的超时时间</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">                System.out.println(passTime);</span><br><span class="line">                <span class="keyword">if</span> (passTime &gt; timeout) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 防止结果依旧为 null 但是被其他线程唤醒</span></span><br><span class="line">                    lock.wait(timeout - passTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          <span class="comment">// 其他线程获取条件</span></span><br><span class="line">            <span class="built_in">this</span>.result = response;</span><br><span class="line">          <span class="comment">// 唤醒</span></span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGuard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">GuardObject</span> <span class="variable">guardObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="comment">// 设置超时时间</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> guardObject.get(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;result:&quot;</span> + o);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;result complete...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            guardObject.complete(Integer.MAX_VALUE);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="join底层分析"><a href="#join底层分析" class="headerlink" title="join底层分析"></a>join底层分析</h6><blockquote><p>线程A调用线程B实例的join方法，线程A将等待线程B执行结束后，才会执行线程A下面的代码。</p><p>join的底层实现就用到了 保护性暂停 Guarded Suspension 模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// millis 超时时间 0表示不会超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 参数有效性检查</span></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 不会超时的等待</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">              <span class="comment">// 超时释放</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if this thread is alive. A thread is alive if it has</span></span><br><span class="line"><span class="comment">     * been started and has not yet died. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 代码执行完毕后，线程被销毁 返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h6 id="多任务代码实现"><a href="#多任务代码实现" class="headerlink" title="多任务代码实现"></a>多任务代码实现</h6><img src="https://s2.loli.net/2024/01/18/KanUrBxG2RtSesp.png" alt="image-20240118150227848" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"># GuardObj </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardObj</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardObj</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">            <span class="keyword">if</span> (passTime &gt; timeout) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait(timeout);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#  Tasks 统一管理多个任务</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tasks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Long, GuardObj&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardObj <span class="title function_">genGuardObj</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">GuardObj</span> <span class="variable">guardObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardObj</span>(id);</span><br><span class="line">        tasks.put(id, guardObj);</span><br><span class="line">        <span class="keyword">return</span> guardObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardObj <span class="title function_">removeGuardObj</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGuardObjs</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0l</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">GuardObj</span> <span class="variable">guardObj</span> <span class="operator">=</span> Tasks.genGuardObj(finalI);</span><br><span class="line">                System.out.println(<span class="string">&quot;任务&quot;</span> + finalI + <span class="string">&quot;开始接受任务&quot;</span>);</span><br><span class="line">                guardObj.get(<span class="number">5000</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0l</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">GuardObj</span> <span class="variable">guardObj</span> <span class="operator">=</span> Tasks.removeGuardObj(finalI);</span><br><span class="line">                System.out.println(<span class="string">&quot;向任务&quot;</span> + finalI + <span class="string">&quot;发送任务&quot;</span>);</span><br><span class="line">                guardObj.complete(finalI);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line"> 任务<span class="number">0</span>开始接受任务</span><br><span class="line">  任务<span class="number">1</span>开始接受任务</span><br><span class="line">  任务<span class="number">2</span>开始接受任务</span><br><span class="line">  向任务<span class="number">0</span>发送任务</span><br><span class="line">  向任务<span class="number">1</span>发送任务</span><br><span class="line">  向任务<span class="number">2</span>发送任务</span><br></pre></td></tr></table></figure><h6 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h6><p>上述的模式，一个线程等待另一个线程的条件满足，才被唤醒执行，等待线程和唤醒线程是一对一的关系，在多个任务时，需要多对线程。而在生产者和消费者模型中，等待线程可以多次等待，唤醒线程可以多次唤醒，从而减少了线程资源的开销。生产者只负责生产数据，消费者只负责接收数据，数据以消费队列的方式存储，JDK的很多阻塞队列采用了这种模式。</p><img src="https://s2.loli.net/2024/01/18/Cxnc3ZPGhUmIRwY.png" alt="image-20240118190002480" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(Integer id, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(Integer capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 获取消息的等待条件为 队列不能空</span></span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息队列已空，等待生产者生产消息&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            System.out.println(<span class="string">&quot;comsume:&quot;</span> + message.toString());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 等待存入消息的条件为 队列没有满</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息队列满足，等待消费者消费消息&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            System.out.println(<span class="string">&quot;produce:&quot;</span> + message.toString());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMq</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">messageQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                messageQueue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, <span class="string">&quot;content&quot;</span> + id));</span><br><span class="line">            &#125;, <span class="string">&quot;produce&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                messageQueue.take();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Park和unPark方法"><a href="#Park和unPark方法" class="headerlink" title="Park和unPark方法"></a>Park和unPark方法</h4><p>Park和unPark方法是LockSupport类中的方法，它们以线程为单位阻塞和唤醒线程，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.park(); <span class="comment">// 用于暂停当前线程</span></span><br><span class="line">LockSupport.unpark(thread对象); <span class="comment">// 恢复某个线程的运行</span></span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 输出：</span><br><span class="line">  start...</span><br><span class="line">  park...</span><br><span class="line">  unpark...</span><br></pre></td></tr></table></figure><p>注意：unpark 方法可以在 park 之前调用，也可以在 park 之后调用，在之前调用也可以恢复线程。</p><h5 id="wait和park方法"><a href="#wait和park方法" class="headerlink" title="wait和park方法"></a>wait和park方法</h5><ul><li>wait、notify和 notifyAll 底层通过 对象的 monitor 监视器实现，而 unpark 实现更加的轻量级，unpark 让线程阻塞，但是不会让持有锁的线程释放锁</li><li>unpark 是 唤醒一个指定的线程，而 notify/notifyAll 则是唤醒 对象的 monitor 监视器中 waitSet 等待线程的随机一个 </li><li>park 之前可以先执行 unpark</li></ul><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>LockSupport中的 park 和 unpark 方法，底层原理依赖于操作系统的线程调度和管理机制。当一个线程调用 <code>park</code> 时，它会检查线程jvm底层的parker对象 是否有一个“许可”（permit）可用，如果有许可，<code>park</code> 立即返回，并消耗这个许可（即许可数变为0）；如果没有许可，线程将被阻塞，直到接收到一个许可或者线程被中断。当线程一个线程调用 <code>unpark</code> 唤醒它时，它会如果目标线程此时被 <code>park</code> 阻塞，它将被唤醒。如果目标线程此时没有被阻塞，它会持有这个许可，直到下次调用 <code>park</code> 时立即返回而不会阻塞。</p><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><blockquote><p>在很多场景下，为了提高系统的并发度，会讲锁的粒度尽可能的细化，这样有可能造成死锁。死锁就是 两个线程或者多个线程互等待彼此持有的锁。</p></blockquote><h6 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h6><ul><li>jstack</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jps </span><br><span class="line">jstack &lt;PID&gt; &gt; thread.dump</span><br><span class="line">搜索关键字 deadlock</span><br></pre></td></tr></table></figure><ul><li><p>使用 visualvm 或者 jconsole 工具</p><img src="https://s2.loli.net/2024/01/18/uEIMtCSW5QyoUcN.png" alt="image-20240118223540220" style="zoom:50%;" /></li></ul><h6 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h6><p>可以按照相同的顺序进行加锁，但是这种情况容易发生饥饿现象即有部分线程很难获取到锁，导致一直没有办法执行</p><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><blockquote><p>活锁是指两个或者多个线程相互改变彼此线程的结束条件，导致的状态变化彼此抵消，使得两个线程一直执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line"></span><br><span class="line">                System.out.println(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">                System.out.println(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，会一直执行下去，解决办法：可以使得两个线程执行时间交错，可以两个线程的休眠时间设置成不同的</p><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><blockquote><p>饥饿是指一个线程由于优先级太低，始终得不到CPU调度而始终无法结束的情况或者很难获取到锁对象，导致一直没有办法执行同步代码块</p></blockquote><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><blockquote><p>ReentrantLock 翻译是 可重入锁，相比于 synchronized 有如下的特点</p><ul><li>可以被中断</li><li>可以设置获取锁的超时时间</li><li>可以设置公平锁 - 先到先得，有效防止部分线程饥饿的情况</li><li>支持多个条件变量进行</li></ul><p>与 synchronized 一样，ReentrantLock 也是可重入的。</p></blockquote><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><blockquote><p>可重入指的是同一个线程可以多次获取同一把锁</p></blockquote><h5 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h5><p>Synchronized 和 ReentrantLock的 Lock 都是不可打断的，即有线程持有了锁，其他线程将一直阻塞等待下去。</p><blockquote><p>可打断是指 锁已经被持有的情况下，线程等待锁的释放，等待锁的释放的过程可以被打断，防止线程一直等待获取锁。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果锁没有被其他线程占用，竞争获取对象的锁</span></span><br><span class="line">                <span class="comment">// 如果锁被其他线程占用，则进入阻塞队列等待锁释放</span></span><br><span class="line">                System.out.println(<span class="string">&quot;t1 try lock&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 get lock&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 unlock&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;main lock&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1 interrupt&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">          main lock</span><br><span class="line">          t1 <span class="keyword">try</span> lock</span><br><span class="line">          t1 interrupt</span><br><span class="line">          interrupted</span><br><span class="line">          java.lang.InterruptedException</span><br><span class="line">            at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">944</span>)</span><br><span class="line">            at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1263</span>)</span><br><span class="line">            at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">317</span>)</span><br><span class="line">            at com.example.demo.concurrency.ReentrantLockDemo.lambda$method2$<span class="number">0</span>(ReentrantLockDemo.java:<span class="number">38</span>)</span><br><span class="line">            at java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>)</span><br></pre></td></tr></table></figure><h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><blockquote><p>锁超时机制是指尝试获取锁的线程不会一直阻塞等待，而是在指定的时间内等待锁的释放。如果在指定的时间内未能获取到锁，则停止等待，返回 <code>false</code>。这种机制有效的防止了线程无限制的等待下去，防止了死锁。</p></blockquote><h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;         </span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;t1 try lock&quot;</span>);</span><br><span class="line">           <span class="type">boolean</span> tryLock;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               tryLock = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;获取锁超时&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1 get lock&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       lock.lock();</span><br><span class="line">       t1.start();</span><br><span class="line">&#125;</span><br><span class="line">       # 输出：</span><br><span class="line">         t1 <span class="keyword">try</span> lock</span><br><span class="line">获取锁超时</span><br></pre></td></tr></table></figure><p>注意当直接调用 lock.trylock() 方法时即没有设置超时时间的情况下，线程直接尝试获取锁，不会等待，获取不到则直接返回 false ，获取锁失败。</p><h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><blockquote><p>公平锁的是指 线程会按照它们请求锁的顺序获得锁即先发出请求的线程会先获得锁，而后发出请求的线程按顺序排队等待锁。</p><p>Synchronized 和 ReentrantLock的无参数构造都是 非公平锁。 Synchronized 的 对象对应的 monitor 监视器的 EntryList（本质队列）维护了 等待获取锁的线程，当占有锁的线程释放锁时， 会调用 notifyAll（不是notify方法，防止死锁和饥饿） 方法唤醒所有阻塞队列的线程，让这些线程重新竞争获取锁。ReentrantLock 的无参数构造默认是 非公平锁。</p><p>ReentrantLock 的有参数构造设置 fair 参数为 true，此时是 公平锁 的实现。公平锁可以避免饥饿问题，防止线程无限制的等待。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock 实例对象的无参构造方法，默认创建非公平锁</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ReentrantLock 实例对象的有参构造方法， </span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是没有必要使用 ReentrantLock 实现避免饥饿问题（防止线程无限制的等待），因为 并发锁会降低并发度，造成性能降低，可以使用 lock.trylock 方法。</p><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><blockquote><p>条件变量是ReentrantLock提供的一种允许持有锁的线程在特定条件不满足时阻塞等待，在条件满足时被唤醒的特性。和Synchronized代码块中的wait/notify相比，ReentrantLock支持多个条件变量，提供了更细粒度的阻塞和唤醒机制。通过使用条件变量，你可以控制线程在特定条件下的等待和唤醒，从而有效地管理线程间的协作。</p><p>ReentrantLock的条件变量和Synchronized的wait/notify方法防止持有锁的线程在等待条件满足时占有锁，让其他线程无法执行，它们都有效的管理了线程之间的协作。</p></blockquote><p>ReentrantLock的条件变量通过 ReentrantLock实例对象的 newCondition 方法创建，该提供了该条件变量的await方法使得当前持有锁的线程等待并且释放锁（当前线程需要持有锁），直到另一个线程调用同一条件变量的single或者sinleAll方法唤醒等待条件中的一个线程或者全部线程重新竞争lock锁。</p><p>注意：使用变量时，调用 await 方法，线程应持有相关的锁。当调用 await方法后，线程会释放锁，进入等待状态。</p><p>使用场景：条件变量通常用于表示“某个条件是否满足”，用于实现复杂的线程间协调和通信。例如，在生产者-消费者问题中，消费者线程可能在“缓冲区为空”的条件上等待，而生产者线程在添加了新项到缓冲区后会通知该条件。</p><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 wait&quot;</span>);</span><br><span class="line">            condition1.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 doing&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 wait&quot;</span>);</span><br><span class="line">            condition1.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 doing&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition1.signalAll();</span><br><span class="line">        condition2.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JUC-并发编程&quot;&gt;&lt;a href=&quot;#JUC-并发编程&quot; class=&quot;headerlink&quot; title=&quot;JUC 并发编程&quot;&gt;&lt;/a&gt;JUC 并发编程&lt;/h1&gt;&lt;h2 id=&quot;多线程的引入&quot;&gt;&lt;a href=&quot;#多线程的引入&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
  </entry>
  
</feed>
