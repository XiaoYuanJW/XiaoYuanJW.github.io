<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC 并发编程 (三) JUC并发工具 | Hexo</title><meta name="keywords" content="juc"><meta name="author" content="YuanJW"><meta name="copyright" content="YuanJW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JUC并发工具并发工具线程池线程是一种系统资源，每个线程都会占用一定的内存资源，过多的线程可能会导致内存溢出的情况。同时，过多的线程会导致频繁的上下文切换而降低性能。因此不能过多的创建线程，在此问题的基础上，出现了线程池。 线程池是用于管理和复用线程的机制，减少过多的内存占用和线程数量导致频繁的上下文切换，以提升性能。 自定义线程池   ThreadPool - 线程池：用于管理可以被复用的线程">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC 并发编程 (三) JUC并发工具">
<meta property="og:url" content="http://example.com/2024/02/14/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JUC并发工具并发工具线程池线程是一种系统资源，每个线程都会占用一定的内存资源，过多的线程可能会导致内存溢出的情况。同时，过多的线程会导致频繁的上下文切换而降低性能。因此不能过多的创建线程，在此问题的基础上，出现了线程池。 线程池是用于管理和复用线程的机制，减少过多的内存占用和线程数量导致频繁的上下文切换，以提升性能。 自定义线程池   ThreadPool - 线程池：用于管理可以被复用的线程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/default-cover/2.png">
<meta property="article:published_time" content="2024-02-13T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-12T02:43:54.071Z">
<meta property="article:author" content="YuanJW">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default-cover/2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/14/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC 并发编程 (三) JUC并发工具',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-12 10:43:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default-cover/2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC 并发编程 (三) JUC并发工具</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-02-13T16:00:00.000Z" title="Created 2024-02-14 00:00:00">2024-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-03-12T02:43:54.071Z" title="Updated 2024-03-12 10:43:54">2024-03-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC 并发编程 (三) JUC并发工具"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JUC并发工具"><a href="#JUC并发工具" class="headerlink" title="JUC并发工具"></a>JUC并发工具</h1><h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程是一种系统资源，每个线程都会占用一定的内存资源，过多的线程可能会导致内存溢出的情况。同时，过多的线程会导致频繁的上下文切换而降低性能。因此不能过多的创建线程，在此问题的基础上，出现了线程池。</p>
<p>线程池是用于管理和复用线程的机制，减少过多的内存占用和线程数量导致频繁的上下文切换，以提升性能。</p>
<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><img src="https://s2.loli.net/2024/01/22/SwX8xyvudT4VbtE.png" alt="image-20240122111214901" style="zoom: 50%;" />

<ul>
<li>ThreadPool - 线程池：用于管理可以被复用的线程</li>
<li>BlockingQueue - 阻塞队列：用于平衡生产者生产和消费者消费速度差异<ul>
<li>消费者：相当于线程池中的线程，获取阻塞队列中的任务并执行</li>
<li>生产者：相当于请求或者其他线程产生任务</li>
<li>当消费者线程消费速度高于生产者线程生产时，线程池中线程需要等待 阻塞队列</li>
<li>当生产者线程生产速度高于消费者线程消费，阻塞队列用于存储来不及消费的任务</li>
</ul>
</li>
</ul>
<p>简单时间一个最大线程数和线程工厂的自定义线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(PoolTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThreadPool</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadPool</span>(<span class="number">2</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="number">5</span>,</span><br><span class="line">                (task) -&gt; ((MyThreadPool.Worker) task).getTarget().run());</span><br><span class="line">        List&lt;Runnable&gt; runnables = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i;</span><br><span class="line">            runnables.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;task&quot;</span> + a);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : runnables) &#123;</span><br><span class="line">            myThreadPool.exec(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectedHandler</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(T r)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyThreadPool.class);</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> MyBlockingQueue&lt;Worker&gt; myBlockingQueue;</span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 线程等待任务超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">workerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略模式 抽象成接口的抽象方法 具体实现交给调用者实现</span></span><br><span class="line">    <span class="keyword">private</span> RejectedHandler rejectedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit, <span class="type">int</span> queueCapacity, RejectedHandler rejectedHandler)</span> &#123;</span><br><span class="line">        myBlockingQueue = <span class="keyword">new</span> <span class="title class_">MyBlockingQueue</span>&lt;&gt;(queueCapacity);</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.rejectedHandler = rejectedHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exec</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        workerLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程的线程数小于核心线程数 - 创建线程执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(runnable);</span><br><span class="line">                worker.start();</span><br><span class="line">                logger.info(<span class="string">&quot;add worker:&#123;&#125; pre task:&#123;&#125;&quot;</span>, worker, runnable);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前线程的线程数等于核心线程数 - 任务进入阻塞队列</span></span><br><span class="line">                logger.info(<span class="string">&quot;task put queue:&#123;&#125; current queue size:&#123;&#125;&quot;</span>, runnable, myBlockingQueue.size());</span><br><span class="line">                myBlockingQueue.offer(<span class="keyword">new</span> <span class="title class_">Worker</span>(runnable), rejectedHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Runnable <span class="title function_">getTarget</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前线程任务不为空时</span></span><br><span class="line">                logger.info(<span class="string">&quot;exec task:&#123;&#125;&quot;</span>, target);</span><br><span class="line">                target.run();</span><br><span class="line">                <span class="comment">// 继续从阻塞队列中获取任务并执行</span></span><br><span class="line">                target = myBlockingQueue.poll(timeout, timeUnit);</span><br><span class="line">            &#125;</span><br><span class="line">            workerLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;remove worker:&#123;&#125;&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                workerLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁保证阻塞队列共享变量的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者条件变量，当消费者在阻塞队列中没有变量时，消费者需要阻塞等待</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">consumer_condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者拉取消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (deque.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//设置等待条件超时时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 重置等待实际为剩余时间 防止虚假唤醒重置等待时间</span></span><br><span class="line">                    nanos = consumer_condition.awaitNanos(nanos);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">T</span> <span class="variable">pop</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">            <span class="keyword">return</span> pop;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者投递消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rejectedHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(T t, RejectedHandler rejectedHandler)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (deque.size() &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">// 阻塞队列满了执行拒绝策略</span></span><br><span class="line">                rejectedHandler.reject(t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞队列添加任务</span></span><br><span class="line">                deque.offer(t);</span><br><span class="line">                consumer_condition.signalAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>ThreadPoolExecutor是jdk提供的线程池的实现</p>
<img src="https://s2.loli.net/2024/01/22/GmAQhFgH3pLRUWY.png" alt="image-20240122154814432" style="zoom: 67%;" />

<ul>
<li>Executor：是一个执行器接口，提供了提交的 Runnable 任务的对象</li>
<li>ExecutorService：是执行器服务接口，是线程池最基础的接口，扩展了 Executor 并用于管理任务和执行器本身的生命周期的附加方法。<ul>
<li>引入了 submit(Callable<T> task) 方法，返回挂起结果 Future<T></li>
</ul>
</li>
<li>AbstractExecutorService：是抽象执行器服务，实现了Executor的基本方法</li>
<li>ThreadPoolExecutor：ThreadPoolExecutor 是 ExecutorService 接口的具体实现，提供了一个灵活可配置的线程池实现，开发者可以使用 ThreadPoolExecutor 实例来管理和执行任务。</li>
<li>ScheduledExecutorService：ScheduledExecutorService在ExecutorService线程池基础接口的基础上提供了定时或延迟执行的抽象方法</li>
<li>ScheduledThreadPoolExecutor：ScheduledThreadPoolExecutor 是 ScheduledExecutorService 的具体实现。</li>
</ul>
<h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><p>ThreadPoolExecutor使用原子整数 ctl - control state 存储线程池的状态，ctl 包含了两个部分：高3位表示 线程池的运行状态，低29位表示 工作线程的数量，这样设计的好处是，保证了操作状态和工作线程数量两个值通过一次CAS操作同时进行赋值，实现了高效的状态管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>状态名</th>
<th>高3位</th>
<th>说明</th>
<th>是否接受任务</th>
<th>是否处理阻塞队列任务</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>线程池处于运行状态（初始状态）</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>线程池处于关闭状态，不再接受新的任务，但会继续执行已经提交的任务即阻塞队列的任务。</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>线程池处于停止状态，不再接受新的任务，也不会执行阻塞队列中的任务，并中断正在执行的任务。</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>所有的任务都已经终止，工作线程数量为0，线程池即将转换到 TERMINATED 状态。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>线程池终止，不再处于任何活动状态。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler rejectExecutionHandler)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：核心线程数 - 线程池的基本大小，即在没有任务需要执行时，线程池的大小始终保持在这个数量（注意刚开始是0，用到才会创建）。即使线程是空闲的，它们也不会被销毁，除非设置了 <code>allowCoreThreadTimeOut</code>。</li>
<li>maximumPoolSize：最大线程数 - 线程池允许创建的最大线程数。<ul>
<li>如果在阻塞队列中有任务等待执行，且已有的线程数小于 <code>corePoolSize</code>，则会创建新的线程作为 核心线程。</li>
<li>如果已有的线程数等于 <code>corePoolSize</code>，新的任务会加入阻塞队列中等待执行。</li>
<li>当阻塞队列已满，有新的任务的来时，创建新的线程作为救急线程直到线程数达到<code>maximumPoolSize</code>，这些救急线程会在不需要时被销毁。</li>
<li>当阻塞队列已满，线程数已经达到 <code>maximumPoolSize</code>，新的任务无法执行，会触发拒绝策略。</li>
</ul>
</li>
<li>keepAliveTime：线程空闲时间 - 当线程池中的线程数超过 <code>corePoolSize</code> 时，多余的空闲救急线程在被终止之前等待新任务的最长时间即从线程空闲开始算起的最大空闲时间。</li>
<li>unit：时间单位 -  用于指定 <code>keepAliveTime</code> 参数的时间单位。</li>
<li>workQueue：阻塞队列 - 用于保存等待执行的任务的阻塞队列。可以使用不同的阻塞队列实现。</li>
<li>threadFactory：线程工厂 - 用于创建新线程的工厂。可以通过自定义线程工厂来指定新线程的属性，如线程名称、优先级等。</li>
<li>rejectExecutionHandler：拒绝策略 - 当任务添加到线程池中被拒绝时的处理策略。</li>
</ul>
<p>注意：只有当阻塞队列为有容量限制的队列时，才会在超过其队列容量大小时，创建最多 maxnumPoolSize - corePoolSize 的数据线程来救急。</p>
<h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><img src="https://s2.loli.net/2024/01/22/ltV1Adp8fZQXOwk.png" alt="image-20240122210258386" style="zoom:50%;" />

<blockquote>
<p>自定义线程池的拒绝策略是指当线程池的任务队列已满并且最大线程数被耗尽的情况下，线程池应对任务处理的一种策略。</p>
</blockquote>
<ul>
<li>AbortPolicy（默认策略）：会直接抛出<code>RejectedExecutionException</code>异常，阻止新任务的提交。</li>
<li>CallerRunsPolicy：当线程池无法接受新任务时，会将任务交给调用者线程来执行。<ul>
<li>保证了任务一定会被执行，但是可能会导致调用者线程的负担增加</li>
</ul>
</li>
<li>AbortPolicy：丢弃无法处理的任务，不提供任何反馈。</li>
<li>DiscardPolicy：丢弃阻塞队列等待时间最长的任务，然后尝试将新任务加入队列。</li>
</ul>
<p>其他框架对于拒绝策略有很多不同的扩展：</p>
<p>dubbo 框架有拒绝策略实现 抛出异常并记录日志，并且dump线程栈帧的信息，方便问题的定位</p>
<p>netty 框架有拒绝策略实现 创建一个新的线程来执行任务</p>
<p>activemq 框架有拒绝策略实现 设置60秒超时等待时间 期间不断尝试将任务放入到队列中</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务task 使用Future获取返回结果 </span></span><br><span class="line"><span class="comment">// 利用synchronized和wait/notifyAll保护性暂停模式 调用future get方法的线程阻塞等待，直到执行callable的线程执行完毕后唤醒它</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行给定的任务集合，并返回代表这些任务的Future对象的列表</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 在上述方法的基础上，设置超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                  <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行给定的任务集合，并返回最先执行结束任务的执行结果</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行给定的任务集合，并返回最先执行结束任务的执行结果，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<h6 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h6><ul>
<li><p>shutdown</p>
<blockquote>
<p>调用 shutdown 方法将线程池的状态更改为 SHUTDOWN，不会接受新的任务，但会将已提交的任务和在阻塞队列中的任务执行完毕。但是shutdown 方法不会阻塞调用者线程的执行，调用者线程会继续执行，而不会等待线程池中的任务执行完毕。</p>
<p>shutdown 方法是一个优雅关闭线程池的方式，让线程池在执行完已提交的任务后安全地终止。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 检查是否有权限关闭线程池</span></span><br><span class="line">        <span class="built_in">this</span>.checkShutdownAccess();</span><br><span class="line">      <span class="comment">// 更新线程池的状态</span></span><br><span class="line">        <span class="built_in">this</span>.advanceRunState(SHUTDOWN);</span><br><span class="line">      <span class="comment">// 打断空闲线程</span></span><br><span class="line">        <span class="built_in">this</span>.interruptIdleWorkers();</span><br><span class="line">      <span class="comment">//  在线程池关闭时执行一些自定义的关闭操作，这是一个可扩展的钩子方法</span></span><br><span class="line">        <span class="built_in">this</span>.onShutdown();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 尝试终结 - 没有运行的线程则直接终结，如果还有线程则让他们自己自己结束，也不会阻塞等待</span></span><br><span class="line">    <span class="built_in">this</span>.tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>shutdownNow</p>
<blockquote>
<p>调用 shutdownNow 方法将线程池的状态更改为 STOP，不会接受新的任务的同时，也会将尝试中断所有工作线程，包括正在执行任务的线程，正在执行任务的线程使用 interrupt 打断，当前阻塞队列中的任务会作为方法的返回结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">  </span><br><span class="line">    List tasks;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.checkShutdownAccess();</span><br><span class="line">        <span class="built_in">this</span>.advanceRunState(STOP);</span><br><span class="line">      <span class="comment">//  中断所有工作线程</span></span><br><span class="line">        <span class="built_in">this</span>.interruptWorkers();</span><br><span class="line">      <span class="comment">// 获取阻塞队列中的任务进行返回</span></span><br><span class="line">        tasks = <span class="built_in">this</span>.drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 尝试终结 - 由于之前的工作线程全部被打断，所以这里所有的线程都会被终结</span></span><br><span class="line">    <span class="built_in">this</span>.tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><blockquote>
<p>Executors 是 基于ThreadPoolExecutor构造 的一个工厂类，提供了很多方法来创建不同用途的线程池。</p>
<p>配置项相对于ThreadPoolExecutor较少，但是某些场景的简化，可能无法满足特定的需求。</p>
</blockquote>
<ul>
<li><p>newFixedThreadPool</p>
<blockquote>
<p>newFixedThreadPool 创建一个固定大小的线程池，当有新的任务提交时，如果线程池中的线程数小于<code>nThreads</code>，则创建新线程来处理任务，否则将任务加入队列等待执行，最多为 nThreads 个核心线程数，没有救急线程。</p>
<p>注意：该构造方法的阻塞队列采用了 LinkedBlockingQueue ，属于无界队列。</p>
<p>使用场景：适用于需要控制并发线程数量或者执行固定数量的任务的场景</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>newCachedThreadPool</p>
<blockquote>
<p>newCachedThreadPool可缓存的线程池，该线程池没有核心线程，最大线程数为 Integer.MAX_VALUE，线程池中的线程数量根据任务的数量动态调整，这些线程都是救急线程，超过60秒会被回收。当有新任务提交时，如果有空闲线程，则重用现有线程，否则创建新线程。</p>
<p>该构造方法的阻塞队列采用了 SynchronousQueue 特殊类型的队列，内部并不存储元素，而是将任务直接交给等待的线程。它的容量为0，意味着每个插入操作必须等待另一个线程的对应移除操作，它这种特性是专门应用于 newCachedThreadPool 的。</p>
<p>使用场景： 适用于任务数量不确定但每个任务执行时间较短、可能有爆发性增长的场景，自动调整线程数量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>newSingleThreadExecutor</p>
<blockquote>
<p>newSingleThreadExecutor 创建一个只有单个线程的线程池。所有提交的任务将按顺序执行，并且保证不会有并发执行的情况。</p>
<p>该构造方法的阻塞队列采用 LinkedBlockingQueue 链式无解队列。</p>
<p>这种只有一个线程的线程池和一个线程串行执行的区别在于：线程池有拒绝策略进行补偿，同时线程池会维护一个线程并保证其的政策工作（即使有线程发生意外终止了，线程池会创建一个新的线程来顶替，保证线程池中始终有且只有一个可用的线程）。</p>
<p>使用场景： 顺序执行的任务</p>
<p>注意：newSingleThreadExecutor方法底层通过FinalizableDelegatedExecutorService装饰，只暴露了 ExecutorService 接口，不能调用 ThreadPoolExecutor 特有的方法，例如 setCorePoolSize 等方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h4><p>线程池让有限的工作线程（worker thread）来轮流地异步处理无限多的任务，采用了工作线程的模式，也有分工模式和享元模式的思想在里面。</p>
<p>在实际的应用场景中，由于不同类型的任务可能有不同的执行特性和优先级，因此不同的任务类型应该使用不同的线程池，这样可以避免饥饿现象的同时，也可以提升运行效率。</p>
<h5 id="饥饿现象"><a href="#饥饿现象" class="headerlink" title="饥饿现象"></a>饥饿现象</h5><p>线程池的饥饿现象是指由于线程不足，导致很多任务无法继续执行的现象。在这种情况下，这些任务可能会一直等待，无法得到执行的机会，因为线程池中的线程资源已经被占满，无法满足所有任务的并发执行需求。</p>
<h4 id="线程池推荐配置"><a href="#线程池推荐配置" class="headerlink" title="线程池推荐配置"></a>线程池推荐配置</h4><p>过小的线程数不能充分利用多核CPU的系统资源，而且会导致饥饿问题的产生；过多的线程数会导致频繁的线程上下文的切换，占用更多的内存。</p>
<h5 id="CPU密集型任务"><a href="#CPU密集型任务" class="headerlink" title="CPU密集型任务"></a>CPU密集型任务</h5><blockquote>
<p>CPU密集型任务指的是 任务执行过程中需要大量的CPU计算资源，这种情况下，可以使用 固定大小的线程池，这样可以确保CPU的资源高效的利用，不会出现频繁的上下文切换而带来的性能上的开销。固定大小的线程池一般采用 <strong>cpu核数 + 1</strong> （+1 目的是 保证当有线程由于页缺失故障或其他原因导致暂停，额外的线程可以顶上，保证CPU时钟周期不被浪费）。</p>
</blockquote>
<h5 id="IO密集型任务"><a href="#IO密集型任务" class="headerlink" title="IO密集型任务"></a>IO密集型任务</h5><blockquote>
<p>IO密集型任务指的是 任务执行过程中会涉及到大量的I0操作(如读写文件、网络通信等)，IO操作会让线程等待，不会占用CPU资源，此时可以提高线程数来提升CPU的利用率。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 = CPU核心数 * 期望CPU利用率 * 总时间（CPU计算时间 + IO等待时间）/ CPU计算时间</span><br></pre></td></tr></table></figure>

<h4 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h4><blockquote>
<p>在任务调度线程池加入之前，jdk提供了 java.util.timer来实现定时功能，但timer的缺点在于所有的任务都是由同一个线程来调度执行，因此所有的任务都是串行执行，在单线程串行处理的情况下，同一时间只有一个任务可以被执行，无法并行，前一个任务的延迟会导致后一个任务的执行时间延迟，前一个任务的抛出的异常会导致线程消失，而是先回收异常线程，再创建一个新的线程。</p>
</blockquote>
<p>引入 任务调度线程池 ScheduledThreadPoolExecutor ，它可以延迟执行任务，也可以定时执行任务，通过设置核心线程数可以防止任务延迟，同时及时执行异常时，线程也不会消失，而是先回收异常线程，再创建一个新的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用  Executors 快速创建 ScheduledExecutorService</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟执行</span></span><br><span class="line">scheduledExecutorService.schedule(Runnable command, <span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="comment">// 固定时间间隔执行[如果任务的执行时间超过了设定的延迟时间，下一个任务会在上一个任务完成后立即启动]</span></span><br><span class="line">scheduledExecutorService.scheduleWithFixedDelay(Runnable command, <span class="type">long</span> initialDelay,<span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="comment">// 固定频率执行[如果任务执行时间超过了设定的频率，下一个任务可能会立即启动，不等待上一个任务的完成]</span></span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period, TimeUnit unit);</span><br></pre></td></tr></table></figure>

<h5 id="任务调度应用"><a href="#任务调度应用" class="headerlink" title="任务调度应用"></a>任务调度应用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每周五 18点定时执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startTaskEveryFriday</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> now.with(DayOfWeek.FRIDAY).withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (time.isBefore(now)) &#123;</span><br><span class="line">        <span class="comment">// 获取下一个周五</span></span><br><span class="line">        time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算时间差值</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> Duration.between(now, time).toMillis();</span><br><span class="line">    logger.info(<span class="string">&quot;time:&#123;&#125;, initialDelay:&#123;&#125;&quot;</span>, time, initialDelay);</span><br><span class="line"></span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;, initialDelay, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池的异常处理"><a href="#线程池的异常处理" class="headerlink" title="线程池的异常处理"></a>线程池的异常处理</h4><blockquote>
<p>线程池的异常不会导致线程池中的线程数量减少，线程池会回收掉异常线程，并创建新的线程补充，因此其他的线程不会收到影响。</p>
</blockquote>
<p>当调用 execute(Runnable r) 方法时，异常会信息会打印在控制台，当调用 submit(Callable c) 方法时，异常信息不会被打印在控制台，而是封装到返回结果 Future 中，使用 future.get 方法可以获取异常并捕获。</p>
<h4 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h4><p>tomcat 核心组成部分主要包括 connector（连接器）和 container（容器）。connector 负责和客户端连接通信；container 负责管理和执行 Servlet。其中 connector 连接器部分使用了 线程池。connector 的架构如下图：</p>
<h5 id="Tomcat架构"><a href="#Tomcat架构" class="headerlink" title="Tomcat架构"></a>Tomcat架构</h5><img src="https://s2.loli.net/2024/01/23/Wb29SZwEokqzKxO.png" alt="image-20240123161842550" style="zoom: 67%;" />

<ul>
<li>LimitLatch：基于semaphore实现的限流，可以控制最大的连接个数</li>
<li>Acceptor：不断执行负责接收新的socket连接</li>
<li>Poller：负责监听 socket channel 是否有 可读的I/O事件，一旦有可读的事件，会封装备为一个任务对象提交给 Executor 线程池执行</li>
<li>Executor 线程池负责将 处理请求</li>
</ul>
<h5 id="Tomcat-Executor线程池流程"><a href="#Tomcat-Executor线程池流程" class="headerlink" title="Tomcat Executor线程池流程"></a>Tomcat Executor线程池流程</h5><p> 如果任务数量超过核心线程数，但没有超过最大线程数，线程池会创建新的线程来处理额外的任务（不会超过核心线程数，这些线程在任务完成后可能会被保留一段时间以备重用，或者在空闲一定时间后被销毁），如果任务数量超过核心线程数和最大线程数的总和，多余的任务才会被放入任务队列中。</p>
<h5 id="Tomcat-Executor线程池扩展"><a href="#Tomcat-Executor线程池扩展" class="headerlink" title="Tomcat Executor线程池扩展"></a>Tomcat Executor线程池扩展</h5><p>Tomcat线程池对于jdk提供的ThreadPoolExecutor线程池进行了扩展：</p>
<p>当总任务到达 maximumPoolSize 并且阻塞队列也满了的时候，它不会抛出 RejectedExecutionException 异常，而是再次尝试将任务放入队列中，如果再不成功则抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.catalina.core.StandardThreadExecutor    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        submittedCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 super 方法执行任务</span></span><br><span class="line">            <span class="built_in">super</span>.execute(command);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (TaskQueue)<span class="built_in">super</span>.getQueue();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 再次尝试将任务放入队列中，如果再不成功则抛出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                        submittedCount.decrementAndGet();</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Queue capacity is full.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    Thread.interrupted();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(x);</span><br><span class="line">                &#125;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> rx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Tomcat-Executor配置"><a href="#Tomcat-Executor配置" class="headerlink" title="Tomcat Executor配置"></a>Tomcat Executor配置</h5><table>
<thead>
<tr>
<th>配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>threadPriority</td>
<td>5</td>
<td>线程优先级</td>
</tr>
<tr>
<td>daemon</td>
<td>true</td>
<td>是否为守护线程</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>25</td>
<td>核心线程数 相当于 corePoolSize</td>
</tr>
<tr>
<td>maxThreads</td>
<td>200</td>
<td>最大线程数 相当于 maximumPoolSize</td>
</tr>
<tr>
<td>maxIdleTime</td>
<td>60000</td>
<td>线程生存时间，单位是毫秒，默认值即 1 分钟</td>
</tr>
<tr>
<td>maxQueueSize</td>
<td>Integer.MAX_VALUE</td>
<td>队列长度</td>
</tr>
<tr>
<td>prestartminSpareThreads</td>
<td>false</td>
<td>核心线程的创建方式：false - 懒加载 true - 预加载</td>
</tr>
</tbody></table>
<h4 id="Fork-Join线程池"><a href="#Fork-Join线程池" class="headerlink" title="Fork/Join线程池"></a>Fork/Join线程池</h4><blockquote>
<p>Fork/Join 线程池是 一种并行处理的线程池，使用了分治的思想，加入多线程，将每个任务进行拆分交给不同的线程来处理，进一步提升运行效率。</p>
<p>分而治之的思想是指：将问题分解成更小子问题并并行处理的思想。</p>
<p>适用于可以进行任务拆分的cpu密集型运算。</p>
<p>Fork/Join 线程池默认创建与cpu核心数大小相同的线程，这是由于需要拆分的任务大多是cpu密集型任务，线程数和cpu核心数相同即可。</p>
</blockquote>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><h6 id="创建任务对象"><a href="#创建任务对象" class="headerlink" title="创建任务对象"></a>创建任务对象</h6><blockquote>
<p>任务类继承抽象类 RecursiveTask<T> - 有返回结果 或者 RecursiveAction - 无返回结果，重写抽象方法 compute </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">	  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">		... </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池 默认线程数 = cpu核心数 Runtime.getRuntime().availableProcessors()</span></span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line">forkJoinPool.invoke(ForkJoinTask&lt;T&gt; task);</span><br></pre></td></tr></table></figure>

<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>模拟 n + … + 5 + 4 + 3 + 2 + 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">			<span class="comment">// 创建线程池 默认线程数 = cpu核心数 Runtime.getRuntime().availableProcessors()</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">      <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">invoke</span> <span class="operator">=</span> forkJoinPool.invoke(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(invoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * n + ... + 5 + 4 + 3 + 2 + 1</span></span><br><span class="line"><span class="comment"> * MyTask(5) = MyTask(4) + 5</span></span><br><span class="line"><span class="comment"> * MyTask(4) = MyTask(3) + 4</span></span><br><span class="line"><span class="comment"> * MyTask(3) = MyTask(2) + 3</span></span><br><span class="line"><span class="comment"> * ....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// MyTask(n) = n + MyTask(n-1)</span></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 让一个线程执行此任务 MyTask(n-1)</span></span><br><span class="line">        myTask.fork();</span><br><span class="line">        <span class="comment">// 获取任务结果 MyTask(n-1)</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> myTask.join();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t;</span><br><span class="line">        logger.info(<span class="string">&quot;join &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t, n, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 日志输出：</span><br><span class="line">  <span class="number">21</span>:<span class="number">02</span>:<span class="number">26</span> [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] com.example.demo.threadpool.MyTask - join <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">  <span class="number">21</span>:<span class="number">02</span>:<span class="number">26</span> [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] com.example.demo.threadpool.MyTask - join <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line">  <span class="number">21</span>:<span class="number">02</span>:<span class="number">26</span> [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] com.example.demo.threadpool.MyTask - join <span class="number">6</span> + <span class="number">4</span> = <span class="number">10</span></span><br><span class="line">  <span class="number">21</span>:<span class="number">02</span>:<span class="number">26</span> [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] com.example.demo.threadpool.MyTask - join <span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line">  <span class="number">15</span></span><br></pre></td></tr></table></figure>

<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>上面的方法 发现任务之间都是相互依赖 MyTask(5) 依赖 MyTask(4) 的结果，这并不能发挥分代并行的优势，基于此改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * n + (n-1) + .. + 2 + 1</span></span><br><span class="line"><span class="comment"> * =&gt; 1 ~ mid  mid + 1 ~ n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyProTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyProTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end + begin) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">MyProTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyProTask</span>(begin, mid);</span><br><span class="line">        <span class="type">MyProTask</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyProTask</span>(mid + <span class="number">1</span>, end);</span><br><span class="line">        t1.fork();</span><br><span class="line">        t2.fork();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">join1</span> <span class="operator">=</span> t1.join();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">join2</span> <span class="operator">=</span> t2.join();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> join1 + join2;</span><br><span class="line">        logger.info(<span class="string">&quot;t1 &#123;&#125; t2 &#123;&#125; result &#123;&#125;&quot;</span>, join1, join2, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<blockquote>
<p>Fork/Join 线程池 的重点在于 任务的拆分，尽量保证发挥分代并行的优势</p>
</blockquote>
<h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>JUC包下的很多工具都是依赖于AQS</p>
<blockquote>
<p>AQS - AbstractQueuedSynchronized 翻译则是 抽象的基于队列的同步器，是阻塞式锁和相关同步器工具的基类。</p>
<p>AQS 的核心思想是使用一个状态变量来表示共享资源的状态，并通过原子性的状态修改和线程阻塞/唤醒等操作来实现对共享资源的安全访问。</p>
</blockquote>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>AQS 的主要特点如下：</p>
<ul>
<li><p>state - 状态：表示 共享资源的状态。它是AQS维护的一个原子性的状态变量，状态可以被多个线程共享，通过 CAS（Compare and Swap）等原子操作进行修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// aqs 内存整数值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">  	</span><br><span class="line"><span class="comment">// stateOffset 用于存储 state 字段在内存中偏移量 用于 UNSAFE 类的修改和读取操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          stateOffset = unsafe.objectFieldOffset</span><br><span class="line">              (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用 乐观锁的 CAS 原子性的将 state 值从 expect 更新到 update</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">      <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>state 支持两种模式：共享模式 - shared mode 和 独占模式 - execlusive mode</p>
<ul>
<li>共享模式：在独占模式下，同一时刻只有一个线程能够获得锁，其他线程必须等待。<ul>
<li>state 值为 0 时表示没有线程持有锁，大于0表示有线程持有锁</li>
<li>常见应用：ReentrantLock</li>
</ul>
</li>
<li>独占模式：在共享模式下，允许多个线程访问共享资源<ul>
<li>state的值为计数器，表示被共享资源的线程数量</li>
<li>常见应用：Semaphore</li>
</ul>
</li>
</ul>
<p>子类需要定义和维护这个状态，实现不同模式下的应用</p>
</li>
<li><p>queue - 等待队列：AQS 使用一个先进先出（FIFO）的等待队【通过节点(Node)来实现的一个双向链表（Double-Linked Queue）】来管理阻塞的线程。当线程请求访问资源但无法获得时，会被加入到等待队列中等待。</p>
</li>
<li><p>condition - 条件变量： AQS 支持条件变量，允许线程按照特定的条件等待或唤醒，实现了更加灵活的线程通信。</p>
</li>
<li><p>exclusiveOwnerThread - 独占锁的线程引用，表示当前锁持有独占锁的线程。</p>
</li>
</ul>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><blockquote>
<p>开发者可以创建自定义的同步器继承 AQS 并实现其抽象方法，从而构建更复杂的同步工具。</p>
</blockquote>
<p>继承AQS需要实现下面的模版方法：</p>
<ul>
<li>tryAcquire：用于尝试获取独占锁</li>
<li>tryRelease：用于尝试释放独占锁</li>
<li>tryAcquireShard：用于尝试释放独占锁</li>
<li>tryReleaseShard：用于尝试释放共享锁</li>
<li>isHeldExclusively：用于判断当前线程是否持有独占锁</li>
</ul>
<p>简单实现一个不可重入的独占锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AqsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(AqsTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyLock</span> <span class="variable">myLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            logger.info(<span class="string">&quot;t1 lock...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;t1 unlock...&quot;</span>);</span><br><span class="line">                myLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            logger.info(<span class="string">&quot;t2 lock...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;t2 unlock...&quot;</span>);</span><br><span class="line">                myLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现不可重入的独占锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySnyc</span> <span class="variable">snyc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySnyc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步器类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySnyc</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// cas 尝试获取独占锁 state 0 无锁 1 已经线程占有锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功 设置当前持有锁的线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进入阻塞队列等待</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// volatile 写屏障</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 获取失败则线程阻塞进入等待队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内部调用了 tryAcquire 方法</span></span><br><span class="line">        snyc.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 可被打断</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        snyc.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试加锁 尝试加锁一次 失败不会阻塞线程 跳出获取锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> snyc.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试加锁一次 并设置超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> snyc.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        snyc.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> snyc.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><h5 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h5><img src="https://s2.loli.net/2024/01/24/19c86kavLQTVFps.png" alt="image-20240124152215431" style="zoom:33%;" />

<p>ReentrantLock内部维护Sync同步器，同步器继承自 aqs，针对Sync抽象同步器，内部提供了两种不同实现：NonfairSync 和 FairSync，分别对应了非公平锁和公平锁。</p>
<h5 id="非公平锁实现"><a href="#非公平锁实现" class="headerlink" title="非公平锁实现"></a>非公平锁实现</h5><p>从无参构造器来看，默认使用的非公平锁的同步器实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 		# reentrantlock.java	</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">      sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h6 id="加锁成功"><a href="#加锁成功" class="headerlink" title="加锁成功"></a>加锁成功</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  # aqs.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">      sync.lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># reentrantlock.java	</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// cas尝试更改 aqs state 判断当前线程获取锁是否成功</span></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">              <span class="comment">// 如果获取锁成功，则修改同步器的独占线程为 当前线程</span></span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 获取锁失败</span></span><br><span class="line">              acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 尝试获取锁</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/01/24/dC9wPeHJGUZutbV.png" alt="image-20240124154216822" style="zoom:50%;" />

<h6 id="加锁失败"><a href="#加锁失败" class="headerlink" title="加锁失败"></a>加锁失败</h6><p>上面加锁失败后，执行了同步器默认实现的 acquire 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 再次尝试获取锁 失败则执行 逻辑与 后面的</span></span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          <span class="comment">// 创建一个等待对象并将其加入到等待队列中</span></span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 线程等待</span></span><br><span class="line">          selfInterrupt();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在将当前线程加入到等待队列后，使线程进入自旋状态等待获取锁</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋尝试获取锁</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();	</span><br><span class="line">            <span class="comment">// 当 当前节点的前驱节点为 head （避免无效竞争 - 只有头部线程有资格去尝试获取锁）并且 尝试获取锁成功时，移除队列  </span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="literal">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> interrupted;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">// 如果无法成功获取锁，检查是否需要将当前线程阻塞（park）</span></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire 会将 前驱节点 waitStatus 改为 -1 （-1表示节点处于等待唤醒状态，它有责任唤醒它的下一个节点）</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  <span class="comment">// 调用 LockSupport.park(this) 阻塞当前线程 </span></span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 修改中断标识</span></span><br><span class="line">                  interrupted = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2024/01/24/FLOUVlCdBcGpqe8.png" alt="image-20240124154930816" style="zoom: 50%;" />

<p>再次尝试获取独占锁失败后，会执行逻辑与之后的逻辑，将阻塞线程添加到队列里</p>
<ul>
<li>addWriter方法</li>
</ul>
<p>AbstractQueuedSynchronizer 的队列通过节点(Node)实现的一个双向链表（Double-Linked Queue），它是由一个虚拟的头结点（head）和一个虚拟的尾结点（tail）组成的。</p>
<p>尝试添加一个节点，首次添加节点时，AQS会创建一个虚拟头结点（head），并将这个头结点作为队列的头部。然后再创建一个表示当前等待线程的真正节点，该节点是独占模式的等待节点，将它添加到队列尾部中，并设置它为尾结点（tail）。虚拟头节点的作用在于高效地进行队列的入队和出队操作。</p>
<img src="https://s2.loli.net/2024/01/24/RiHrKtyvu4NCbTg.png" alt="image-20240124160058839" style="zoom:50%;" />

<ul>
<li>acquireQueued 方法</li>
</ul>
<p>在将当前线程加入到等待队列后，使线程进入自旋状态等待获取锁，自旋获取锁失败则被 park</p>
<img src="https://s2.loli.net/2024/01/24/QXHbgVBe9wNLr1j.png" alt="image-20240124172339160" style="zoom:50%;" />

<h6 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h6><img src="https://s2.loli.net/2024/01/25/fiF5t29j3TxL7eN.png" alt="image-20240125085757914" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    # ReentrantLock.java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # AbstractQueuedSynchonizer.java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">          <span class="comment">// 当前队列不为空，并且 waitStatus 为-1 时 进入unparkSuccessor流程</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              <span class="comment">// unpark 唤醒后继节点 让后继节点的所属线程从被park的地方（即自旋的地方）继续执行</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> # ReentrantLock#Sync.java</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">   <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      free = <span class="literal">true</span>;</span><br><span class="line">      setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   setState(c);</span><br><span class="line">   <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentranctLock 执行 unlock 方法时，会调用 同步器的tryRelease 的方法</p>
<p>方法内部调用 tryRelease 方法，设置 当前同步器的状态为 0 并且设置 exclusiveOwnerThread 为 null  表示当前锁没有被占有</p>
<p>当前队列不为空，并且 waitStatus 为-1 时 进入unparkSuccessor流程</p>
<p>在 unpark 唤醒头节点的后继节点，让后继节点的所属线程从被park的地方（即自旋的地方）继续执行</p>
<ul>
<li><p>当tryAcquire(arg)返回 true 获取锁成功时，同步器的exclusiveOwnerThread为 被唤醒的线程，并设置 state 为1</p>
<ul>
<li><p>阻塞队列的变化：会将当前节点设置为新的头部节点，断开当前头部节点与下一个节点的连接以便垃圾回收，并标记竞争失败的标志为<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line"><span class="comment">// 当 当前节点的前驱节点为 head （避免无效竞争 - 只有头部线程有资格去尝试获取锁）并且 尝试获取锁成功时，移除队列  </span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">	<span class="comment">// 将被唤醒的节点设置为新的头部节点</span></span><br><span class="line">  setHead(node);</span><br><span class="line">  <span class="comment">// 之前的头节点p的 后继节点设置为null 有助于将之前的头部节点p被垃圾回收点</span></span><br><span class="line">  p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">  failed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">  <span class="comment">// 将被唤醒的节点设置为新的头部节点</span></span><br><span class="line">  head = node;</span><br><span class="line">  <span class="comment">// 设置当前节点的线程引用为空 前继节点指向为 null</span></span><br><span class="line">  node.thread = <span class="literal">null</span>;</span><br><span class="line">  node.prev = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="https://s2.loli.net/2024/01/25/XUVhkvjDQH43KBG.png" alt="image-20240125090804035" style="zoom:50%;" /></li>
<li><p>由于为非公平锁的实现，因此当此时有其他线程在锁没有占有的情况下，也尝试获取了锁时，它也可能获取到锁（exclusiveOnwerThread 设置为它，并且 state = 1  ），当被唤醒的线程自旋过程竞争锁失败时，再次被park。</p>
<img src="https://s2.loli.net/2024/01/25/kvmbtZnK1zLYBgW.png" alt="image-20240125090401261" style="zoom:50%;" /></li>
</ul>
<h5 id="可重入锁原理"><a href="#可重入锁原理" class="headerlink" title="可重入锁原理"></a>可重入锁原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">          <span class="comment">// 首次尝试获取锁 将 state 从 0 修改为 1</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 当 exclusiveOwner 为当前线程时， state++</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">              /</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 重入锁释放 state-- </span></span><br><span class="line">       <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">         <span class="comment">// 只是可重入次数减1 而不是释放锁 </span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="comment">// 只有state 为0时，才释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h5><p>reentrantlock 分为两种模式：可打断模式 和 不可打断模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 不可打断模式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">      sync.lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可打断模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h6 id="不可打断模式"><a href="#不可打断模式" class="headerlink" title="不可打断模式"></a>不可打断模式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// 自旋尝试获取锁</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// park 线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// locksupport.park 可以被 thread.interrupt() 中断继续执行</span></span><br><span class="line">  LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">  <span class="comment">// 返回中断标识并清除中断标识，以便再次被 park 住</span></span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 返回当前线程的中断状态，并清除中断标志</span></span><br><span class="line">  <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loksupport.park 可以被 thread.interrupt() 打断继续执行，但是继续执行后，它还是在自旋获取锁的代码中，重新被park掉（park被调用interrupt线程无法再次被park掉，需要调用Thread.interrupted()返回返回中断标识并会清除中断标识，以便再次被 park 住），因此，即使有线程调用打断被阻塞的线程，线程被唤醒还是在自旋获取锁的代码中执行，需要获取锁以后，才跳出循环，打断后正常继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      <span class="comment">// 当获取锁成功时 在这里进行一次打断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 thread.interrupt() 打断</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">  <span class="comment">// 没有获取到锁 </span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// park 线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">              <span class="comment">// 被interrupt打断后抛出异常，跳出for(;;)循环，放弃等待获取锁 </span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="公平性原理"><a href="#公平性原理" class="headerlink" title="公平性原理"></a>公平性原理</h5><h6 id="非公平锁原理"><a href="#非公平锁原理" class="headerlink" title="非公平锁原理"></a>非公平锁原理</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">      <span class="comment">// 调用父类 Sync 中的 nonfairTryAcquire 方法</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">  <span class="comment">// 非公平尝试获取锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">      <span class="comment">// 当前锁的占用标识为 0 时即没有线程持有线程时</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 直接cas尝试获取获取锁，不会进入阻塞队列等待  </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="公平锁原理"><a href="#公平锁原理" class="headerlink" title="公平锁原理"></a>公平锁原理</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># ReentrantLock.java</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">          <span class="comment">// 当前锁的占用标识为 0 时即没有线程持有线程时</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; </span><br><span class="line">          <span class="comment">// 调用 hasQueuedPredecessors 查看队列是否有优先级更高的线程等待执行  </span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># aqs.java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">  <span class="comment">// h != t 头节点和尾节点不相等 说明队列中还有节点</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">          <span class="comment">//  队列中的头节点的下一个节点不为空 并且 该节点的线程不是当前线程</span></span><br><span class="line">            ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="条件变量原理"><a href="#条件变量原理" class="headerlink" title="条件变量原理"></a>条件变量原理</h5><p>ReentrantLock 条件变量对应了一个 ConditionObject 对象，每个 ConditionObject 对象维护了一个 双向链表，保存着等待条件阻塞的线程。</p>
<h6 id="await"><a href="#await" class="headerlink" title="await"></a>await</h6><img src="https://s2.loli.net/2024/01/25/jiHVWON2z6lG1BJ.png" alt="image-20240125104133386" style="zoom:50%;" />

<p>当 thread-0 持有锁时，调用 condition.await 方法，将创建一个状态为2（Node.Condition表示线程在等待条件）关联线程的节点加入到 conditionObject 实例对象的双向链表的尾部中，并且尝试释放重入锁和清空重试次数，设置 exclusiveOwnerThread 为 null，并唤醒阻塞队列的后继节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ConditionObject 是内部类 实现了 Condition 接口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">      </span><br><span class="line">     		<span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        </span><br><span class="line">      	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">          <span class="comment">// 将线程加入到 ConditionObject 实例的双向链表中 </span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">          <span class="comment">// 完成释放重入锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">            <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              <span class="comment">// park 线程</span></span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">  				<span class="comment">//  创建一个状态为2（Node.Condition表示线程在等待条件）关联线程的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取当前线程持有锁的重入次数 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">     			 <span class="comment">// 尝试释放重入锁和清空重试次数</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">     <span class="comment">// 尝试释放重入锁和清空重试次数</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              <span class="comment">// 唤醒阻塞队列的后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><p>调用 thread-1 调用 signal 方法时，将 conditionObject 实例中的双向链表中的第一个节点移出来，改变节点的状态从 Node.CONDITION-2 转换为 0 并将该线程节点转移到等待锁的等待队列中，当 thread-1线程执行完毕后释放锁，会唤醒等待队列中的下一个节点。</p>
 <img src="https://s2.loli.net/2024/01/25/ePWFkYKNEOxnmSV.png" alt="    " style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ConditionObject 是内部类 实现了 Condition 接口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">      </span><br><span class="line">     		<span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// 当前线程是否当前锁的持有者 只有持有锁的线程才能唤醒其他线程</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">          <span class="comment">// 获取队列的第一个元素</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">          <span class="comment">// 当队列的第一个元素不为空时，</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">// firstWaiter = first.nextWaiter 将头节点指向 first 节点的下一个节点，将 first 节点从队列中移除</span></span><br><span class="line">              <span class="comment">// 当第一个节点的后继节点为空时，则说明当前队列内部没有节点 则设置为节点为空</span></span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = <span class="literal">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">              <span class="comment">// transferForSignal 将 该线程节点 转移到等待锁的等待队列中 </span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal( first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">          <span class="comment">// 改变节点的状态 从Node.CONDITION-2转换为0 </span></span><br><span class="line">          <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// 将 唤醒的线程节点 加入到等待队列的尾部，加入成功则返回它在队列中的前驱节点</span></span><br><span class="line">          <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">          <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">          <span class="comment">// 将 迁前驱的节点的状态，修改为 Node.SIGNAL - -1  它有责任唤醒它的下一个节点</span></span><br><span class="line">          <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">              LockSupport.unpark(node.thread);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><h5 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><blockquote>
<p>ReentrantReadWriteLock 提供了一对关联的锁，用于读和写操作，它允许多个线程同时读取资源，同时确保只有一个线程能够进行写操作即实现 “读-读并发 读-写互斥 写写互斥” 的效果。</p>
<ul>
<li>读锁：多个线程可以同时持有读锁，只要当前没有线程持有写锁。</li>
<li>写锁：同一时间只有一个线程能够持有写锁。如果有任何线程持有写锁，则其他线程无法获取读锁或者写锁。</li>
</ul>
<p>适用于 读多写少的场景</p>
<p>注意事项：</p>
<p>读锁不支持条件变量(condition)，因为读锁是非独占的，可以有多个线程持有读锁，但是写锁是独占的，支持条件变量。</p>
<p>重入性 - 持有写锁的线程可以获取读锁，但是持有读锁的线程不可以获取写锁 （支持锁重入的升级 不支持锁重入的降级）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; dataContainer.read()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; dataContainer.write()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DataContainer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;获取读锁&quot;</span>);</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;获取对象&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;获取写锁&quot;</span>);</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;设置对象&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line"><span class="number">21</span>:<span class="number">29</span>:<span class="number">21</span> [Thread-<span class="number">0</span>] com.example.demo.aqs.DataContainer - 获取读锁</span><br><span class="line"><span class="number">21</span>:<span class="number">29</span>:<span class="number">21</span> [Thread-<span class="number">1</span>] com.example.demo.aqs.DataContainer - 获取写锁</span><br><span class="line"><span class="number">21</span>:<span class="number">29</span>:<span class="number">21</span> [Thread-<span class="number">0</span>] com.example.demo.aqs.DataContainer - 获取对象</span><br><span class="line"><span class="number">21</span>:<span class="number">29</span>:<span class="number">22</span> [Thread-<span class="number">0</span>] com.example.demo.aqs.DataContainer - 释放读锁</span><br><span class="line"><span class="number">21</span>:<span class="number">29</span>:<span class="number">22</span> [Thread-<span class="number">1</span>] com.example.demo.aqs.DataContainer - 设置对象</span><br><span class="line"><span class="number">21</span>:<span class="number">29</span>:<span class="number">22</span> [Thread-<span class="number">1</span>] com.example.demo.aqs.DataContainer - 释放写锁</span><br></pre></td></tr></table></figure>

<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><blockquote>
<p>在读写锁的使用过程中，底层利用AQS并使用CAS修改其状态，为了进一步优化读的性能，引入的StampedLock，它的特点是 使用它的读写锁时都需要配合一个戳使用。</p>
</blockquote>
<ul>
<li>读锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.readLock();</span><br><span class="line">stampedLock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<ul>
<li>写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock();</span><br><span class="line">stampedLock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<ul>
<li>乐观读：StampedLock 支持 乐观读，核心方法就是 tryOptimistic 方法，该方法不会加锁，而时获取乐观素的的一个戳，在执行读操作之前，进行一次戳校验，如果戳校验失败，则说明在这期间，没有写线程获取写锁执行写操作，数据可以安全的读取，否则，需要锁升级并重新获取 读锁，保证数据安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="comment">// tryOptimisticRead 方法没有添加任何的锁 只是返回了一个戳</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line">    <span class="comment">// 验戳 防止在获取乐观读锁和执行读操作之间，有其他线程获取写锁执行写操作</span></span><br><span class="line">    <span class="keyword">if</span> (stampedLock.validate(stamp)) &#123;</span><br><span class="line">      <span class="comment">// 验戳一致，直接读取返回</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 验戳不一致即说明有写线程获取写锁执行写操作 锁升级</span></span><br><span class="line">      stampedLock.readLcok();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      stampedLock.unLockRead();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DataContainer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;获取乐观读锁&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stampedLock.validate(stamp)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;验戳成功，开始读取&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            logger.info(<span class="string">&quot;验戳失败，获取读锁，执行读操作&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;获取写锁&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;执行写操作&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>stampedLock不支持条件变量 condition</li>
<li>stampedlock不支持可重入</li>
</ul>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><blockquote>
<p>Semaphore 信号量 用于限制同时访问共享资源的线程上限。</p>
</blockquote>
<p>用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 参数 permits 共享资源同时访问的线程上限</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 尝试信号量</span></span><br><span class="line">      semaphore.acquire();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//... </span></span><br><span class="line">    &#125;	<span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 释放信号量</span></span><br><span class="line">      semaphore.release();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 permits 共享资源同时访问的线程上限</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            logger.info(<span class="string">&quot;获取信号量&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            logger.info(<span class="string">&quot;释放信号量&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br></pre></td></tr></table></figure>

<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li><p>限流：限制访问的线程数量，让没有获取到信号量的线程阻塞，等待其他线程释放许可后，重新获取信号量并运行。这只适合限制单机线程数量。</p>
</li>
<li><p>资源池管理：在数据库连接池，线程池和对象池等场景下，计数信号量可以控制对资源的并发访问，防止资源被过度占用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphorePool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SemaphoreTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接池数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接资源集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] connects;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接资源占用标识数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicIntegerArray statesArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    SemaphorePool(<span class="type">int</span> poolSize) &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="built_in">this</span>.connects = <span class="keyword">new</span> <span class="title class_">Object</span>[poolSize];</span><br><span class="line">        <span class="built_in">this</span>.statesArray = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">        <span class="comment">// 信号量个数和连接池数量一致</span></span><br><span class="line">        <span class="built_in">this</span>.semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(poolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (statesArray.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (statesArray.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;connect:&#123;&#125;&quot;</span>, connects[i]);</span><br><span class="line">                        <span class="keyword">return</span> connects[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disConnect</span><span class="params">(Object conn)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connects[i] == conn) &#123;</span><br><span class="line">                statesArray.set(i, <span class="number">0</span>);</span><br><span class="line">                logger.info(<span class="string">&quot;disconnect:&#123;&#125;&quot;</span>, connects[i]);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="semaphore原理"><a href="#semaphore原理" class="headerlink" title="semaphore原理"></a>semaphore原理</h5><blockquote>
<p>semaphore 底层实现是基于 AQS 实现，将 AQS 的 state 设置为 信号量的许可数。</p>
</blockquote>
<h6 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h6><blockquote>
<p>每次acquire操作将尝试获取一个许可，而release操作将释放一个许可，当 state为正数时，表示有可用的许可，当 state 为零时，表示没有可用的许可，其他线程调用 acquire 方法会被阻塞并且进入 AQS的阻塞队列中。</p>
</blockquote>
<img src="https://s2.loli.net/2024/01/27/uzTFQ7PIieBt1mY.png" alt="image-20240127100622925" style="zoom:33%;" />



<img src="https://s2.loli.net/2024/01/27/vSpPTsXq4ZN69Be.png" alt="image-20240127100641239" style="zoom:33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;  </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 默认构造为 非公平的</span></span><br><span class="line">        NonfairSync(<span class="type">int</span> permits) &#123;</span><br><span class="line">            <span class="built_in">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 默认调用非公平锁实现</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	  <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">// 6. 获取当前 state 即 许可个数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">              <span class="comment">// 7. 减去获取剩余的个数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    <span class="comment">// 8. 许可个数足够则 cas 操作修改 state 至剩余值</span></span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 2. 尝试获取信号量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 3. 调用 sync的父类aqs 的  acquireSharedInterruptibly 方法</span></span><br><span class="line">    	sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 4. 调用 子类重写实现的 tryAcquireShared 方法即 semaphore的 sync中的tryAcquireShared </span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 9. 当 剩余许可不足时，将线程park并进入阻塞队列中</span></span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="release"><a href="#release" class="headerlink" title="release"></a>release</h6><p><img src="https://s2.loli.net/2024/01/27/kodsErwYqR1WAtX.png" alt="image-20240127104327947"></p>
<p><img src="https://s2.loli.net/2024/01/27/Zr9ESNxX5O7K2d4.png" alt="image-20240127104150801"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">              <span class="comment">// 4. state = state + release 释放许可</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">              <span class="comment">// 5. 使用 cas 修改</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 释放信号量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 调用 sync的父类aqs 的releaseShared方法</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="comment">// 3. 调用 semaphore 的 sync 子类重写的 tryReleaseShared 方法</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">          <span class="comment">// 6. 唤醒 阻塞队列中的节点	 </span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h4><blockquote>
<p>CountdownLatch 为 倒计时门栓，用于控制多个线程之间的同步，允许一个线程或者多个线程等待一组操作完成。</p>
<p>CountdownLatch 的核心概念为 计数器，在构造 CountdownLatch 需要指定一个初始化计数器，线程通过调用 await 方法阻塞等待计数器达到0，其他线程通过 调用 countdown 方法递减计数器数值，直到0后，唤醒 调用 await的线程。</p>
</blockquote>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CountDownLatchDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                logger.info(<span class="string">&quot;countdown...&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;await...&quot;</span>);</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                logger.info(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">  await...</span><br><span class="line">  countdown...</span><br><span class="line">  countdown...</span><br><span class="line">  countdown...</span><br><span class="line">  signal</span><br></pre></td></tr></table></figure>

<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><p>一个游戏等待10个人加载完毕，则开始游戏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchApp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CountDownLatchDemo.class);  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        String[] schedules = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">100</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    schedules[a] = j + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">                    logger.info(<span class="string">&quot;\r&quot;</span> + Arrays.toString(schedules));</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        logger.info(<span class="string">&quot;游戏加载完毕&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出：</span><br><span class="line">  [<span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%]</span><br><span class="line">  游戏加载完毕</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CountdownLatch 常用于 多线程执行多个任务，等待多个任务都执行完毕，在执行下面的场景。</p>
</blockquote>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><blockquote>
<p>CyclicBarrier 循环屏障，用于多线程环境下协调多个线程执行任务即线程协作。</p>
<p>​        允许一组线程到达某个共同点之前相互等待，并在所有线程都到达这个点时同时继续执行。</p>
</blockquote>
<h5 id="CyclicBarrier-实现原理"><a href="#CyclicBarrier-实现原理" class="headerlink" title="CyclicBarrier 实现原理"></a>CyclicBarrier 实现原理</h5><blockquote>
<p>CyclicBarrier 内部维护了一个计数器，当每个线程调用 await 方法时，当前线程被阻塞并且 CyclicBarrier 内部的计数器 count 就会减1，当计数器为0时，当所有线程都到达屏障点，屏障就会打开，所有被阻塞的线程被释放。</p>
</blockquote>
<h6 id="CyclicBarrier-循环使用"><a href="#CyclicBarrier-循环使用" class="headerlink" title="CyclicBarrier 循环使用"></a>CyclicBarrier 循环使用</h6><blockquote>
<p>CyclicBarrier 可以被重用，在屏障打开时会自动重置计数器，等待一轮同步。</p>
</blockquote>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CyclicBarrierTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;cyclicBarrier over...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 重用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;task1 begin...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// count--</span></span><br><span class="line">                    logger.info(<span class="string">&quot;task1 end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.submit(()-&gt;&#123;</span><br><span class="line">                logger.info(<span class="string">&quot;task2 begin...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// count--</span></span><br><span class="line">                    logger.info(<span class="string">&quot;task2 end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出三次：</span><br><span class="line">	task1 begin...</span><br><span class="line">  task2 begin... </span><br><span class="line">  cyclicBarrier over...</span><br><span class="line">  task2 end...</span><br><span class="line">  task1 end...</span><br></pre></td></tr></table></figure>

<h4 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h4><h5 id="线程安全集合类概述"><a href="#线程安全集合类概述" class="headerlink" title="线程安全集合类概述"></a>线程安全集合类概述</h5><ul>
<li><p>遗留的安全集合： Vector HashTable </p>
<ul>
<li>所有方法使用 synchronized 修饰 并发性能较低</li>
</ul>
</li>
<li><p>修饰的安全集合：Collections.singletonList(new ArrayList&lt;&gt;())</p>
<ul>
<li>装饰者模式 将线程不安全的集合作为内部的成员变量，操作时依旧使用不安全集合的方法，只是加了 synchronized 锁保证线程安全，并发性能同样较差</li>
</ul>
</li>
<li><p><strong>JUC的安全集合</strong>：包含三大类：Blocking 类，CopyOnWrite 类，Concurrent 类</p>
<ul>
<li><p>Blocking 类：阻塞式的并发集合，大多实现基于锁并提供阻塞方法，线程不满足条件时将会被阻塞。</p>
</li>
<li><p>CopyOnWrite 类：修改时采用拷贝的方式来避免多线程访问时读写的并发安全，只适用于读多写少的场景。</p>
</li>
<li><p>Concurrent 类：高效的并发集合，内部使用cas优化并提供多把锁提高并发度和吞吐量，适用于高并发的读写操作场景，</p>
<ul>
<li><p>弱一致性 ：遍历时的弱一致性，读取弱的一致性等</p>
<p>（注意：迭代器Iterator机制 对于 线程安全的集合遍历时进行修改，使用fail-safe机制，不会抛出异常；而对于 线程不安全的集合遍历时进行修改，使用fail-fast机制，会抛出ConcurrentModificationException异常 ）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h3><h4 id="disruptor"><a href="#disruptor" class="headerlink" title="disruptor"></a>disruptor</h4><p>高性能无锁队列</p>
<h4 id="guava-RateLimiter"><a href="#guava-RateLimiter" class="headerlink" title="guava-RateLimiter"></a>guava-RateLimiter</h4><p>基于信号量的高性能限流器</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">YuanJW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/14/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/">http://example.com/2024/02/14/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/juc/">juc</a></div><div class="post_share"><div class="social-share" data-image="/img/default-cover/2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/ShareJS/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/02/12/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/"><img class="next-cover" src="/img/default-cover/16.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">JUC 并发编程 (二) JMM</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/02/12/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/" title="JUC 并发编程 (二) JMM"><img class="cover" src="/img/default-cover/16.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-12</div><div class="title">JUC 并发编程 (二) JMM</div></div></a></div><div><a href="/2023/02/01/rocketmq/" title="RocketMQ"><img class="cover" src="/img/default-cover/48.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">RocketMQ</div></div></a></div><div><a href="/2024/02/10/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/" title="JUC 并发编程 (一) 基础"><img class="cover" src="/img/default-cover/4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-10</div><div class="title">JUC 并发编程 (一) 基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YuanJW</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XiaoYuanJW" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2754742370@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.</span> <span class="toc-text">JUC并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.</span> <span class="toc-text">并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">自定义线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text">拒绝策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.2.4.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.1.2.4.1.</span> <span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.1.2.4.2.</span> <span class="toc-text">关闭线程池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">Executors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">异步模式之工作线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF%E7%8E%B0%E8%B1%A1"><span class="toc-number">1.1.1.4.1.</span> <span class="toc-text">饥饿现象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8E%A8%E8%8D%90%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">线程池推荐配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.1.5.1.</span> <span class="toc-text">CPU密集型任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.1.5.2.</span> <span class="toc-text">IO密集型任务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">任务调度线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.1.6.1.</span> <span class="toc-text">任务调度应用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">线程池的异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">Tomcat线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Tomcat%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.1.8.1.</span> <span class="toc-text">Tomcat架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tomcat-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.8.2.</span> <span class="toc-text">Tomcat Executor线程池流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tomcat-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.1.8.3.</span> <span class="toc-text">Tomcat Executor线程池扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tomcat-Executor%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.1.8.4.</span> <span class="toc-text">Tomcat Executor配置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fork-Join%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">Fork&#x2F;Join线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.9.1.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.9.1.1.</span> <span class="toc-text">创建任务对象</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.1.9.2.</span> <span class="toc-text">创建线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.1.9.3.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.1.9.4.</span> <span class="toc-text">优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JUC"><span class="toc-number">1.1.2.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ReentrantLock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">ReentrantLock实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">非公平锁实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E6%88%90%E5%8A%9F"><span class="toc-number">1.1.2.2.2.1.</span> <span class="toc-text">加锁成功</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%A4%B1%E8%B4%A5"><span class="toc-number">1.1.2.2.2.2.</span> <span class="toc-text">加锁失败</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.1.2.2.2.3.</span> <span class="toc-text">释放锁</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">可重入锁原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">可打断原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.2.4.1.</span> <span class="toc-text">不可打断模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.2.4.2.</span> <span class="toc-text">可打断模式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.5.</span> <span class="toc-text">公平性原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.5.1.</span> <span class="toc-text">非公平锁原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.5.2.</span> <span class="toc-text">公平锁原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.6.</span> <span class="toc-text">条件变量原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#await"><span class="toc-number">1.1.2.2.6.1.</span> <span class="toc-text">await</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#signal"><span class="toc-number">1.1.2.2.6.2.</span> <span class="toc-text">signal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StampedLock"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">StampedLock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.1.2.3.4.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.2.4.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#semaphore%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.4.2.</span> <span class="toc-text">semaphore原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#acquire"><span class="toc-number">1.1.2.4.2.1.</span> <span class="toc-text">acquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#release"><span class="toc-number">1.1.2.4.2.2.</span> <span class="toc-text">release</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountdownLatch"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">CountdownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">1.1.2.5.1.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CyclicBarrier-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.6.1.</span> <span class="toc-text">CyclicBarrier 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#CyclicBarrier-%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.6.1.1.</span> <span class="toc-text">CyclicBarrier 循环使用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.1.2.6.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">并发集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.2.7.1.</span> <span class="toc-text">线程安全集合类概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">第三方工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#disruptor"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">disruptor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#guava-RateLimiter"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">guava-RateLimiter</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/14/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/" title="JUC 并发编程 (三) JUC并发工具"><img src="/img/default-cover/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 并发编程 (三) JUC并发工具"/></a><div class="content"><a class="title" href="/2024/02/14/3-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7/" title="JUC 并发编程 (三) JUC并发工具">JUC 并发编程 (三) JUC并发工具</a><time datetime="2024-02-13T16:00:00.000Z" title="Created 2024-02-14 00:00:00">2024-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/12/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/" title="JUC 并发编程 (二) JMM"><img src="/img/default-cover/16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 并发编程 (二) JMM"/></a><div class="content"><a class="title" href="/2024/02/12/2-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JMM/" title="JUC 并发编程 (二) JMM">JUC 并发编程 (二) JMM</a><time datetime="2024-02-11T16:00:00.000Z" title="Created 2024-02-12 00:00:00">2024-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/10/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/" title="JUC 并发编程 (一) 基础"><img src="/img/default-cover/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 并发编程 (一) 基础"/></a><div class="content"><a class="title" href="/2024/02/10/1-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/" title="JUC 并发编程 (一) 基础">JUC 并发编程 (一) 基础</a><time datetime="2024-02-09T16:00:00.000Z" title="Created 2024-02-10 00:00:00">2024-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/26/jvm-4-%E5%8E%9F%E7%90%86/" title="jvm 原理"><img src="/img/default-cover/46.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jvm 原理"/></a><div class="content"><a class="title" href="/2024/01/26/jvm-4-%E5%8E%9F%E7%90%86/" title="jvm 原理">jvm 原理</a><time datetime="2024-01-25T16:00:00.000Z" title="Created 2024-01-26 00:00:00">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/15/jvm-3-%E9%AB%98%E7%BA%A7/" title="jvm 高级"><img src="/img/default-cover/55.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jvm 高级"/></a><div class="content"><a class="title" href="/2024/01/15/jvm-3-%E9%AB%98%E7%BA%A7/" title="jvm 高级">jvm 高级</a><time datetime="2024-01-14T16:00:00.000Z" title="Created 2024-01-15 00:00:00">2024-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By YuanJW</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>